import type { ResolvedContract } from "../types/config";
import { formatCode } from "../utils/format";
import {
  toCamelCase,
  type ClarityFunction,
  type ClarityMap,
  type ClarityVariable,
} from "@secondlayer/clarity-types";
import { getTypeForArg } from "../utils/type-mapping";

/**
 * Code generator for contract interfaces
 */

/**
 * Generate shared network utilities for the generated code
 */
function generateNetworkUtils(): string {
  return `/**
 * API URLs for different networks
 */
const API_URLS: Record<'mainnet' | 'testnet' | 'devnet', string> = {
  mainnet: 'https://api.hiro.so',
  testnet: 'https://api.testnet.hiro.so',
  devnet: 'http://localhost:3999'
};

/**
 * Infer network from Stacks address prefix
 * SP/SM = mainnet, ST/SN = testnet
 */
function inferNetworkFromAddress(address: string): 'mainnet' | 'testnet' | undefined {
  if (address.startsWith('SP') || address.startsWith('SM')) return 'mainnet';
  if (address.startsWith('ST') || address.startsWith('SN')) return 'testnet';
  return undefined;
}

/**
 * Get API URL, inferring network from contract address if not specified
 */
function getApiUrl(
  contractAddress: string,
  explicitNetwork?: 'mainnet' | 'testnet' | 'devnet'
): string {
  const network = explicitNetwork ?? inferNetworkFromAddress(contractAddress) ?? 'mainnet';
  return API_URLS[network];
}`;
}

/**
 * Generate validation utilities that are inlined in generated code
 * This avoids requiring external dependencies beyond @stacks/transactions
 */
function generateValidationUtils(): string {
  return `/**
 * Contract name validation regex
 * Must start with letter, contain only letters, numbers, and hyphens, max 128 chars
 */
const CONTRACT_NAME_REGEX = /^[a-zA-Z][a-zA-Z0-9\\-]{0,127}$/;`;
}

export async function generateContractInterface(
  contracts: ResolvedContract[]
): Promise<string> {
  const imports = `import { Cl, validateStacksAddress } from '@stacks/transactions'`;

  const header = `/**
 * Generated by @secondlayer/cli
 * DO NOT EDIT MANUALLY
 *
 * @requires @stacks/transactions - Install with: npm install @stacks/transactions
 */`;

  const validationUtils = generateValidationUtils();
  const networkUtils = generateNetworkUtils();

  const contractsCode = contracts
    .map((contract) => generateContract(contract))
    .join("\n\n");

  const code = `${imports}\n\n${header}\n\n${validationUtils}\n\n${networkUtils}\n\n${contractsCode}`;

  return formatCode(code);
}

function generateContract(contract: ResolvedContract): string {
  const { name, address, contractName, abi } = contract;

  const abiCode = generateAbiConstant(name, abi);

  const methods = abi.functions
    .filter((func: ClarityFunction) => func.access !== "private")
    .map((func: ClarityFunction) => generateMethod(func, address, contractName))
    .join(",\n\n  ");

  // Generate maps object if contract has maps
  const mapsObject = generateMapsObject(abi.maps || [], address, contractName);

  // Generate vars object if contract has variables (only data vars, not constants)
  const varsObject = generateVarsObject(abi.variables || [], address, contractName);

  // Generate constants object if contract has constants
  const constantsObject = generateConstantsObject(abi.variables || [], address, contractName);

  // Combine all members
  const allMembers = [methods, mapsObject, varsObject, constantsObject].filter(Boolean);

  const contractCode = `export const ${name} = {
  address: '${address}',
  contractAddress: '${address}',
  contractName: '${contractName}',

  ${allMembers.join(",\n\n  ")}
} as const`;

  return `${abiCode}\n\n${contractCode}`;
}

function generateAbiConstant(name: string, abi: any): string {
  const abiJson = JSON.stringify(abi, null, 2)
    .replace(/"([a-zA-Z_$][a-zA-Z0-9_$]*)":/g, "$1:") // Only remove quotes from valid JS identifiers
    .replace(/"/g, "'"); // Use single quotes

  return `export const ${name}Abi = ${abiJson} as const`;
}

function generateMethod(
  func: ClarityFunction,
  address: string,
  contractName: string
): string {
  const methodName = toCamelCase(func.name);

  if (func.args.length === 0) {
    return `${methodName}() {
    return {
      contractAddress: '${address}',
      contractName: '${contractName}',
      functionName: '${func.name}',
      functionArgs: []
    }
  }`;
  }

  if (func.args.length === 1) {
    const originalArgName = func.args[0].name;
    const argName = toCamelCase(originalArgName);
    const argType = getTypeForArg(func.args[0]);
    const clarityConversion = generateClarityConversion(argName, func.args[0]);

    return `${methodName}(...args: [{ ${argName}: ${argType} }] | [${argType}]) {
    const ${argName} = args.length === 1 && typeof args[0] === 'object' && args[0] !== null && '${argName}' in args[0]
      ? args[0].${argName}
      : args[0] as ${argType}
    
    return {
      contractAddress: '${address}',
      contractName: '${contractName}',
      functionName: '${func.name}',
      functionArgs: [${clarityConversion}]
    }
  }`;
  }

  const argsList = func.args.map((arg) => toCamelCase(arg.name)).join(", ");
  const argsTypes = func.args
    .map((arg) => {
      const camelName = toCamelCase(arg.name);
      return `${camelName}: ${getTypeForArg(arg)}`;
    })
    .join("; ");
  const argsArray = func.args
    .map((arg) => {
      const argName = toCamelCase(arg.name);
      return generateClarityConversion(argName, arg);
    })
    .join(", ");
  const objectAccess = func.args
    .map((arg) => {
      const camelName = toCamelCase(arg.name);
      return `args[0].${camelName}`;
    })
    .join(", ");
  const positionTypes = func.args.map((arg) => getTypeForArg(arg)).join(", ");

  return `${methodName}(...args: [{ ${argsTypes} }] | [${positionTypes}]) {
    const [${argsList}] = args.length === 1 && typeof args[0] === 'object' && args[0] !== null
      ? [${objectAccess}]
      : args as [${positionTypes}]
    
    return {
      contractAddress: '${address}',
      contractName: '${contractName}',
      functionName: '${func.name}',
      functionArgs: [${argsArray}]
    }
  }`;
}


/**
 * Convert TypeScript value to ClarityValue based on the argument type
 */
function generateClarityConversion(argName: string, argType: any): string {
  const type = argType.type;

  if (typeof type === "string") {
    switch (type) {
      case "uint128":
        return `Cl.uint(${argName})`;
      case "int128":
        return `Cl.int(${argName})`;
      case "bool":
        return `Cl.bool(${argName})`;
      case "principal":
      case "trait_reference":
        return `(() => {
          const [address, contractName] = ${argName}.split(".") as [string, string | undefined];
          if (!validateStacksAddress(address)) {
            throw new Error("Invalid Stacks address format");
          }
          if (contractName !== undefined) {
            if (!CONTRACT_NAME_REGEX.test(contractName)) {
              throw new Error("Invalid contract name format: must start with letter and contain only letters, numbers, and hyphens");
            }
            return Cl.contractPrincipal(address, contractName);
          }
          return Cl.standardPrincipal(${argName});
        })()`;
      default:
        return `${argName}`; // fallback for unknown types
    }
  }

  if (type["string-ascii"]) {
    return `Cl.stringAscii(${argName})`;
  }

  if (type["string-utf8"]) {
    return `Cl.stringUtf8(${argName})`;
  }

  if (type.buff) {
    // Generate flexible buffer conversion code that matches the hooks implementation
    return `(() => {
      const value = ${argName};
      // Direct Uint8Array
      if (value instanceof Uint8Array) {
        return Cl.buffer(value);
      }
      // Object notation with explicit type
      if (typeof value === 'object' && value !== null && value.type && value.value) {
        switch (value.type) {
          case 'ascii':
            return Cl.bufferFromAscii(value.value);
          case 'utf8':
            return Cl.bufferFromUtf8(value.value);
          case 'hex':
            return Cl.bufferFromHex(value.value);
          default:
            throw new Error(\`Unsupported buffer type: \${value.type}\`);
        }
      }
      // Auto-detect string type
      if (typeof value === 'string') {
        // Check for hex (0x prefix or pure hex pattern)
        if (value.startsWith('0x') || /^[0-9a-fA-F]+$/.test(value)) {
          return Cl.bufferFromHex(value);
        }
        // Check for non-ASCII characters (UTF-8) using char code comparison
        const hasNonAscii = value.split('').some(char => char.charCodeAt(0) > 127);
        if (hasNonAscii) {
          return Cl.bufferFromUtf8(value);
        }
        // Default to ASCII for simple ASCII strings
        return Cl.bufferFromAscii(value);
      }
      throw new Error(\`Invalid buffer value: \${value}\`);
    })()`;
  }

  if (type.optional) {
    const innerConversion = generateClarityConversion(argName, {
      type: type.optional,
    });
    return `${argName} !== null ? Cl.some(${innerConversion.replace(argName, `${argName}`)}) : Cl.none()`;
  }

  if (type.list) {
    const innerConversion = generateClarityConversion("item", {
      type: type.list.type,
    });
    const maxLength = type.list.length || 100;
    return `(() => {
      const listValue = ${argName};
      if (listValue.length > ${maxLength}) {
        throw new Error(\`List length \${listValue.length} exceeds max ${maxLength}\`);
      }
      return Cl.list(listValue.map(item => ${innerConversion}));
    })()`;
  }

  if (type.tuple) {
    const requiredFields = type.tuple.map((f: any) => f.name);
    const fieldNames = JSON.stringify(requiredFields);
    const fields = type.tuple
      .map((field: any) => {
        const camelFieldName = toCamelCase(field.name);
        const fieldConversion = generateClarityConversion(
          `tupleValue.${camelFieldName}`,
          { type: field.type }
        );
        return `"${field.name}": ${fieldConversion}`;
      })
      .join(", ");
    return `(() => {
      const tupleValue = ${argName};
      const requiredFields = ${fieldNames};
      for (const fieldName of requiredFields) {
        const camelName = fieldName.replace(/-([a-z])/g, (_: string, l: string) => l.toUpperCase());
        if (!(fieldName in tupleValue) && !(camelName in tupleValue)) {
          throw new Error(\`Missing tuple field: \${fieldName}\`);
        }
      }
      return Cl.tuple({ ${fields} });
    })()`;
  }

  if (type.response) {
    // For response types, we expect the user to pass { ok: value } or { err: value }
    const okConversion = generateClarityConversion(`responseValue.ok`, {
      type: type.response.ok,
    });
    const errConversion = generateClarityConversion(`responseValue.err`, {
      type: type.response.error,
    });
    return `(() => {
      const responseValue = ${argName};
      const hasOk = 'ok' in responseValue;
      const hasErr = 'err' in responseValue;
      if (hasOk && !hasErr) {
        return Cl.ok(${okConversion});
      }
      if (hasErr && !hasOk) {
        return Cl.error(${errConversion});
      }
      throw new Error("Response must have exactly 'ok' or 'err' property");
    })()`;
  }

  // Default fallback
  return `${argName}`;
}

/**
 * Generate maps object with type-safe accessors for contract data maps
 */
function generateMapsObject(
  maps: readonly ClarityMap[],
  address: string,
  contractName: string
): string {
  if (!maps || maps.length === 0) {
    return "";
  }

  const mapMethods = maps.map((map) => {
    const methodName = toCamelCase(map.name);
    const keyType = getTypeForArg({ type: map.key });
    const valueType = getTypeForArg({ type: map.value });
    const keyConversion = generateMapKeyConversion(map.key);

    return `${methodName}: {
      async get(key: ${keyType}, options?: { network?: 'mainnet' | 'testnet' | 'devnet' }): Promise<${valueType} | null> {
        try {
          const { cvToJSON, serializeCV } = await import('@stacks/transactions');
          const baseUrl = getApiUrl('${address}', options?.network);
          const mapKey = ${keyConversion};
          const keyHex = serializeCV(mapKey).toString('hex');

          const response = await fetch(
            \`\${baseUrl}/v2/map_entry/${address}/${contractName}/${map.name}\`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(keyHex)
            }
          );

          if (!response.ok) {
            throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
          }

          const result = await response.json();
          if (!result.data || result.data === '0x09') {
            return null; // none value
          }

          const { deserializeCV } = await import('@stacks/transactions');
          const cv = deserializeCV(result.data);
          const parsed = cvToJSON(cv);
          // Unwrap the (some ...) wrapper
          return parsed.value?.value ?? parsed.value ?? null;
        } catch (error) {
          if (error instanceof Error) {
            throw new Error(\`Map access failed for '${map.name}': \${error.message}\`);
          }
          throw error;
        }
      },
      keyType: ${JSON.stringify(map.key)} as const,
      valueType: ${JSON.stringify(map.value)} as const
    }`;
  });

  return `maps: {
    ${mapMethods.join(",\n\n    ")}
  }`;
}

/**
 * Generate vars object with type-safe accessors for contract data variables
 */
function generateVarsObject(
  variables: readonly ClarityVariable[],
  address: string,
  contractName: string
): string {
  if (!variables || variables.length === 0) {
    return "";
  }

  // Filter to only include mutable data variables (not constants)
  const dataVars = variables.filter((v) => v.access === "variable");

  if (dataVars.length === 0) {
    return "";
  }

  const varMethods = dataVars.map((variable) => {
    const methodName = toCamelCase(variable.name);
    const valueType = getTypeForArg({ type: variable.type });

    return `${methodName}: {
      async get(options?: { network?: 'mainnet' | 'testnet' | 'devnet' }): Promise<${valueType}> {
        try {
          const { cvToJSON, deserializeCV } = await import('@stacks/transactions');
          const baseUrl = getApiUrl('${address}', options?.network);

          const response = await fetch(
            \`\${baseUrl}/v2/data_var/${address}/${contractName}/${variable.name}?proof=0\`
          );

          if (!response.ok) {
            throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
          }

          const result = await response.json();
          const cv = deserializeCV(result.data);
          const parsed = cvToJSON(cv);
          return parsed.value ?? parsed;
        } catch (error) {
          if (error instanceof Error) {
            throw new Error(\`Variable access failed for '${variable.name}': \${error.message}\`);
          }
          throw error;
        }
      },
      type: ${JSON.stringify(variable.type)} as const
    }`;
  });

  return `vars: {
    ${varMethods.join(",\n\n    ")}
  }`;
}

/**
 * Generate constants object with type-safe accessors for contract constants
 */
function generateConstantsObject(
  variables: readonly ClarityVariable[],
  address: string,
  contractName: string
): string {
  if (!variables || variables.length === 0) {
    return "";
  }

  // Filter to only include constants
  const constants = variables.filter((v) => v.access === "constant");

  if (constants.length === 0) {
    return "";
  }

  const constMethods = constants.map((constant) => {
    const methodName = toCamelCase(constant.name);
    const valueType = getTypeForArg({ type: constant.type });

    return `${methodName}: {
      async get(options?: { network?: 'mainnet' | 'testnet' | 'devnet' }): Promise<${valueType}> {
        try {
          const { cvToJSON, deserializeCV } = await import('@stacks/transactions');
          const baseUrl = getApiUrl('${address}', options?.network);

          const response = await fetch(
            \`\${baseUrl}/v2/constant_val/${address}/${contractName}/${constant.name}?proof=0\`
          );

          if (!response.ok) {
            throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
          }

          const result = await response.json();
          const cv = deserializeCV(result.data);
          const parsed = cvToJSON(cv);
          return parsed.value ?? parsed;
        } catch (error) {
          if (error instanceof Error) {
            throw new Error(\`Constant access failed for '${constant.name}': \${error.message}\`);
          }
          throw error;
        }
      },
      type: ${JSON.stringify(constant.type)} as const
    }`;
  });

  return `constants: {
    ${constMethods.join(",\n\n    ")}
  }`;
}

/**
 * Generate Clarity conversion for map key
 */
function generateMapKeyConversion(keyType: any): string {
  // Map keys are typically tuples or simple types
  if (keyType.tuple) {
    const fields = keyType.tuple
      .map((field: any) => {
        const camelFieldName = toCamelCase(field.name);
        const fieldConversion = generateClarityConversion(
          `key.${camelFieldName}`,
          { type: field.type }
        );
        return `"${field.name}": ${fieldConversion}`;
      })
      .join(", ");
    return `Cl.tuple({ ${fields} })`;
  }

  // Single-value keys
  return generateClarityConversion("key", { type: keyType });
}
