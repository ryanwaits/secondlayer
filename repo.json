{
  "fileSummary": {
    "generationHeader": "This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.",
    "purpose": "This file contains a packed representation of a subset of the repository's contents that is considered the most important context.\nIt is designed to be easily consumable by AI systems for analysis, code review,\nor other automated processes.",
    "fileFormat": "The content is organized as follows:\n1. This summary section\n2. Repository information\n3. Directory structure\n4. Repository files, each consisting of:\n   - File path as a key\n   - Full contents of the file as the value",
    "usageGuidelines": "- This file should be treated as read-only. Any changes should be made to the\n  original repository files, not this packed version.\n- When processing this file, use the file path to distinguish\n  between different files in the repository.\n- Be aware that this file may contain sensitive information. Handle it with\n  the same level of security as you would the original repository.\n- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.",
    "notes": "- Some files may have been excluded based on .gitignore rules and Repomix's configuration\n- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files\n- Files matching these patterns are excluded: node_modules/**, bun.lock, *.lock\n- Files matching patterns in .gitignore are excluded\n- Files matching default ignore patterns are excluded\n- Long base64 data strings (e.g., data:image/png;base64,...) have been truncated to reduce token count\n- Files are sorted by Git change count (files with more changes are at the bottom)\n- Git diffs from the worktree and staged changes are included\n- Git logs (50 commits) are included to show development patterns"
  },
  "userProvidedHeader": "This repository contains the code for Secondlayer - Clarity contract tooling.",
  "directoryStructure": ".changeset/\n  config.json\n  README.md\n.claude/\n  settings.local.json\n.cursor/\n  plans/\npackages/\n  clarity-docs/\n    src/\n      generators/\n        index.ts\n        json.ts\n        markdown.ts\n      parser/\n        extractor.ts\n        index.ts\n        lexer.ts\n        parser.ts\n      types/\n        doc-block.ts\n        index.ts\n        tags.ts\n      utils/\n        index.ts\n        strip.ts\n      validation/\n        index.ts\n        validators.ts\n      index.ts\n    tests/\n      generators.test.ts\n      parser.test.ts\n    bunup.config.ts\n    CHANGELOG.md\n    package.json\n    SIP-DRAFT-claritydoc.md\n    tsconfig.json\n    vitest.config.ts\n  clarity-types/\n    src/\n      abi/\n        extractors.ts\n        functions.ts\n      converters/\n        index.ts\n      integration/\n        connect.ts\n      types/\n        composites.ts\n        mappings.ts\n        primitives.ts\n      utils/\n        index.ts\n      validation/\n        guards.ts\n      index.ts\n    tests/\n      camelcase-conversion.test.ts\n      runtime.test.ts\n      trait-reference.test.ts\n      types.test.ts\n    bunup.config.ts\n    CHANGELOG.md\n    gpt-5.1-codex-max-high-clarity-types-audit.md\n    package.json\n    README.md\n    tsconfig.json\n    vitest.config.ts\n  cli/\n    src/\n      commands/\n        generate.ts\n        init.ts\n      core/\n        plugin-manager.ts\n      generated/\n        provider.tsx\n        stacks-api.ts\n      generators/\n        contract.ts\n        hooks.ts\n        react-provider.ts\n        stacks-api-generator.ts\n        stacks-api.ts\n      parsers/\n        clarity.ts\n      plugins/\n        actions/\n          generators.ts\n          index.ts\n        clarinet/\n          index.ts\n        react/\n          generators/\n            contract.ts\n            generic.ts\n            utils.ts\n          provider/\n            context.ts\n            index.ts\n            provider.tsx\n            types.ts\n          index.ts\n          types.ts\n        testing/\n          generators.ts\n          index.ts\n        index.ts\n      react/\n        config.ts\n        hooks.ts\n        index.ts\n        types.ts\n      types/\n        config.ts\n        plugin.ts\n      utils/\n        abi-compat.ts\n        api.ts\n        config.ts\n        dependencies.ts\n        format.ts\n        type-mapping.ts\n      cli.ts\n      index.ts\n    tests/\n      fixtures/\n        counter.clar\n        simple-token.clar\n      actions-plugin.test.ts\n      buffer-conversion.test.ts\n      generator.test.ts\n      maps-variables.test.ts\n      type-safety.test.ts\n    biome.json\n    bunup.config.ts\n    CHANGELOG.md\n    package.json\n    tsconfig.json\n.gitignore\nCLAUDE.md\nLICENSE\npackage.json\nREADME.md\nrepomix.config.jsonc\ntsconfig.json",
  "files": {
    ".claude/settings.local.json": "{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(tree:*)\",\n      \"WebFetch(domain:bunup.dev)\",\n      \"Bash(find:*)\",\n      \"Bash(bun run test:cli:*)\",\n      \"Bash(bun run clean:*)\",\n      \"Bash(bun run build)\",\n      \"Bash(bun run build:types:*)\",\n      \"Bash(bun run typecheck:*)\",\n      \"WebFetch(domain:github.com)\"\n    ]\n  }\n}",
    "CLAUDE.md": "In all interactions, plans, and commit messages, be extremely concise and sacrifice grammar for the sake of concision.",
    "repomix.config.jsonc": "{\n  \"$schema\": \"https://repomix.com/schemas/latest/schema.json\",\n  \"input\": {\n    \"maxFileSize\": 50000000,\n  },\n  \"output\": {\n    \"filePath\": \"repo.json\",\n    \"style\": \"json\",\n    \"parsableStyle\": false,\n    \"compress\": false,\n    \"headerText\": \"This repository contains the code for Secondlayer - Clarity contract tooling.\",\n    \"fileSummary\": true,\n    \"directoryStructure\": true,\n    \"files\": true,\n    \"removeComments\": false,\n    \"removeEmptyLines\": false,\n    \"topFilesLength\": 5,\n    \"showLineNumbers\": false,\n    \"includeEmptyDirectories\": true,\n    \"truncateBase64\": true,\n    \"tokenCountTree\": 50000,\n    \"git\": {\n      \"sortByChanges\": true,\n      \"sortByChangesMaxCommits\": 100,\n      \"includeDiffs\": true,\n      \"includeLogs\": true,\n      \"includeLogsCount\": 50,\n    },\n  },\n  \"include\": [],\n  \"ignore\": {\n    \"useGitignore\": true,\n    \"useDefaultPatterns\": true,\n    \"customPatterns\": [\n      \"node_modules/**\",\n      \"bun.lock\",\n      \"*.lock\",\n    ],\n  },\n  \"security\": {\n    \"enableSecurityCheck\": true,\n  },\n  \"tokenCount\": {\n    \"encoding\": \"o200k_base\",\n  },\n}",
    ".changeset/config.json": "{\n  \"$schema\": \"https://unpkg.com/@changesets/config@3.1.2/schema.json\",\n  \"changelog\": [\n    \"@changesets/changelog-github\",\n    { \"repo\": \"ryanwaits/secondlayer\" }\n  ],\n  \"commit\": false,\n  \"fixed\": [],\n  \"linked\": [],\n  \"access\": \"public\",\n  \"baseBranch\": \"main\",\n  \"updateInternalDependencies\": \"patch\",\n  \"ignore\": []\n}",
    ".changeset/README.md": "# Changesets\n\nHello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works\nwith multi-package repos, or single-package repos to help you version and publish your code. You can\nfind the full documentation for it [in our repository](https://github.com/changesets/changesets)\n\nWe have a quick list of common questions to get you started engaging with this project in\n[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)",
    "packages/clarity-docs/src/generators/index.ts": "export * from \"./markdown\";\nexport * from \"./json\";",
    "packages/clarity-docs/src/generators/json.ts": "/**\n * Generate JSON output from ClarityDoc\n */\n\nimport type { ContractDoc, FunctionDoc, MapDoc, VariableDoc, TraitDoc } from \"../types/doc-block\";\n\n/** JSON-serializable function documentation */\nexport interface JsonFunctionDoc {\n  name: string;\n  access: \"public\" | \"read-only\" | \"private\";\n  desc?: string;\n  dev?: string;\n  params: Array<{ name: string; description: string }>;\n  ok?: string;\n  errs: Array<{ code: string; description: string }>;\n  posts: Array<{ asset: string; description: string }>;\n  examples: string[];\n  prints: Array<{ name: string; type?: string; description: string }>;\n  calls: Array<{ contract: string; function: string; description?: string }>;\n  callers: string[];\n  deprecated?: string;\n  version?: string;\n  see: string[];\n}\n\n/** JSON-serializable map documentation */\nexport interface JsonMapDoc {\n  name: string;\n  desc?: string;\n  dev?: string;\n  key?: string;\n  value?: string;\n  deprecated?: string;\n  version?: string;\n  see: string[];\n}\n\n/** JSON-serializable variable documentation */\nexport interface JsonVariableDoc {\n  name: string;\n  type: \"variable\" | \"constant\";\n  desc?: string;\n  dev?: string;\n  deprecated?: string;\n  version?: string;\n  see: string[];\n  /** For error constants: marks this as an error constant */\n  isError?: boolean;\n  /** For error constants: human-readable error description */\n  errorDescription?: string;\n  /** For error constants: extracted error code (e.g., \"u67\") */\n  errorCode?: string;\n  /** Usage examples */\n  examples?: string[];\n}\n\n/** JSON-serializable trait documentation */\nexport interface JsonTraitDoc {\n  name: string;\n  desc?: string;\n  dev?: string;\n  deprecated?: string;\n  version?: string;\n  see: string[];\n}\n\n/** JSON-serializable contract documentation */\nexport interface JsonContractDoc {\n  header: {\n    contract?: string;\n    author?: string;\n    desc?: string;\n    dev?: string;\n    version?: string;\n    deprecated?: string;\n    see: string[];\n    implements: string[];\n    custom: Record<string, string>;\n    /** Off-chain documentation URL */\n    uri?: string;\n    /** Documentation hash for integrity verification */\n    docsHash?: string;\n  };\n  functions: JsonFunctionDoc[];\n  maps: JsonMapDoc[];\n  variables: JsonVariableDoc[];\n  constants: JsonVariableDoc[];\n  traits: JsonTraitDoc[];\n  sourcePath?: string;\n}\n\n/** Convert ContractDoc to JSON-serializable format */\nexport function toJson(doc: ContractDoc): JsonContractDoc {\n  return {\n    header: {\n      contract: doc.header.contract,\n      author: doc.header.author,\n      desc: doc.header.desc,\n      dev: doc.header.dev,\n      version: doc.header.version,\n      deprecated: doc.header.deprecated,\n      see: doc.header.see,\n      implements: doc.header.implements,\n      custom: Object.fromEntries(doc.header.custom),\n      uri: doc.header.uri,\n      docsHash: doc.header.docsHash,\n    },\n    functions: Array.from(doc.functions.values()).map(convertFunction),\n    maps: Array.from(doc.maps.values()).map(convertMap),\n    variables: Array.from(doc.variables.values()).map((v) => convertVariable(v, \"variable\")),\n    constants: Array.from(doc.constants.values()).map((v) => convertVariable(v, \"constant\")),\n    traits: Array.from(doc.traits.values()).map(convertTrait),\n    sourcePath: doc.sourcePath,\n  };\n}\n\nfunction convertFunction(func: FunctionDoc): JsonFunctionDoc {\n  return {\n    name: func.functionName,\n    access: func.access,\n    desc: func.desc,\n    dev: func.dev,\n    params: func.params,\n    ok: func.ok,\n    errs: func.errs,\n    posts: func.posts,\n    examples: func.examples,\n    prints: func.prints,\n    calls: func.calls,\n    callers: func.callers,\n    deprecated: func.deprecated,\n    version: func.version,\n    see: func.see,\n  };\n}\n\nfunction convertMap(map: MapDoc): JsonMapDoc {\n  return {\n    name: map.mapName,\n    desc: map.desc,\n    dev: map.dev,\n    key: map.key,\n    value: map.value,\n    deprecated: map.deprecated,\n    version: map.version,\n    see: map.see,\n  };\n}\n\nfunction convertVariable(variable: VariableDoc, type: \"variable\" | \"constant\"): JsonVariableDoc {\n  return {\n    name: variable.variableName,\n    type,\n    desc: variable.desc,\n    dev: variable.dev,\n    deprecated: variable.deprecated,\n    version: variable.version,\n    see: variable.see,\n    isError: variable.isError,\n    errorDescription: variable.errorDescription,\n    errorCode: variable.errorCode,\n    examples: variable.examples,\n  };\n}\n\nfunction convertTrait(trait: TraitDoc): JsonTraitDoc {\n  return {\n    name: trait.traitName,\n    desc: trait.desc,\n    dev: trait.dev,\n    deprecated: trait.deprecated,\n    version: trait.version,\n    see: trait.see,\n  };\n}\n\n/** Generate JSON string from ContractDoc */\nexport function generateJson(doc: ContractDoc, pretty = true): string {\n  const json = toJson(doc);\n  return pretty ? JSON.stringify(json, null, 2) : JSON.stringify(json);\n}",
    "packages/clarity-docs/src/generators/markdown.ts": "/**\n * Generate Markdown documentation from ClarityDoc\n */\n\nimport type { ClarityContract } from \"@secondlayer/clarity-types\";\nimport type { ContractDoc, FunctionDoc, MapDoc, VariableDoc } from \"../types/doc-block\";\n\n/** Options for markdown generation */\nexport interface MarkdownOptions {\n  /** Include private functions */\n  includePrivate?: boolean;\n  /** Include table of contents */\n  includeToc?: boolean;\n  /** Contract name for the title */\n  contractName?: string;\n  /** Include ABI type information */\n  includeTypes?: boolean;\n}\n\n/** Generate Markdown documentation */\nexport function generateMarkdown(doc: ContractDoc, abi?: ClarityContract, options: MarkdownOptions = {}): string {\n  const lines: string[] = [];\n  const { includePrivate = false, includeToc = true, contractName, includeTypes = true } = options;\n\n  // Title\n  const title = doc.header.contract || contractName || \"Contract Documentation\";\n  lines.push(`# ${title}`);\n  lines.push(\"\");\n\n  // Contract header\n  if (doc.header.desc) {\n    lines.push(doc.header.desc);\n    lines.push(\"\");\n  }\n\n  if (doc.header.author) {\n    lines.push(`**Author:** ${doc.header.author}`);\n    lines.push(\"\");\n  }\n\n  if (doc.header.dev) {\n    lines.push(`> ${doc.header.dev}`);\n    lines.push(\"\");\n  }\n\n  if (doc.header.deprecated) {\n    lines.push(`> **Deprecated:** ${doc.header.deprecated}`);\n    lines.push(\"\");\n  }\n\n  if (doc.header.implements.length > 0) {\n    lines.push(\"**Implements:**\");\n    for (const impl of doc.header.implements) {\n      lines.push(`- \\`${impl}\\``);\n    }\n    lines.push(\"\");\n  }\n\n  // Documentation link\n  if (doc.header.uri) {\n    const hashNote = doc.header.docsHash ? ` (hash: \\`${doc.header.docsHash}\\`)` : \"\";\n    lines.push(`**Documentation:** [${doc.header.uri}](${doc.header.uri})${hashNote}`);\n    lines.push(\"\");\n  }\n\n  // Separate error constants from regular constants\n  const errorConstants = Array.from(doc.constants.values()).filter((c) => c.isError);\n  const regularConstants = Array.from(doc.constants.values()).filter((c) => !c.isError);\n\n  // Table of contents\n  if (includeToc) {\n    lines.push(\"## Table of Contents\");\n    lines.push(\"\");\n    if (doc.functions.size > 0) lines.push(\"- [Functions](#functions)\");\n    if (doc.maps.size > 0) lines.push(\"- [Maps](#maps)\");\n    if (errorConstants.length > 0) lines.push(\"- [Error Constants](#error-constants)\");\n    if (doc.variables.size > 0 || regularConstants.length > 0) lines.push(\"- [Variables](#variables)\");\n    lines.push(\"\");\n  }\n\n  // Functions\n  const functions = Array.from(doc.functions.values()).filter(\n    (f) => includePrivate || f.access !== \"private\"\n  );\n\n  if (functions.length > 0) {\n    lines.push(\"## Functions\");\n    lines.push(\"\");\n\n    for (const func of functions) {\n      lines.push(...generateFunctionMarkdown(func, abi?.functions.find((f) => f.name === func.functionName), includeTypes));\n      lines.push(\"\");\n    }\n  }\n\n  // Maps\n  if (doc.maps.size > 0) {\n    lines.push(\"## Maps\");\n    lines.push(\"\");\n\n    for (const map of doc.maps.values()) {\n      lines.push(...generateMapMarkdown(map, abi?.maps?.find((m) => m.name === map.mapName), includeTypes));\n      lines.push(\"\");\n    }\n  }\n\n  // Error Constants (separate section for wallet/explorer integration)\n  if (errorConstants.length > 0) {\n    lines.push(\"## Error Constants\");\n    lines.push(\"\");\n    lines.push(\"| Code | Name | Description |\");\n    lines.push(\"|------|------|-------------|\");\n\n    for (const errConst of errorConstants) {\n      const code = errConst.errorCode ? `\\`${errConst.errorCode}\\`` : \"-\";\n      lines.push(`| ${code} | \\`${errConst.variableName}\\` | ${errConst.errorDescription || errConst.desc || \"-\"} |`);\n    }\n    lines.push(\"\");\n  }\n\n  // Variables and Constants\n  if (doc.variables.size > 0 || regularConstants.length > 0) {\n    lines.push(\"## Variables\");\n    lines.push(\"\");\n\n    for (const variable of regularConstants) {\n      lines.push(...generateVariableMarkdown(variable, abi?.variables?.find((v) => v.name === variable.variableName), includeTypes));\n      lines.push(\"\");\n    }\n\n    for (const variable of doc.variables.values()) {\n      lines.push(...generateVariableMarkdown(variable, abi?.variables?.find((v) => v.name === variable.variableName), includeTypes));\n      lines.push(\"\");\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\nfunction generateFunctionMarkdown(\n  func: FunctionDoc,\n  abiFunc?: ClarityContract[\"functions\"][number],\n  includeTypes = true\n): string[] {\n  const lines: string[] = [];\n\n  // Function header with access badge\n  const accessBadge = func.access === \"public\" ? \"public\" : func.access === \"read-only\" ? \"read-only\" : \"private\";\n  lines.push(`### \\`${func.functionName}\\``);\n  lines.push(\"\");\n  lines.push(`\\`${accessBadge}\\``);\n  lines.push(\"\");\n\n  if (func.deprecated) {\n    lines.push(`> **Deprecated:** ${func.deprecated}`);\n    lines.push(\"\");\n  }\n\n  if (func.desc) {\n    lines.push(func.desc);\n    lines.push(\"\");\n  }\n\n  if (func.dev) {\n    lines.push(`> ${func.dev}`);\n    lines.push(\"\");\n  }\n\n  // Parameters\n  if (func.params.length > 0) {\n    lines.push(\"**Parameters:**\");\n    lines.push(\"\");\n    lines.push(\"| Name | Type | Description |\");\n    lines.push(\"|------|------|-------------|\");\n\n    for (const param of func.params) {\n      const abiArg = abiFunc?.args.find((a) => a.name === param.name);\n      const typeStr = includeTypes && abiArg ? `\\`${formatType(abiArg.type)}\\`` : \"-\";\n      lines.push(`| \\`${param.name}\\` | ${typeStr} | ${param.description} |`);\n    }\n    lines.push(\"\");\n  }\n\n  // Ok value\n  if (func.ok) {\n    const returnType = includeTypes && abiFunc ? ` (\\`${formatType(abiFunc.outputs)}\\`)` : \"\";\n    lines.push(`**Ok:**${returnType} ${func.ok}`);\n    lines.push(\"\");\n  }\n\n  // Errs\n  if (func.errs.length > 0) {\n    lines.push(\"**Errs:**\");\n    lines.push(\"\");\n    for (const err of func.errs) {\n      lines.push(`- \\`${err.code}\\`: ${err.description}`);\n    }\n    lines.push(\"\");\n  }\n\n  // Posts (postconditions)\n  if (func.posts.length > 0) {\n    lines.push(\"**Postconditions:**\");\n    lines.push(\"\");\n    for (const post of func.posts) {\n      lines.push(`- \\`${post.asset}\\`: ${post.description}`);\n    }\n    lines.push(\"\");\n  }\n\n  // Examples\n  if (func.examples.length > 0) {\n    lines.push(\"**Examples:**\");\n    lines.push(\"\");\n    for (const example of func.examples) {\n      lines.push(\"```clarity\");\n      lines.push(example);\n      lines.push(\"```\");\n    }\n    lines.push(\"\");\n  }\n\n  // Prints\n  if (func.prints.length > 0) {\n    lines.push(\"**Prints:**\");\n    lines.push(\"\");\n    for (const p of func.prints) {\n      const typeStr = p.type ? ` \\`{${p.type}}\\`` : \"\";\n      lines.push(`- \\`${p.name}\\`${typeStr}: ${p.description}`);\n    }\n    lines.push(\"\");\n  }\n\n  // Authorization (callers)\n  if (func.callers.length > 0) {\n    lines.push(\"**Authorization:**\");\n    lines.push(\"\");\n    for (const caller of func.callers) {\n      lines.push(`- ${caller}`);\n    }\n    lines.push(\"\");\n  }\n\n  // External calls\n  if (func.calls.length > 0) {\n    lines.push(\"**Calls:**\");\n    lines.push(\"\");\n    for (const call of func.calls) {\n      const desc = call.description ? ` - ${call.description}` : \"\";\n      lines.push(`- \\`${call.contract}\\` â†’ \\`${call.function}\\`${desc}`);\n    }\n    lines.push(\"\");\n  }\n\n  return lines;\n}\n\nfunction generateMapMarkdown(\n  map: MapDoc,\n  abiMap?: ClarityContract[\"maps\"] extends readonly (infer T)[] | undefined ? T : never,\n  includeTypes = true\n): string[] {\n  const lines: string[] = [];\n\n  lines.push(`### \\`${map.mapName}\\``);\n  lines.push(\"\");\n\n  if (map.deprecated) {\n    lines.push(`> **Deprecated:** ${map.deprecated}`);\n    lines.push(\"\");\n  }\n\n  if (map.desc) {\n    lines.push(map.desc);\n    lines.push(\"\");\n  }\n\n  if (map.dev) {\n    lines.push(`> ${map.dev}`);\n    lines.push(\"\");\n  }\n\n  // Key and Value\n  if (map.key || map.value || abiMap) {\n    lines.push(\"| | Type | Description |\");\n    lines.push(\"|---|------|-------------|\");\n\n    const keyType = includeTypes && abiMap ? `\\`${formatType(abiMap.key)}\\`` : \"-\";\n    const valueType = includeTypes && abiMap ? `\\`${formatType(abiMap.value)}\\`` : \"-\";\n\n    lines.push(`| **Key** | ${keyType} | ${map.key || \"-\"} |`);\n    lines.push(`| **Value** | ${valueType} | ${map.value || \"-\"} |`);\n    lines.push(\"\");\n  }\n\n  return lines;\n}\n\nfunction generateVariableMarkdown(\n  variable: VariableDoc,\n  abiVar?: ClarityContract[\"variables\"] extends readonly (infer T)[] | undefined ? T : never,\n  includeTypes = true\n): string[] {\n  const lines: string[] = [];\n\n  const badge = variable.target === \"constant\" ? \"constant\" : \"data-var\";\n  lines.push(`### \\`${variable.variableName}\\``);\n  lines.push(\"\");\n  lines.push(`\\`${badge}\\``);\n\n  if (includeTypes && abiVar) {\n    lines.push(` \\`${formatType(abiVar.type)}\\``);\n  }\n  lines.push(\"\");\n\n  if (variable.deprecated) {\n    lines.push(`> **Deprecated:** ${variable.deprecated}`);\n    lines.push(\"\");\n  }\n\n  if (variable.desc) {\n    lines.push(variable.desc);\n    lines.push(\"\");\n  }\n\n  if (variable.dev) {\n    lines.push(`> ${variable.dev}`);\n    lines.push(\"\");\n  }\n\n  // Examples (for constants)\n  if (variable.examples && variable.examples.length > 0) {\n    lines.push(\"**Examples:**\");\n    lines.push(\"\");\n    for (const example of variable.examples) {\n      lines.push(\"```clarity\");\n      lines.push(example);\n      lines.push(\"```\");\n    }\n    lines.push(\"\");\n  }\n\n  return lines;\n}\n\n/** Format a Clarity type for display */\nfunction formatType(type: unknown): string {\n  if (typeof type === \"string\") {\n    return type;\n  }\n\n  if (typeof type === \"object\" && type !== null) {\n    const obj = type as Record<string, unknown>;\n\n    if (\"optional\" in obj) {\n      return `(optional ${formatType(obj.optional)})`;\n    }\n    if (\"list\" in obj) {\n      const list = obj.list as { type: unknown; length: number };\n      return `(list ${list.length} ${formatType(list.type)})`;\n    }\n    if (\"response\" in obj) {\n      const resp = obj.response as { ok: unknown; error: unknown };\n      return `(response ${formatType(resp.ok)} ${formatType(resp.error)})`;\n    }\n    if (\"tuple\" in obj) {\n      return \"(tuple ...)\";\n    }\n    if (\"buff\" in obj) {\n      const buff = obj.buff as { length: number };\n      return `(buff ${buff.length})`;\n    }\n    if (\"string-ascii\" in obj) {\n      const str = obj[\"string-ascii\"] as { length: number };\n      return `(string-ascii ${str.length})`;\n    }\n    if (\"string-utf8\" in obj) {\n      const str = obj[\"string-utf8\"] as { length: number };\n      return `(string-utf8 ${str.length})`;\n    }\n  }\n\n  return String(type);\n}",
    "packages/clarity-docs/src/parser/extractor.ts": "/**\n * Extract complete documentation from Clarity source files\n */\n\nimport type {\n  ContractDoc,\n  ContractHeaderDoc,\n  FunctionDoc,\n  MapDoc,\n  TraitDoc,\n  VariableDoc,\n} from \"../types/doc-block\";\nimport { createEmptyContractDoc } from \"../types/doc-block\";\nimport type { DefineInfo } from \"./lexer\";\nimport { groupCommentBlocks, tokenize } from \"./lexer\";\nimport {\n  extractCalls,\n  extractCallers,\n  extractCustomTags,\n  extractErrs,\n  extractFirstTagValue,\n  extractImplements,\n  extractParams,\n  extractPosts,\n  extractPrints,\n  extractTagValues,\n  parseDocBlock,\n} from \"./parser\";\n\n/** Contract-level tags that indicate a block is a header, not definition docs */\nconst CONTRACT_LEVEL_TAGS = [\"contract\", \"author\"] as const;\n\n/** Check if a doc block contains contract-level tags */\nfunction isContractHeader(parsed: ReturnType<typeof parseDocBlock>): boolean {\n  return parsed.tags.some((t) => (CONTRACT_LEVEL_TAGS as readonly string[]).includes(t.tag));\n}\n\n/** Extract documentation from Clarity source code */\nexport function extractDocs(source: string, sourcePath?: string): ContractDoc {\n  const tokens = tokenize(source);\n  const blocks = groupCommentBlocks(tokens);\n  const doc = createEmptyContractDoc();\n\n  if (sourcePath) {\n    doc.sourcePath = sourcePath;\n  }\n\n  // Track if we've processed the header\n  let headerProcessed = false;\n\n  for (const { block, followingDefine } of blocks) {\n    const parsed = parseDocBlock(block);\n\n    // Check if this is a contract header (first block with @title or @author)\n    if (!headerProcessed && isContractHeader(parsed)) {\n      doc.header = buildContractHeader(parsed);\n      headerProcessed = true;\n      continue;\n    }\n\n    // First unattached block without contract tags is also treated as header\n    if (!followingDefine && !headerProcessed) {\n      doc.header = buildContractHeader(parsed);\n      headerProcessed = true;\n      continue;\n    }\n\n    if (!followingDefine) {\n      // Unattached doc block after header - skip\n      continue;\n    }\n\n    // Attach documentation to the definition\n    switch (followingDefine.type) {\n      case \"public\":\n      case \"read-only\":\n      case \"private\":\n        doc.functions.set(followingDefine.name, buildFunctionDoc(parsed, followingDefine));\n        break;\n      case \"map\":\n        doc.maps.set(followingDefine.name, buildMapDoc(parsed, followingDefine));\n        break;\n      case \"data-var\":\n        doc.variables.set(followingDefine.name, buildVariableDoc(parsed, followingDefine, \"variable\"));\n        break;\n      case \"constant\":\n        doc.constants.set(followingDefine.name, buildVariableDoc(parsed, followingDefine, \"constant\"));\n        break;\n      case \"trait\":\n        doc.traits.set(followingDefine.name, buildTraitDoc(parsed, followingDefine));\n        break;\n    }\n  }\n\n  return doc;\n}\n\nfunction buildContractHeader(parsed: ReturnType<typeof parseDocBlock>): ContractHeaderDoc {\n  return {\n    contract: extractFirstTagValue(parsed.tags, \"contract\"),\n    author: extractFirstTagValue(parsed.tags, \"author\"),\n    desc: extractFirstTagValue(parsed.tags, \"desc\"),\n    dev: extractFirstTagValue(parsed.tags, \"dev\"),\n    version: extractFirstTagValue(parsed.tags, \"version\"),\n    deprecated: extractFirstTagValue(parsed.tags, \"deprecated\"),\n    see: extractTagValues(parsed.tags, \"see\"),\n    implements: extractImplements(parsed.tags),\n    custom: extractCustomTags(parsed.tags),\n    uri: extractFirstTagValue(parsed.tags, \"uri\"),\n    docsHash: extractFirstTagValue(parsed.tags, \"hash\"),\n  };\n}\n\nfunction buildFunctionDoc(\n  parsed: ReturnType<typeof parseDocBlock>,\n  define: DefineInfo\n): FunctionDoc {\n  return {\n    ...parsed,\n    target: \"function\",\n    functionName: define.name,\n    access: define.type as \"public\" | \"read-only\" | \"private\",\n    params: extractParams(parsed.tags),\n    ok: extractFirstTagValue(parsed.tags, \"ok\"),\n    errs: extractErrs(parsed.tags),\n    posts: extractPosts(parsed.tags),\n    examples: extractTagValues(parsed.tags, \"example\"),\n    prints: extractPrints(parsed.tags),\n    calls: extractCalls(parsed.tags),\n    callers: extractCallers(parsed.tags),\n    desc: extractFirstTagValue(parsed.tags, \"desc\"),\n    dev: extractFirstTagValue(parsed.tags, \"dev\"),\n    deprecated: extractFirstTagValue(parsed.tags, \"deprecated\"),\n    version: extractFirstTagValue(parsed.tags, \"version\"),\n    see: extractTagValues(parsed.tags, \"see\"),\n  };\n}\n\nfunction buildMapDoc(\n  parsed: ReturnType<typeof parseDocBlock>,\n  define: DefineInfo\n): MapDoc {\n  // For @key and @value, the \"name\" field contains the type info\n  const keyTag = parsed.tags.find((t) => t.tag === \"key\");\n  const valueTag = parsed.tags.find((t) => t.tag === \"value\");\n\n  return {\n    ...parsed,\n    target: \"map\",\n    mapName: define.name,\n    key: keyTag ? (keyTag.name ? `${keyTag.name} ${keyTag.description}` : keyTag.description) : undefined,\n    value: valueTag\n      ? valueTag.name\n        ? `${valueTag.name} ${valueTag.description}`\n        : valueTag.description\n      : undefined,\n    desc: extractFirstTagValue(parsed.tags, \"desc\"),\n    dev: extractFirstTagValue(parsed.tags, \"dev\"),\n    deprecated: extractFirstTagValue(parsed.tags, \"deprecated\"),\n    version: extractFirstTagValue(parsed.tags, \"version\"),\n    see: extractTagValues(parsed.tags, \"see\"),\n  };\n}\n\nfunction buildVariableDoc(\n  parsed: ReturnType<typeof parseDocBlock>,\n  define: DefineInfo,\n  target: \"variable\" | \"constant\"\n): VariableDoc {\n  const doc: VariableDoc = {\n    ...parsed,\n    target,\n    variableName: define.name,\n    desc: extractFirstTagValue(parsed.tags, \"desc\"),\n    dev: extractFirstTagValue(parsed.tags, \"dev\"),\n    deprecated: extractFirstTagValue(parsed.tags, \"deprecated\"),\n    version: extractFirstTagValue(parsed.tags, \"version\"),\n    see: extractTagValues(parsed.tags, \"see\"),\n    examples: extractTagValues(parsed.tags, \"example\"),\n  };\n\n  // For constants, check for @err tag (error constant support)\n  if (target === \"constant\") {\n    const errTag = parsed.tags.find((t) => t.tag === \"err\");\n    if (errTag) {\n      doc.isError = true;\n      doc.errorDescription = errTag.description;\n      // Try to extract error code from the define expression: (err uXX)\n      const errorCodeMatch = define.fullMatch.match(/\\(err\\s+u(\\d+)\\)/);\n      if (errorCodeMatch) {\n        doc.errorCode = `u${errorCodeMatch[1]}`;\n      }\n    }\n  }\n\n  return doc;\n}\n\nfunction buildTraitDoc(\n  parsed: ReturnType<typeof parseDocBlock>,\n  define: DefineInfo\n): TraitDoc {\n  return {\n    ...parsed,\n    target: \"trait\",\n    traitName: define.name,\n    desc: extractFirstTagValue(parsed.tags, \"desc\"),\n    dev: extractFirstTagValue(parsed.tags, \"dev\"),\n    deprecated: extractFirstTagValue(parsed.tags, \"deprecated\"),\n    version: extractFirstTagValue(parsed.tags, \"version\"),\n    see: extractTagValues(parsed.tags, \"see\"),\n  };\n}\n\n/** Convenience function to extract docs from a file path */\nexport async function extractDocsFromFile(filePath: string): Promise<ContractDoc> {\n  const fs = await import(\"node:fs/promises\");\n  const source = await fs.readFile(filePath, \"utf-8\");\n  return extractDocs(source, filePath);\n}",
    "packages/clarity-docs/src/parser/index.ts": "export * from \"./lexer\";\nexport * from \"./parser\";\nexport * from \"./extractor\";",
    "packages/clarity-docs/src/parser/lexer.ts": "/**\n * Lexer for tokenizing Clarity source comments\n */\n\n/** Token types for documentation parsing */\nexport type TokenType = \"comment\" | \"define\" | \"other\" | \"eof\";\n\n/** A lexer token */\nexport interface Token {\n  type: TokenType;\n  value: string;\n  line: number;\n}\n\n/** Define expression types */\nexport type DefineType = \"public\" | \"read-only\" | \"private\" | \"data-var\" | \"map\" | \"constant\" | \"trait\";\n\n/** Information about a define expression */\nexport interface DefineInfo {\n  type: DefineType;\n  name: string;\n  line: number;\n  fullMatch: string;\n}\n\n/** Tokenize Clarity source into tokens */\nexport function tokenize(source: string): Token[] {\n  const lines = source.split(\"\\n\");\n  const tokens: Token[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmed = line.trim();\n    const lineNum = i + 1; // 1-indexed\n\n    if (trimmed.startsWith(\";;\")) {\n      // Documentation comment\n      tokens.push({\n        type: \"comment\",\n        value: trimmed.slice(2).trim(),\n        line: lineNum,\n      });\n    } else if (trimmed.startsWith(\"(define-\")) {\n      // Define expression\n      tokens.push({\n        type: \"define\",\n        value: trimmed,\n        line: lineNum,\n      });\n    } else if (trimmed.length > 0 && !trimmed.startsWith(\";\")) {\n      // Other non-empty, non-comment line\n      tokens.push({\n        type: \"other\",\n        value: trimmed,\n        line: lineNum,\n      });\n    }\n    // Skip empty lines and single-semicolon comments\n  }\n\n  tokens.push({ type: \"eof\", value: \"\", line: lines.length + 1 });\n  return tokens;\n}\n\n/** Parse a define expression to extract type and name */\nexport function parseDefine(defineExpr: string): DefineInfo | null {\n  // Match (define-TYPE (NAME ...) or (define-TYPE NAME\n  const patterns: Array<{ regex: RegExp; type: DefineType }> = [\n    // Functions: (define-public (name ...)\n    { regex: /^\\(define-public\\s+\\(([a-zA-Z][a-zA-Z0-9_-]*)\\s*/, type: \"public\" },\n    { regex: /^\\(define-read-only\\s+\\(([a-zA-Z][a-zA-Z0-9_-]*)\\s*/, type: \"read-only\" },\n    { regex: /^\\(define-private\\s+\\(([a-zA-Z][a-zA-Z0-9_-]*)\\s*/, type: \"private\" },\n    // Variables: (define-data-var NAME type value)\n    { regex: /^\\(define-data-var\\s+([a-zA-Z][a-zA-Z0-9_-]*)\\s*/, type: \"data-var\" },\n    // Maps: (define-map NAME { key: type } { value: type })\n    { regex: /^\\(define-map\\s+([a-zA-Z][a-zA-Z0-9_-]*)\\s*/, type: \"map\" },\n    // Constants: (define-constant NAME value)\n    { regex: /^\\(define-constant\\s+([a-zA-Z][a-zA-Z0-9_-]*)\\s*/, type: \"constant\" },\n    // Traits: (define-trait NAME ((func ...)))\n    { regex: /^\\(define-trait\\s+([a-zA-Z][a-zA-Z0-9_-]*)\\s*/, type: \"trait\" },\n  ];\n\n  for (const { regex, type } of patterns) {\n    const match = defineExpr.match(regex);\n    if (match) {\n      return {\n        type,\n        name: match[1],\n        line: 0, // Will be set by caller\n        fullMatch: defineExpr,\n      };\n    }\n  }\n\n  return null;\n}\n\n/** Group consecutive comment tokens into blocks */\nexport interface CommentBlock {\n  comments: Token[];\n  startLine: number;\n  endLine: number;\n}\n\nexport function groupCommentBlocks(tokens: Token[]): Array<{ block: CommentBlock; followingDefine: DefineInfo | null }> {\n  const result: Array<{ block: CommentBlock; followingDefine: DefineInfo | null }> = [];\n  let currentBlock: Token[] = [];\n  let blockStart = 0;\n  let lastCommentLine = 0;\n\n  const flushBlock = (followingDefine: DefineInfo | null) => {\n    if (currentBlock.length > 0) {\n      const block: CommentBlock = {\n        comments: [...currentBlock],\n        startLine: blockStart,\n        endLine: currentBlock[currentBlock.length - 1].line,\n      };\n      result.push({ block, followingDefine });\n      currentBlock = [];\n    }\n  };\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n\n    if (token.type === \"comment\") {\n      // Check if there's a gap (empty line) between this comment and the last\n      if (currentBlock.length > 0 && token.line > lastCommentLine + 1) {\n        // Gap detected - flush current block as orphaned\n        flushBlock(null);\n      }\n\n      if (currentBlock.length === 0) {\n        blockStart = token.line;\n      }\n      currentBlock.push(token);\n      lastCommentLine = token.line;\n    } else if (currentBlock.length > 0) {\n      // End of comment block\n      let followingDefine: DefineInfo | null = null;\n      if (token.type === \"define\") {\n        const defineInfo = parseDefine(token.value);\n        if (defineInfo) {\n          defineInfo.line = token.line;\n          followingDefine = defineInfo;\n        }\n      }\n\n      flushBlock(followingDefine);\n    }\n  }\n\n  return result;\n}",
    "packages/clarity-docs/src/parser/parser.ts": "/**\n * Parser for extracting structured documentation from comment blocks\n */\n\nimport type { CallDoc, ClarityDocTag, DocBlock, DocTag, ErrDoc, ParamDoc, PostDoc, PrintDoc } from \"../types/index\";\nimport { isClarityDocTag, isNamedTag } from \"../types/tags\";\nimport type { CommentBlock } from \"./lexer\";\n\n/** Parse a single comment line for @tag content */\nexport function parseTagLine(line: string, lineNum: number): DocTag | null {\n  // Match @tag pattern at start of line\n  const tagMatch = line.match(/^@([a-zA-Z][a-zA-Z0-9_:-]*)\\s*(.*)?$/);\n  if (!tagMatch) {\n    return null;\n  }\n\n  const tagName = tagMatch[1];\n  const rest = (tagMatch[2] || \"\").trim();\n\n  if (!isClarityDocTag(tagName)) {\n    // Unknown tag, treat as custom if it doesn't match standard pattern\n    return null;\n  }\n\n  // Special handling for @calls <contract-ref> <function> [description]\n  if (tagName === \"calls\") {\n    // Match: .contract func OR 'SP...CONTRACT func\n    const callsMatch = rest.match(/^([.''][^\\s]+)\\s+([a-zA-Z_][a-zA-Z0-9_-]*)\\s*(.*)?$/);\n    if (callsMatch) {\n      return {\n        tag: \"calls\" as ClarityDocTag,\n        name: callsMatch[2], // function name\n        description: `${callsMatch[1]} ${(callsMatch[3] || \"\").trim()}`.trim(),\n        line: lineNum,\n      };\n    }\n  }\n\n  // Special handling for @prints {type}? name description\n  if (tagName === \"prints\") {\n    // Check for optional type annotation: @prints {type} name description\n    const printsWithType = rest.match(/^\\{([^}]+)\\}\\s+([a-zA-Z_][a-zA-Z0-9_-]*)\\s*(.*)?$/);\n    if (printsWithType) {\n      return {\n        tag: \"prints\" as ClarityDocTag,\n        name: printsWithType[2],\n        description: `{${printsWithType[1]}} ${(printsWithType[3] || \"\").trim()}`.trim(),\n        line: lineNum,\n      };\n    }\n    // Fall through to normal named tag parsing for @prints name description\n  }\n\n  // For named tags (@param name desc, @error CODE desc), extract the name\n  if (isNamedTag(tagName)) {\n    const namedMatch = rest.match(/^([a-zA-Z_][a-zA-Z0-9_-]*)\\s*(.*)?$/);\n    if (namedMatch) {\n      return {\n        tag: tagName as ClarityDocTag,\n        name: namedMatch[1],\n        description: (namedMatch[2] || \"\").trim(),\n        line: lineNum,\n      };\n    }\n    // Named tag without proper name - still parse it\n    return {\n      tag: tagName as ClarityDocTag,\n      description: rest,\n      line: lineNum,\n    };\n  }\n\n  return {\n    tag: tagName as ClarityDocTag,\n    description: rest,\n    line: lineNum,\n  };\n}\n\n/** Parse a comment block into a structured DocBlock */\nexport function parseDocBlock(block: CommentBlock): DocBlock {\n  const tags: DocTag[] = [];\n  const rawLines: string[] = [];\n  let currentTag: DocTag | null = null;\n\n  for (const comment of block.comments) {\n    const line = comment.value;\n    rawLines.push(line);\n\n    // Check if this line starts a new tag\n    const tag = parseTagLine(line, comment.line);\n\n    if (tag) {\n      // Save previous tag if exists\n      if (currentTag) {\n        tags.push(currentTag);\n      }\n      currentTag = tag;\n    } else if (currentTag && line.length > 0) {\n      // Continuation of previous tag description\n      currentTag.description = currentTag.description ? `${currentTag.description} ${line}` : line;\n    } else if (!currentTag && line.length > 0) {\n      // Free-form text before any tag - treat as @desc\n      currentTag = {\n        tag: \"desc\",\n        description: line,\n        line: comment.line,\n      };\n    }\n  }\n\n  // Don't forget the last tag\n  if (currentTag) {\n    tags.push(currentTag);\n  }\n\n  return {\n    tags,\n    rawText: rawLines.join(\"\\n\"),\n    startLine: block.startLine,\n    endLine: block.endLine,\n  };\n}\n\n/** Extract @param tags as ParamDoc array */\nexport function extractParams(tags: DocTag[]): ParamDoc[] {\n  return tags\n    .filter((t) => t.tag === \"param\" && t.name)\n    .map((t) => ({\n      name: t.name!,\n      description: t.description,\n    }));\n}\n\n/** Extract @err tags as ErrDoc array */\nexport function extractErrs(tags: DocTag[]): ErrDoc[] {\n  return tags\n    .filter((t) => t.tag === \"err\" && t.name)\n    .map((t) => ({\n      code: t.name!,\n      description: t.description,\n    }));\n}\n\n/** Extract @post tags as PostDoc array */\nexport function extractPosts(tags: DocTag[]): PostDoc[] {\n  return tags\n    .filter((t) => t.tag === \"post\" && t.name)\n    .map((t) => ({\n      asset: t.name!,\n      description: t.description,\n    }));\n}\n\n/** Extract @prints tags as PrintDoc array */\nexport function extractPrints(tags: DocTag[]): PrintDoc[] {\n  return tags\n    .filter((t) => t.tag === \"prints\" && t.name)\n    .map((t) => {\n      // Check if description starts with type annotation {..}\n      const typeMatch = t.description.match(/^\\{([^}]+)\\}\\s*(.*)/);\n      if (typeMatch) {\n        return {\n          name: t.name!,\n          type: typeMatch[1],\n          description: typeMatch[2],\n        };\n      }\n      return {\n        name: t.name!,\n        description: t.description,\n      };\n    });\n}\n\n/** Extract all tags of a specific type */\nexport function extractTagValues(tags: DocTag[], tagName: ClarityDocTag): string[] {\n  return tags.filter((t) => t.tag === tagName).map((t) => t.description);\n}\n\n/** Extract the first tag value of a specific type */\nexport function extractFirstTagValue(tags: DocTag[], tagName: ClarityDocTag): string | undefined {\n  const tag = tags.find((t) => t.tag === tagName);\n  return tag?.description;\n}\n\n/** Extract custom tags as a Map */\nexport function extractCustomTags(tags: DocTag[]): Map<string, string> {\n  const custom = new Map<string, string>();\n  for (const tag of tags) {\n    if (tag.tag.startsWith(\"custom:\")) {\n      const customName = tag.tag.slice(7); // Remove \"custom:\" prefix\n      custom.set(customName, tag.description);\n    }\n  }\n  return custom;\n}\n\n/** Extract @calls tags as CallDoc array */\nexport function extractCalls(tags: DocTag[]): CallDoc[] {\n  return tags\n    .filter((t) => t.tag === \"calls\" && t.name)\n    .map((t) => {\n      // Description contains: \"<contract-ref> [optional description]\"\n      const parts = t.description.split(/\\s+/);\n      const contract = parts[0];\n      const description = parts.slice(1).join(\" \") || undefined;\n      return {\n        contract,\n        function: t.name!,\n        description,\n      };\n    });\n}\n\n/** Extract @caller tags as string array */\nexport function extractCallers(tags: DocTag[]): string[] {\n  return tags\n    .filter((t) => t.tag === \"caller\")\n    .map((t) => t.description);\n}\n\n/** Extract @implements tags as string array */\nexport function extractImplements(tags: DocTag[]): string[] {\n  return tags\n    .filter((t) => t.tag === \"implements\")\n    .map((t) => t.description);\n}",
    "packages/clarity-docs/src/types/doc-block.ts": "/**\n * ClarityDoc block and documentation types\n */\n\nimport type { ClarityDocTag } from \"./tags\";\n\n/** A single parsed documentation tag */\nexport interface DocTag {\n  /** The tag name (without @) */\n  tag: ClarityDocTag;\n  /** Optional name argument for tags like @param */\n  name?: string;\n  /** The tag description */\n  description: string;\n  /** Line number in source (1-indexed) */\n  line: number;\n}\n\n/** A block of documentation comments */\nexport interface DocBlock {\n  /** All parsed tags in the block */\n  tags: DocTag[];\n  /** Raw text of all comments (without ;; prefix) */\n  rawText: string;\n  /** Starting line number (1-indexed) */\n  startLine: number;\n  /** Ending line number (1-indexed) */\n  endLine: number;\n}\n\n/** Parameter documentation */\nexport interface ParamDoc {\n  name: string;\n  description: string;\n}\n\n/** Error documentation */\nexport interface ErrDoc {\n  code: string;\n  description: string;\n}\n\n/** Print/event documentation */\nexport interface PrintDoc {\n  name: string;\n  type?: string;\n  description: string;\n}\n\n/** Postcondition documentation (asset transfers, mints, etc.) */\nexport interface PostDoc {\n  /** Asset identifier (stx, token-name, etc.) */\n  asset: string;\n  description: string;\n}\n\n/** Contract call dependency documentation */\nexport interface CallDoc {\n  /** Contract reference (.contract or 'SP...contract) */\n  contract: string;\n  /** Function being called */\n  function: string;\n  /** Optional description */\n  description?: string;\n}\n\n/** Documentation for a function */\nexport interface FunctionDoc extends DocBlock {\n  /** The target type */\n  target: \"function\";\n  /** Function name */\n  functionName: string;\n  /** Function access level */\n  access: \"public\" | \"read-only\" | \"private\";\n  /** Documented parameters */\n  params: ParamDoc[];\n  /** Ok value documentation */\n  ok?: string;\n  /** Error cases */\n  errs: ErrDoc[];\n  /** Postconditions (asset transfers, mints) */\n  posts: PostDoc[];\n  /** Usage examples */\n  examples: string[];\n  /** Print statements documented */\n  prints: PrintDoc[];\n  /** External contract calls */\n  calls: CallDoc[];\n  /** Authorization requirements */\n  callers: string[];\n  /** Description (human-readable) */\n  desc?: string;\n  /** Developer notes */\n  dev?: string;\n  /** Deprecation notice */\n  deprecated?: string;\n  /** Version/deployment info */\n  version?: string;\n  /** Cross-references */\n  see: string[];\n}\n\n/** Documentation for a map */\nexport interface MapDoc extends DocBlock {\n  target: \"map\";\n  mapName: string;\n  /** Key type documentation */\n  key?: string;\n  /** Value type documentation */\n  value?: string;\n  desc?: string;\n  dev?: string;\n  deprecated?: string;\n  version?: string;\n  see: string[];\n}\n\n/** Documentation for a variable or constant */\nexport interface VariableDoc extends DocBlock {\n  target: \"variable\" | \"constant\";\n  variableName: string;\n  desc?: string;\n  dev?: string;\n  deprecated?: string;\n  version?: string;\n  see: string[];\n  /** For error constants: marks this as an error constant */\n  isError?: boolean;\n  /** For error constants: human-readable error description */\n  errorDescription?: string;\n  /** For error constants: extracted error code (e.g., \"u67\") */\n  errorCode?: string;\n  /** Usage examples */\n  examples?: string[];\n}\n\n/** Documentation for a trait definition */\nexport interface TraitDoc extends DocBlock {\n  target: \"trait\";\n  traitName: string;\n  desc?: string;\n  dev?: string;\n  deprecated?: string;\n  version?: string;\n  see: string[];\n}\n\n/** Contract-level documentation */\nexport interface ContractHeaderDoc {\n  /** Contract name/title */\n  contract?: string;\n  /** Author info */\n  author?: string;\n  /** Contract description */\n  desc?: string;\n  /** Developer notes */\n  dev?: string;\n  /** Version info */\n  version?: string;\n  /** Deprecation notice */\n  deprecated?: string;\n  /** Cross-references */\n  see: string[];\n  /** Implemented traits */\n  implements: string[];\n  /** Custom tags */\n  custom: Map<string, string>;\n  /** Off-chain documentation URL */\n  uri?: string;\n  /** Documentation hash for integrity verification */\n  docsHash?: string;\n}\n\n/** Complete contract documentation */\nexport interface ContractDoc {\n  /** Contract header documentation */\n  header: ContractHeaderDoc;\n  /** Function documentation by name */\n  functions: Map<string, FunctionDoc>;\n  /** Map documentation by name */\n  maps: Map<string, MapDoc>;\n  /** Variable documentation by name */\n  variables: Map<string, VariableDoc>;\n  /** Constant documentation by name */\n  constants: Map<string, VariableDoc>;\n  /** Trait documentation by name */\n  traits: Map<string, TraitDoc>;\n  /** Source file path (if available) */\n  sourcePath?: string;\n}\n\n/** Create an empty contract documentation object */\nexport function createEmptyContractDoc(): ContractDoc {\n  return {\n    header: {\n      see: [],\n      implements: [],\n      custom: new Map(),\n    },\n    functions: new Map(),\n    maps: new Map(),\n    variables: new Map(),\n    constants: new Map(),\n    traits: new Map(),\n  };\n}",
    "packages/clarity-docs/src/types/index.ts": "export * from \"./tags\";\nexport * from \"./doc-block\";",
    "packages/clarity-docs/src/types/tags.ts": "/**\n * ClarityDoc tag types and definitions\n */\n\n/** Standard ClarityDoc tags (SIP-014 aligned) */\nexport type StandardTag =\n  | \"contract\"\n  | \"author\"\n  | \"desc\"\n  | \"dev\"\n  | \"param\"\n  | \"ok\"\n  | \"err\"\n  | \"post\"\n  | \"prints\"\n  | \"example\"\n  | \"key\"\n  | \"value\"\n  | \"version\"\n  | \"deprecated\"\n  | \"see\"\n  | \"implements\"\n  | \"calls\"\n  | \"caller\"\n  | \"uri\"\n  | \"hash\";\n\n/** Custom tag format: @custom:name */\nexport type CustomTag = `custom:${string}`;\n\n/** All valid ClarityDoc tags */\nexport type ClarityDocTag = StandardTag | CustomTag;\n\n/** Tags valid at contract level */\nexport type ContractLevelTag = \"contract\" | \"author\" | \"desc\" | \"dev\" | \"version\" | \"deprecated\" | \"see\" | \"implements\" | \"uri\" | \"hash\" | CustomTag;\n\n/** Tags valid for functions */\nexport type FunctionTag =\n  | \"desc\"\n  | \"dev\"\n  | \"param\"\n  | \"ok\"\n  | \"err\"\n  | \"post\"\n  | \"prints\"\n  | \"example\"\n  | \"version\"\n  | \"deprecated\"\n  | \"see\"\n  | \"calls\"\n  | \"caller\"\n  | CustomTag;\n\n/** Tags valid for maps */\nexport type MapTag = \"desc\" | \"dev\" | \"key\" | \"value\" | \"version\" | \"deprecated\" | \"see\" | CustomTag;\n\n/** Tags valid for variables and constants */\nexport type VariableTag = \"desc\" | \"dev\" | \"version\" | \"deprecated\" | \"see\" | \"err\" | \"example\" | CustomTag;\n\n/** Check if a string is a valid standard tag */\nexport function isStandardTag(tag: string): tag is StandardTag {\n  const standardTags: readonly string[] = [\n    \"contract\",\n    \"author\",\n    \"desc\",\n    \"dev\",\n    \"param\",\n    \"ok\",\n    \"err\",\n    \"post\",\n    \"prints\",\n    \"example\",\n    \"key\",\n    \"value\",\n    \"version\",\n    \"deprecated\",\n    \"see\",\n    \"implements\",\n    \"calls\",\n    \"caller\",\n    \"uri\",\n    \"hash\",\n  ];\n  return standardTags.includes(tag);\n}\n\n/** Check if a string is a valid custom tag */\nexport function isCustomTag(tag: string): tag is CustomTag {\n  return tag.startsWith(\"custom:\");\n}\n\n/** Check if a string is a valid ClarityDoc tag */\nexport function isClarityDocTag(tag: string): tag is ClarityDocTag {\n  return isStandardTag(tag) || isCustomTag(tag);\n}\n\n/** Tags that accept a name argument (e.g., @param name description) */\nexport const NAMED_TAGS = [\"param\", \"err\", \"post\", \"key\", \"value\", \"prints\", \"calls\"] as const;\nexport type NamedTag = (typeof NAMED_TAGS)[number];\n\nexport function isNamedTag(tag: string): tag is NamedTag {\n  return (NAMED_TAGS as readonly string[]).includes(tag);\n}\n\n/** Definition context types for tag validation */\nexport type TagContext = \"contract\" | \"public\" | \"read-only\" | \"private\" | \"data-var\" | \"map\" | \"constant\" | \"trait\";\n\n/** Tag placement rules: maps each standard tag to valid definition contexts */\nexport const TAG_RULES: Record<StandardTag, readonly TagContext[]> = {\n  contract: [\"contract\"],\n  author: [\"contract\"],\n  desc: [\"contract\", \"public\", \"read-only\", \"private\", \"data-var\", \"map\", \"constant\", \"trait\"],\n  dev: [\"contract\", \"public\", \"read-only\", \"private\", \"data-var\", \"map\", \"constant\", \"trait\"],\n  version: [\"contract\", \"public\", \"read-only\", \"private\", \"data-var\", \"map\", \"constant\", \"trait\"],\n  deprecated: [\"contract\", \"public\", \"read-only\", \"private\", \"data-var\", \"map\", \"constant\", \"trait\"],\n  see: [\"contract\", \"public\", \"read-only\", \"private\", \"data-var\", \"map\", \"constant\", \"trait\"],\n  implements: [\"contract\"],\n  uri: [\"contract\"],\n  hash: [\"contract\"],\n  param: [\"public\", \"read-only\", \"private\"],\n  ok: [\"public\", \"read-only\", \"private\"],\n  err: [\"public\", \"read-only\", \"private\", \"constant\"],\n  post: [\"public\", \"read-only\", \"private\"],\n  prints: [\"public\", \"read-only\", \"private\"],\n  example: [\"public\", \"read-only\", \"private\", \"constant\"],\n  calls: [\"public\", \"read-only\", \"private\"],\n  caller: [\"public\", \"read-only\", \"private\"],\n  key: [\"map\"],\n  value: [\"map\"],\n};\n\n/** Check if a tag is valid for a given definition context */\nexport function isTagValidForContext(tag: string, context: TagContext): boolean {\n  if (isCustomTag(tag)) return true; // custom tags allowed everywhere\n  if (!isStandardTag(tag)) return false;\n  return TAG_RULES[tag].includes(context);\n}",
    "packages/clarity-docs/src/utils/index.ts": "export { stripDocs, estimateStrippingSavings } from \"./strip\";\nexport type { StripOptions } from \"./strip\";",
    "packages/clarity-docs/src/utils/strip.ts": "/**\n * Utilities for stripping documentation from Clarity source\n *\n * Use cases:\n * - Reduce deployment costs for mainnet\n * - Create minified contract versions\n * - Keep only essential docs (errors) while removing verbose ones\n */\n\nexport interface StripOptions {\n  /** Keep @err tags for wallet integration (default: true) */\n  keepErrors?: boolean;\n  /** Keep @desc tags for basic documentation (default: false) */\n  keepDesc?: boolean;\n  /** Keep specific tags (overrides other options) */\n  keepTags?: string[];\n  /** Remove all doc comments entirely (default: false) */\n  removeAll?: boolean;\n}\n\n/**\n * Strip documentation comments from Clarity source\n *\n * @example\n * // Remove all docs except @err\n * const minimal = stripDocs(source, { keepErrors: true });\n *\n * @example\n * // Remove all docs entirely\n * const bare = stripDocs(source, { removeAll: true });\n *\n * @example\n * // Keep only specific tags\n * const custom = stripDocs(source, { keepTags: ['err', 'desc'] });\n */\nexport function stripDocs(source: string, options: StripOptions = {}): string {\n  const { keepErrors = true, keepDesc = false, keepTags = [], removeAll = false } = options;\n\n  if (removeAll) {\n    return stripAllDocComments(source);\n  }\n\n  const tagsToKeep = new Set(keepTags);\n  if (keepErrors) tagsToKeep.add(\"err\");\n  if (keepDesc) tagsToKeep.add(\"desc\");\n\n  return stripSelectiveDocs(source, tagsToKeep);\n}\n\n/** Remove all ;; doc comments */\nfunction stripAllDocComments(source: string): string {\n  const lines = source.split(\"\\n\");\n  const result: string[] = [];\n  let inDocBlock = false;\n  let docBlockLines: number[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmed = line.trim();\n\n    if (trimmed.startsWith(\";;\")) {\n      // Check if next non-empty line is a define\n      if (!inDocBlock) {\n        inDocBlock = true;\n        docBlockLines = [i];\n      } else {\n        docBlockLines.push(i);\n      }\n    } else if (inDocBlock) {\n      // End of doc block\n      if (trimmed.startsWith(\"(define-\")) {\n        // This was a doc block for a definition - skip it\n        inDocBlock = false;\n        docBlockLines = [];\n      } else if (trimmed.length === 0) {\n        // Empty line continues potential doc block\n        docBlockLines.push(i);\n      } else {\n        // Non-define, non-empty - keep these comments (not attached to define)\n        for (const idx of docBlockLines) {\n          result.push(lines[idx]);\n        }\n        inDocBlock = false;\n        docBlockLines = [];\n      }\n      result.push(line);\n    } else {\n      result.push(line);\n    }\n  }\n\n  // Handle trailing doc block\n  if (inDocBlock) {\n    for (const idx of docBlockLines) {\n      result.push(lines[idx]);\n    }\n  }\n\n  return result.join(\"\\n\");\n}\n\n/** Strip docs selectively, keeping specified tags */\nfunction stripSelectiveDocs(source: string, tagsToKeep: Set<string>): string {\n  const lines = source.split(\"\\n\");\n  const result: string[] = [];\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    if (trimmed.startsWith(\";;\")) {\n      // Check if this line has a tag we want to keep\n      const tagMatch = trimmed.match(/^;;\\s*@([a-zA-Z][a-zA-Z0-9_:-]*)/);\n      if (tagMatch) {\n        const tag = tagMatch[1];\n        if (tagsToKeep.has(tag) || tag.startsWith(\"custom:\")) {\n          result.push(line);\n        }\n        // Skip lines with tags we don't want to keep\n      } else {\n        // Plain comment without tag - skip if we're being selective\n        // (unless it's a continuation of a kept tag, which we can't easily detect)\n      }\n    } else {\n      result.push(line);\n    }\n  }\n\n  return result.join(\"\\n\");\n}\n\n/**\n * Estimate deployment cost savings from stripping docs\n *\n * @returns Object with byte counts and estimated savings\n */\nexport function estimateStrippingSavings(\n  source: string,\n  options: StripOptions = {}\n): { originalBytes: number; strippedBytes: number; savedBytes: number; savingsPercent: number } {\n  const stripped = stripDocs(source, options);\n  const originalBytes = new TextEncoder().encode(source).length;\n  const strippedBytes = new TextEncoder().encode(stripped).length;\n  const savedBytes = originalBytes - strippedBytes;\n  const savingsPercent = originalBytes > 0 ? (savedBytes / originalBytes) * 100 : 0;\n\n  return { originalBytes, strippedBytes, savedBytes, savingsPercent };\n}",
    "packages/clarity-docs/src/validation/index.ts": "export * from \"./validators\";",
    "packages/clarity-docs/src/validation/validators.ts": "/**\n * Validation for ClarityDoc documentation\n */\n\nimport type { ClarityContract, ClarityFunction } from \"@secondlayer/clarity-types\";\nimport type { ContractDoc, FunctionDoc } from \"../types/doc-block\";\nimport { isTagValidForContext, isCustomTag, type TagContext } from \"../types/tags\";\n\n/** Validation error severity */\nexport type Severity = \"error\" | \"warning\" | \"info\";\n\n/** A validation diagnostic */\nexport interface Diagnostic {\n  severity: Severity;\n  message: string;\n  line?: number;\n  tag?: string;\n  target?: string;\n}\n\n/** Validation result */\nexport interface ValidationResult {\n  valid: boolean;\n  diagnostics: Diagnostic[];\n}\n\n/** Validate tag placement for a doc block */\nfunction validateTagPlacement(\n  tags: Array<{ tag: string; line?: number }>,\n  context: TagContext,\n  targetName: string\n): Diagnostic[] {\n  const diagnostics: Diagnostic[] = [];\n\n  for (const { tag, line } of tags) {\n    if (isCustomTag(tag)) continue; // custom tags allowed everywhere\n\n    if (!isTagValidForContext(tag, context)) {\n      diagnostics.push({\n        severity: \"warning\",\n        message: `Tag '@${tag}' is not typically used on ${context} definitions (found on '${targetName}')`,\n        line,\n        tag,\n        target: targetName,\n      });\n    }\n  }\n\n  return diagnostics;\n}\n\n/** Validate documentation against contract ABI */\nexport function validateDocs(doc: ContractDoc, abi?: ClarityContract): ValidationResult {\n  const diagnostics: Diagnostic[] = [];\n\n  // Validate tag placement for contract header\n  if (doc.header.contract || doc.header.author || doc.header.desc) {\n    // Header exists - we don't have tags array directly, but we can skip for now\n    // The header is validated implicitly by the parser\n  }\n\n  // Validate function docs\n  for (const [name, funcDoc] of doc.functions) {\n    // Validate tag placement\n    const tagContext: TagContext = funcDoc.access;\n    const tagDiagnostics = validateTagPlacement(\n      funcDoc.tags.map((t) => ({ tag: t.tag, line: t.line })),\n      tagContext,\n      name\n    );\n    diagnostics.push(...tagDiagnostics);\n\n    // Validate function doc content\n    const funcDiagnostics = validateFunctionDoc(funcDoc, abi?.functions.find((f) => f.name === name));\n    diagnostics.push(...funcDiagnostics);\n  }\n\n  // Validate map docs\n  for (const [name, mapDoc] of doc.maps) {\n    const tagDiagnostics = validateTagPlacement(\n      mapDoc.tags.map((t) => ({ tag: t.tag, line: t.line })),\n      \"map\",\n      name\n    );\n    diagnostics.push(...tagDiagnostics);\n  }\n\n  // Validate constant docs\n  for (const [name, constDoc] of doc.constants) {\n    const tagDiagnostics = validateTagPlacement(\n      constDoc.tags.map((t) => ({ tag: t.tag, line: t.line })),\n      \"constant\",\n      name\n    );\n    diagnostics.push(...tagDiagnostics);\n  }\n\n  // Validate variable docs\n  for (const [name, varDoc] of doc.variables) {\n    const tagDiagnostics = validateTagPlacement(\n      varDoc.tags.map((t) => ({ tag: t.tag, line: t.line })),\n      \"data-var\",\n      name\n    );\n    diagnostics.push(...tagDiagnostics);\n  }\n\n  // Validate trait docs\n  for (const [name, traitDoc] of doc.traits) {\n    const tagDiagnostics = validateTagPlacement(\n      traitDoc.tags.map((t) => ({ tag: t.tag, line: t.line })),\n      \"trait\",\n      name\n    );\n    diagnostics.push(...tagDiagnostics);\n  }\n\n  // Check for undocumented public/read-only functions (if ABI provided)\n  if (abi) {\n    for (const func of abi.functions) {\n      if (func.access !== \"private\" && !doc.functions.has(func.name)) {\n        diagnostics.push({\n          severity: \"warning\",\n          message: `Function '${func.name}' is not documented`,\n          target: func.name,\n        });\n      }\n    }\n\n    // Check for undocumented maps\n    for (const map of abi.maps || []) {\n      if (!doc.maps.has(map.name)) {\n        diagnostics.push({\n          severity: \"info\",\n          message: `Map '${map.name}' is not documented`,\n          target: map.name,\n        });\n      }\n    }\n\n    // Check for undocumented variables\n    for (const variable of abi.variables || []) {\n      const isConstant = variable.access === \"constant\";\n      const docMap = isConstant ? doc.constants : doc.variables;\n      if (!docMap.has(variable.name)) {\n        diagnostics.push({\n          severity: \"info\",\n          message: `${isConstant ? \"Constant\" : \"Variable\"} '${variable.name}' is not documented`,\n          target: variable.name,\n        });\n      }\n    }\n  }\n\n  return {\n    valid: !diagnostics.some((d) => d.severity === \"error\"),\n    diagnostics,\n  };\n}\n\n/** Validate a function's documentation */\nfunction validateFunctionDoc(funcDoc: FunctionDoc, abiFunc?: ClarityFunction): Diagnostic[] {\n  const diagnostics: Diagnostic[] = [];\n  const funcName = funcDoc.functionName;\n\n  // Check for missing @desc\n  if (!funcDoc.desc) {\n    diagnostics.push({\n      severity: \"warning\",\n      message: `Function '${funcName}' is missing @desc description`,\n      target: funcName,\n      tag: \"desc\",\n    });\n  }\n\n  // Check for missing @ok on non-private functions\n  if (funcDoc.access !== \"private\" && !funcDoc.ok) {\n    diagnostics.push({\n      severity: \"info\",\n      message: `Function '${funcName}' is missing @ok documentation`,\n      target: funcName,\n      tag: \"ok\",\n    });\n  }\n\n  // Validate @param against ABI (if available)\n  if (abiFunc) {\n    const abiArgNames = new Set(abiFunc.args.map((a) => a.name));\n    const docArgNames = new Set(funcDoc.params.map((p) => p.name));\n\n    // Check for documented params that don't exist\n    for (const param of funcDoc.params) {\n      if (!abiArgNames.has(param.name)) {\n        diagnostics.push({\n          severity: \"error\",\n          message: `Function '${funcName}': @param '${param.name}' does not match any function argument`,\n          target: funcName,\n          tag: \"param\",\n          line: funcDoc.startLine,\n        });\n      }\n    }\n\n    // Check for undocumented params\n    for (const arg of abiFunc.args) {\n      if (!docArgNames.has(arg.name)) {\n        diagnostics.push({\n          severity: \"warning\",\n          message: `Function '${funcName}': argument '${arg.name}' is not documented with @param`,\n          target: funcName,\n          tag: \"param\",\n        });\n      }\n    }\n  }\n\n  return diagnostics;\n}\n\n/** Calculate documentation coverage metrics */\nexport interface CoverageMetrics {\n  /** Total number of public/read-only functions */\n  totalFunctions: number;\n  /** Number of documented functions */\n  documentedFunctions: number;\n  /** Function coverage percentage (0-100) */\n  functionCoverage: number;\n  /** Total number of maps */\n  totalMaps: number;\n  /** Number of documented maps */\n  documentedMaps: number;\n  /** Map coverage percentage (0-100) */\n  mapCoverage: number;\n  /** Total number of variables/constants */\n  totalVariables: number;\n  /** Number of documented variables/constants */\n  documentedVariables: number;\n  /** Variable coverage percentage (0-100) */\n  variableCoverage: number;\n  /** Overall coverage percentage (0-100) */\n  overallCoverage: number;\n}\n\n/** Calculate documentation coverage */\nexport function calculateCoverage(doc: ContractDoc, abi: ClarityContract): CoverageMetrics {\n  const publicFunctions = abi.functions.filter((f) => f.access !== \"private\");\n  const totalFunctions = publicFunctions.length;\n  const documentedFunctions = publicFunctions.filter((f) => doc.functions.has(f.name)).length;\n\n  const totalMaps = abi.maps?.length || 0;\n  const documentedMaps = (abi.maps || []).filter((m) => doc.maps.has(m.name)).length;\n\n  const totalVariables = abi.variables?.length || 0;\n  const documentedVariables = (abi.variables || []).filter((v) => {\n    const isConstant = v.access === \"constant\";\n    const docMap = isConstant ? doc.constants : doc.variables;\n    return docMap.has(v.name);\n  }).length;\n\n  const total = totalFunctions + totalMaps + totalVariables;\n  const documented = documentedFunctions + documentedMaps + documentedVariables;\n\n  return {\n    totalFunctions,\n    documentedFunctions,\n    functionCoverage: totalFunctions > 0 ? (documentedFunctions / totalFunctions) * 100 : 100,\n    totalMaps,\n    documentedMaps,\n    mapCoverage: totalMaps > 0 ? (documentedMaps / totalMaps) * 100 : 100,\n    totalVariables,\n    documentedVariables,\n    variableCoverage: totalVariables > 0 ? (documentedVariables / totalVariables) * 100 : 100,\n    overallCoverage: total > 0 ? (documented / total) * 100 : 100,\n  };\n}",
    "packages/clarity-docs/src/index.ts": "/**\n * @secondlayer/clarity-docs\n *\n * ClarityDoc - Documentation comment standard and tooling for Clarity smart contracts\n */\n\n// Types\nexport * from \"./types/index\";\n\n// Parser\nexport { tokenize, parseDefine, groupCommentBlocks } from \"./parser/lexer\";\nexport type { Token, TokenType, DefineType, DefineInfo, CommentBlock } from \"./parser/lexer\";\nexport { parseTagLine, parseDocBlock, extractParams, extractErrs, extractPosts, extractPrints, extractTagValues, extractFirstTagValue, extractCustomTags, extractCalls, extractCallers, extractImplements } from \"./parser/parser\";\nexport { extractDocs, extractDocsFromFile } from \"./parser/extractor\";\n\n// Validation\nexport { validateDocs, calculateCoverage } from \"./validation/validators\";\nexport type { Severity, Diagnostic, ValidationResult, CoverageMetrics } from \"./validation/validators\";\n\n// Generators\nexport { generateMarkdown } from \"./generators/markdown\";\nexport type { MarkdownOptions } from \"./generators/markdown\";\nexport { generateJson, toJson } from \"./generators/json\";\nexport type { JsonContractDoc, JsonFunctionDoc, JsonMapDoc, JsonVariableDoc, JsonTraitDoc } from \"./generators/json\";\n\n// Utils\nexport { stripDocs, estimateStrippingSavings } from \"./utils/index\";\nexport type { StripOptions } from \"./utils/index\";",
    "packages/clarity-docs/tests/generators.test.ts": "import { describe, it, expect } from \"vitest\";\nimport { extractDocs } from \"../src/parser/extractor\";\nimport { generateMarkdown } from \"../src/generators/markdown\";\nimport { generateJson, toJson } from \"../src/generators/json\";\n\ndescribe(\"generators\", () => {\n  const sampleSource = `;; @contract Counter Contract\n;; @author Test Author\n;; @desc A simple counter contract\n;; @implements .counter-trait.counter\n\n;; @desc The counter value\n(define-data-var counter uint u0)\n\n;; @desc Increment the counter\n;; @param amount The amount to add\n;; @ok The new counter value\n;; @err ERR_OVERFLOW Counter would overflow\n;; @caller Must be contract owner\n;; @calls .token-contract transfer Pays fee\n;; @prints {amount: uint, new-value: uint} counter-incremented Emitted on success\n;; @example (increment u5)\n(define-public (increment (amount uint))\n  (ok u1))\n\n;; @desc Get the current counter value\n;; @ok The counter value\n(define-read-only (get-counter)\n  (var-get counter))`;\n\n  describe(\"generateMarkdown\", () => {\n    it(\"should generate markdown with title\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"# Counter Contract\");\n    });\n\n    it(\"should include contract description\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"A simple counter contract\");\n    });\n\n    it(\"should include author\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"**Author:** Test Author\");\n    });\n\n    it(\"should include table of contents\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"## Table of Contents\");\n      expect(md).toContain(\"- [Functions](#functions)\");\n      expect(md).toContain(\"- [Variables](#variables)\");\n    });\n\n    it(\"should include function documentation\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"### `increment`\");\n      expect(md).toContain(\"`public`\");\n      expect(md).toContain(\"Increment the counter\");\n      expect(md).toContain(\"**Parameters:**\");\n      expect(md).toContain(\"| `amount` |\");\n      expect(md).toContain(\"The amount to add\");\n    });\n\n    it(\"should include err documentation\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"**Errs:**\");\n      expect(md).toContain(\"`ERR_OVERFLOW`\");\n      expect(md).toContain(\"Counter would overflow\");\n    });\n\n    it(\"should include examples\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"**Examples:**\");\n      expect(md).toContain(\"```clarity\");\n      expect(md).toContain(\"(increment u5)\");\n    });\n\n    it(\"should include prints documentation\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"**Prints:**\");\n      expect(md).toContain(\"`counter-incremented`\");\n      expect(md).toContain(\"`{amount: uint, new-value: uint}`\");\n      expect(md).toContain(\"Emitted on success\");\n    });\n\n    it(\"should include variable documentation\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc);\n\n      expect(md).toContain(\"## Variables\");\n      expect(md).toContain(\"### `counter`\");\n      expect(md).toContain(\"`data-var`\");\n    });\n\n    it(\"should skip TOC when disabled\", () => {\n      const doc = extractDocs(sampleSource);\n      const md = generateMarkdown(doc, undefined, { includeToc: false });\n\n      expect(md).not.toContain(\"## Table of Contents\");\n    });\n\n    it(\"should use custom contract name\", () => {\n      const source = `;; Just a description\n(define-data-var x uint u0)`;\n      const doc = extractDocs(source);\n      const md = generateMarkdown(doc, undefined, { contractName: \"My Contract\" });\n\n      expect(md).toContain(\"# My Contract\");\n    });\n  });\n\n  describe(\"generateJson\", () => {\n    it(\"should generate valid JSON\", () => {\n      const doc = extractDocs(sampleSource);\n      const json = generateJson(doc);\n\n      expect(() => JSON.parse(json)).not.toThrow();\n    });\n\n    it(\"should include header information\", () => {\n      const doc = extractDocs(sampleSource);\n      const result = toJson(doc);\n\n      expect(result.header.contract).toBe(\"Counter Contract\");\n      expect(result.header.author).toBe(\"Test Author\");\n      expect(result.header.desc).toBe(\"A simple counter contract\");\n    });\n\n    it(\"should include functions\", () => {\n      const doc = extractDocs(sampleSource);\n      const result = toJson(doc);\n\n      expect(result.functions).toHaveLength(2);\n\n      const increment = result.functions.find(f => f.name === \"increment\");\n      expect(increment).toBeDefined();\n      expect(increment?.access).toBe(\"public\");\n      expect(increment?.params).toEqual([{ name: \"amount\", description: \"The amount to add\" }]);\n      expect(increment?.errs).toEqual([{ code: \"ERR_OVERFLOW\", description: \"Counter would overflow\" }]);\n    });\n\n    it(\"should include prints in JSON\", () => {\n      const doc = extractDocs(sampleSource);\n      const result = toJson(doc);\n\n      const increment = result.functions.find(f => f.name === \"increment\");\n      expect(increment?.prints).toEqual([{\n        name: \"counter-incremented\",\n        type: \"amount: uint, new-value: uint\",\n        description: \"Emitted on success\",\n      }]);\n    });\n\n    it(\"should include variables\", () => {\n      const doc = extractDocs(sampleSource);\n      const result = toJson(doc);\n\n      expect(result.variables).toHaveLength(1);\n      expect(result.variables[0].name).toBe(\"counter\");\n      expect(result.variables[0].type).toBe(\"variable\");\n    });\n\n    it(\"should generate compact JSON when not pretty\", () => {\n      const doc = extractDocs(sampleSource);\n      const pretty = generateJson(doc, true);\n      const compact = generateJson(doc, false);\n\n      expect(compact.length).toBeLessThan(pretty.length);\n      expect(compact).not.toContain(\"\\n\");\n    });\n\n    it(\"should include implements in header\", () => {\n      const doc = extractDocs(sampleSource);\n      const result = toJson(doc);\n\n      expect(result.header.implements).toEqual([\".counter-trait.counter\"]);\n    });\n\n    it(\"should include calls in function\", () => {\n      const doc = extractDocs(sampleSource);\n      const result = toJson(doc);\n\n      const increment = result.functions.find(f => f.name === \"increment\");\n      expect(increment?.calls).toEqual([{\n        contract: \".token-contract\",\n        function: \"transfer\",\n        description: \"Pays fee\",\n      }]);\n    });\n\n    it(\"should include callers in function\", () => {\n      const doc = extractDocs(sampleSource);\n      const result = toJson(doc);\n\n      const increment = result.functions.find(f => f.name === \"increment\");\n      expect(increment?.callers).toEqual([\"Must be contract owner\"]);\n    });\n  });\n});",
    "packages/clarity-docs/tests/parser.test.ts": "import { describe, it, expect } from \"vitest\";\nimport { tokenize, parseDefine, groupCommentBlocks } from \"../src/parser/lexer\";\nimport { parseDocBlock, parseTagLine, extractParams, extractErrs, extractPrints, extractCalls, extractCallers, extractImplements } from \"../src/parser/parser\";\nimport { extractDocs } from \"../src/parser/extractor\";\n\ndescribe(\"lexer\", () => {\n  describe(\"tokenize\", () => {\n    it(\"should tokenize comment lines\", () => {\n      const source = `;; This is a comment\n;; Another comment`;\n      const tokens = tokenize(source);\n\n      expect(tokens).toHaveLength(3); // 2 comments + EOF\n      expect(tokens[0]).toEqual({ type: \"comment\", value: \"This is a comment\", line: 1 });\n      expect(tokens[1]).toEqual({ type: \"comment\", value: \"Another comment\", line: 2 });\n      expect(tokens[2].type).toBe(\"eof\");\n    });\n\n    it(\"should tokenize define expressions\", () => {\n      const source = `(define-public (my-function (arg uint))\n  (ok u1))`;\n      const tokens = tokenize(source);\n\n      expect(tokens[0]).toEqual({\n        type: \"define\",\n        value: \"(define-public (my-function (arg uint))\",\n        line: 1,\n      });\n    });\n\n    it(\"should skip empty lines and single-semicolon comments\", () => {\n      const source = `\n; single semicolon comment\n;; doc comment\n`;\n      const tokens = tokenize(source);\n\n      expect(tokens).toHaveLength(2); // 1 doc comment + EOF\n      expect(tokens[0].type).toBe(\"comment\");\n    });\n  });\n\n  describe(\"parseDefine\", () => {\n    it(\"should parse public function\", () => {\n      const result = parseDefine(\"(define-public (my-function (arg uint))\");\n      expect(result).toEqual({\n        type: \"public\",\n        name: \"my-function\",\n        line: 0,\n        fullMatch: \"(define-public (my-function (arg uint))\",\n      });\n    });\n\n    it(\"should parse read-only function\", () => {\n      const result = parseDefine(\"(define-read-only (get-value)\");\n      expect(result).toEqual({\n        type: \"read-only\",\n        name: \"get-value\",\n        line: 0,\n        fullMatch: \"(define-read-only (get-value)\",\n      });\n    });\n\n    it(\"should parse private function\", () => {\n      const result = parseDefine(\"(define-private (helper-fn (x uint))\");\n      expect(result).toEqual({\n        type: \"private\",\n        name: \"helper-fn\",\n        line: 0,\n        fullMatch: \"(define-private (helper-fn (x uint))\",\n      });\n    });\n\n    it(\"should parse data-var\", () => {\n      const result = parseDefine(\"(define-data-var counter uint u0)\");\n      expect(result).toEqual({\n        type: \"data-var\",\n        name: \"counter\",\n        line: 0,\n        fullMatch: \"(define-data-var counter uint u0)\",\n      });\n    });\n\n    it(\"should parse map\", () => {\n      const result = parseDefine(\"(define-map balances principal uint)\");\n      expect(result).toEqual({\n        type: \"map\",\n        name: \"balances\",\n        line: 0,\n        fullMatch: \"(define-map balances principal uint)\",\n      });\n    });\n\n    it(\"should parse constant\", () => {\n      const result = parseDefine(\"(define-constant MAX_VALUE u1000)\");\n      expect(result).toEqual({\n        type: \"constant\",\n        name: \"MAX_VALUE\",\n        line: 0,\n        fullMatch: \"(define-constant MAX_VALUE u1000)\",\n      });\n    });\n\n    it(\"should parse trait\", () => {\n      const result = parseDefine(\"(define-trait my-trait ((transfer (uint principal) (response bool uint))))\");\n      expect(result).toEqual({\n        type: \"trait\",\n        name: \"my-trait\",\n        line: 0,\n        fullMatch: \"(define-trait my-trait ((transfer (uint principal) (response bool uint))))\",\n      });\n    });\n  });\n\n  describe(\"groupCommentBlocks\", () => {\n    it(\"should group consecutive comments\", () => {\n      const source = `;; Line 1\n;; Line 2\n(define-public (test))`;\n      const tokens = tokenize(source);\n      const blocks = groupCommentBlocks(tokens);\n\n      expect(blocks).toHaveLength(1);\n      expect(blocks[0].block.comments).toHaveLength(2);\n      expect(blocks[0].followingDefine).not.toBeNull();\n      expect(blocks[0].followingDefine?.name).toBe(\"test\");\n    });\n\n    it(\"should handle orphaned comment blocks\", () => {\n      const source = `;; Orphaned comment\n\n(define-public (test))`;\n      const tokens = tokenize(source);\n      const blocks = groupCommentBlocks(tokens);\n\n      // The comment block is followed by an \"other\" token (empty line behavior)\n      // Actually with our tokenize, empty lines are skipped, so the define follows\n      expect(blocks).toHaveLength(1);\n    });\n  });\n});\n\ndescribe(\"parser\", () => {\n  describe(\"parseTagLine\", () => {\n    it(\"should parse simple tag\", () => {\n      const result = parseTagLine(\"@desc This is a description\", 1);\n      expect(result).toEqual({\n        tag: \"desc\",\n        description: \"This is a description\",\n        line: 1,\n      });\n    });\n\n    it(\"should parse named tag\", () => {\n      const result = parseTagLine(\"@param amount The amount to transfer\", 1);\n      expect(result).toEqual({\n        tag: \"param\",\n        name: \"amount\",\n        description: \"The amount to transfer\",\n        line: 1,\n      });\n    });\n\n    it(\"should parse err tag\", () => {\n      const result = parseTagLine(\"@err ERR_OVERFLOW Counter would overflow\", 1);\n      expect(result).toEqual({\n        tag: \"err\",\n        name: \"ERR_OVERFLOW\",\n        description: \"Counter would overflow\",\n        line: 1,\n      });\n    });\n\n    it(\"should parse custom tag\", () => {\n      const result = parseTagLine(\"@custom:security Audited by XYZ\", 1);\n      expect(result).toEqual({\n        tag: \"custom:security\",\n        description: \"Audited by XYZ\",\n        line: 1,\n      });\n    });\n\n    it(\"should return null for non-tag lines\", () => {\n      const result = parseTagLine(\"Just a regular comment\", 1);\n      expect(result).toBeNull();\n    });\n  });\n\n  describe(\"parseDocBlock\", () => {\n    it(\"should parse multiple tags\", () => {\n      const block = {\n        comments: [\n          { type: \"comment\" as const, value: \"@desc A function\", line: 1 },\n          { type: \"comment\" as const, value: \"@param x The x value\", line: 2 },\n          { type: \"comment\" as const, value: \"@ok The result\", line: 3 },\n        ],\n        startLine: 1,\n        endLine: 3,\n      };\n\n      const result = parseDocBlock(block);\n\n      expect(result.tags).toHaveLength(3);\n      expect(result.tags[0]).toEqual({ tag: \"desc\", description: \"A function\", line: 1 });\n      expect(result.tags[1]).toEqual({ tag: \"param\", name: \"x\", description: \"The x value\", line: 2 });\n      expect(result.tags[2]).toEqual({ tag: \"ok\", description: \"The result\", line: 3 });\n    });\n\n    it(\"should treat free-form text as @desc\", () => {\n      const block = {\n        comments: [\n          { type: \"comment\" as const, value: \"This is just a description\", line: 1 },\n        ],\n        startLine: 1,\n        endLine: 1,\n      };\n\n      const result = parseDocBlock(block);\n\n      expect(result.tags).toHaveLength(1);\n      expect(result.tags[0].tag).toBe(\"desc\");\n      expect(result.tags[0].description).toBe(\"This is just a description\");\n    });\n\n    it(\"should handle multiline descriptions\", () => {\n      const block = {\n        comments: [\n          { type: \"comment\" as const, value: \"@desc First line\", line: 1 },\n          { type: \"comment\" as const, value: \"continued on second line\", line: 2 },\n        ],\n        startLine: 1,\n        endLine: 2,\n      };\n\n      const result = parseDocBlock(block);\n\n      expect(result.tags).toHaveLength(1);\n      expect(result.tags[0].description).toBe(\"First line continued on second line\");\n    });\n  });\n\n  describe(\"extractParams\", () => {\n    it(\"should extract param docs\", () => {\n      const tags = [\n        { tag: \"desc\" as const, description: \"A function\", line: 1 },\n        { tag: \"param\" as const, name: \"x\", description: \"The x value\", line: 2 },\n        { tag: \"param\" as const, name: \"y\", description: \"The y value\", line: 3 },\n      ];\n\n      const result = extractParams(tags);\n\n      expect(result).toEqual([\n        { name: \"x\", description: \"The x value\" },\n        { name: \"y\", description: \"The y value\" },\n      ]);\n    });\n  });\n\n  describe(\"extractErrs\", () => {\n    it(\"should extract err docs\", () => {\n      const tags = [\n        { tag: \"err\" as const, name: \"ERR_OVERFLOW\", description: \"Value too large\", line: 1 },\n        { tag: \"err\" as const, name: \"ERR_UNAUTHORIZED\", description: \"Not allowed\", line: 2 },\n      ];\n\n      const result = extractErrs(tags);\n\n      expect(result).toEqual([\n        { code: \"ERR_OVERFLOW\", description: \"Value too large\" },\n        { code: \"ERR_UNAUTHORIZED\", description: \"Not allowed\" },\n      ]);\n    });\n  });\n\n  describe(\"parseTagLine - prints\", () => {\n    it(\"should parse @prints with type and name\", () => {\n      const result = parseTagLine(\"@prints {uint} count The iteration count\", 1);\n      expect(result).toEqual({\n        tag: \"prints\",\n        name: \"count\",\n        description: \"{uint} The iteration count\",\n        line: 1,\n      });\n    });\n\n    it(\"should parse @prints without type\", () => {\n      const result = parseTagLine(\"@prints debug A debug message\", 1);\n      expect(result).toEqual({\n        tag: \"prints\",\n        name: \"debug\",\n        description: \"A debug message\",\n        line: 1,\n      });\n    });\n\n    it(\"should parse @prints with tuple type\", () => {\n      const result = parseTagLine(\"@prints {from: principal, to: principal} transfer Emitted on success\", 1);\n      expect(result).toEqual({\n        tag: \"prints\",\n        name: \"transfer\",\n        description: \"{from: principal, to: principal} Emitted on success\",\n        line: 1,\n      });\n    });\n  });\n\n  describe(\"extractPrints\", () => {\n    it(\"should extract prints with name only\", () => {\n      const tags = [\n        { tag: \"prints\" as const, name: \"transfer\", description: \"Emitted on success\", line: 1 },\n      ];\n      const result = extractPrints(tags);\n      expect(result).toEqual([{ name: \"transfer\", description: \"Emitted on success\" }]);\n    });\n\n    it(\"should extract prints with type annotation\", () => {\n      const tags = [\n        { tag: \"prints\" as const, name: \"transfer\", description: \"{from: principal, to: principal} Emitted on success\", line: 1 },\n      ];\n      const result = extractPrints(tags);\n      expect(result).toEqual([{\n        name: \"transfer\",\n        type: \"from: principal, to: principal\",\n        description: \"Emitted on success\",\n      }]);\n    });\n\n    it(\"should extract prints with primitive type\", () => {\n      const tags = [\n        { tag: \"prints\" as const, name: \"count\", description: \"{uint} The count\", line: 1 },\n      ];\n      const result = extractPrints(tags);\n      expect(result).toEqual([{\n        name: \"count\",\n        type: \"uint\",\n        description: \"The count\",\n      }]);\n    });\n  });\n\n  describe(\"parseTagLine - implements\", () => {\n    it(\"should parse @implements with local ref\", () => {\n      const result = parseTagLine(\"@implements .sip-010-trait.ft-trait\", 1);\n      expect(result).toEqual({\n        tag: \"implements\",\n        description: \".sip-010-trait.ft-trait\",\n        line: 1,\n      });\n    });\n\n    it(\"should parse @implements with full principal\", () => {\n      const result = parseTagLine(\"@implements 'SP2C2Y.token.ft-trait\", 1);\n      expect(result).toEqual({\n        tag: \"implements\",\n        description: \"'SP2C2Y.token.ft-trait\",\n        line: 1,\n      });\n    });\n  });\n\n  describe(\"parseTagLine - calls\", () => {\n    it(\"should parse @calls with local contract\", () => {\n      const result = parseTagLine(\"@calls .token-contract transfer Transfers tokens\", 1);\n      expect(result).toEqual({\n        tag: \"calls\",\n        name: \"transfer\",\n        description: \".token-contract Transfers tokens\",\n        line: 1,\n      });\n    });\n\n    it(\"should parse @calls with full principal\", () => {\n      const result = parseTagLine(\"@calls 'SP2C2Y.wrapped-stx wrap\", 1);\n      expect(result).toEqual({\n        tag: \"calls\",\n        name: \"wrap\",\n        description: \"'SP2C2Y.wrapped-stx\",\n        line: 1,\n      });\n    });\n  });\n\n  describe(\"parseTagLine - caller\", () => {\n    it(\"should parse @caller as freeform\", () => {\n      const result = parseTagLine(\"@caller Must be contract-owner\", 1);\n      expect(result).toEqual({\n        tag: \"caller\",\n        description: \"Must be contract-owner\",\n        line: 1,\n      });\n    });\n  });\n\n  describe(\"extractCalls\", () => {\n    it(\"should extract call docs\", () => {\n      const tags = [\n        { tag: \"calls\" as const, name: \"transfer\", description: \".token Moves tokens\", line: 1 },\n      ];\n      const result = extractCalls(tags);\n      expect(result).toEqual([{\n        contract: \".token\",\n        function: \"transfer\",\n        description: \"Moves tokens\",\n      }]);\n    });\n\n    it(\"should extract call docs without description\", () => {\n      const tags = [\n        { tag: \"calls\" as const, name: \"wrap\", description: \"'SP2C2Y.wrapped-stx\", line: 1 },\n      ];\n      const result = extractCalls(tags);\n      expect(result).toEqual([{\n        contract: \"'SP2C2Y.wrapped-stx\",\n        function: \"wrap\",\n        description: undefined,\n      }]);\n    });\n  });\n\n  describe(\"extractCallers\", () => {\n    it(\"should extract caller descriptions\", () => {\n      const tags = [\n        { tag: \"caller\" as const, description: \"Must be owner\", line: 1 },\n      ];\n      const result = extractCallers(tags);\n      expect(result).toEqual([\"Must be owner\"]);\n    });\n\n    it(\"should extract multiple callers\", () => {\n      const tags = [\n        { tag: \"caller\" as const, description: \"Must be owner\", line: 1 },\n        { tag: \"caller\" as const, description: \"Must be whitelisted\", line: 2 },\n      ];\n      const result = extractCallers(tags);\n      expect(result).toEqual([\"Must be owner\", \"Must be whitelisted\"]);\n    });\n  });\n\n  describe(\"extractImplements\", () => {\n    it(\"should extract implements refs\", () => {\n      const tags = [\n        { tag: \"implements\" as const, description: \".sip-010.ft-trait\", line: 1 },\n      ];\n      const result = extractImplements(tags);\n      expect(result).toEqual([\".sip-010.ft-trait\"]);\n    });\n\n    it(\"should extract multiple implements\", () => {\n      const tags = [\n        { tag: \"implements\" as const, description: \".sip-010.ft-trait\", line: 1 },\n        { tag: \"implements\" as const, description: \".burnable.burnable-trait\", line: 2 },\n      ];\n      const result = extractImplements(tags);\n      expect(result).toEqual([\".sip-010.ft-trait\", \".burnable.burnable-trait\"]);\n    });\n  });\n});\n\ndescribe(\"extractor\", () => {\n  describe(\"extractDocs\", () => {\n    it(\"should extract contract-level documentation\", () => {\n      const source = `;; @contract Counter Contract\n;; @author Test Author\n;; @desc A simple counter\n\n(define-data-var counter uint u0)`;\n\n      const result = extractDocs(source);\n\n      expect(result.header.contract).toBe(\"Counter Contract\");\n      expect(result.header.author).toBe(\"Test Author\");\n      expect(result.header.desc).toBe(\"A simple counter\");\n    });\n\n    it(\"should extract function documentation\", () => {\n      const source = `;; @desc Increment the counter\n;; @param amount The amount to add\n;; @ok The new counter value\n;; @err ERR_OVERFLOW Counter would overflow\n(define-public (increment (amount uint))\n  (ok u1))`;\n\n      const result = extractDocs(source);\n\n      expect(result.functions.has(\"increment\")).toBe(true);\n      const func = result.functions.get(\"increment\")!;\n      expect(func.desc).toBe(\"Increment the counter\");\n      expect(func.params).toEqual([{ name: \"amount\", description: \"The amount to add\" }]);\n      expect(func.ok).toBe(\"The new counter value\");\n      expect(func.errs).toEqual([{ code: \"ERR_OVERFLOW\", description: \"Counter would overflow\" }]);\n      expect(func.access).toBe(\"public\");\n    });\n\n    it(\"should extract map documentation\", () => {\n      const source = `;; @desc User balances\n;; @key principal The user address\n;; @value uint The balance\n(define-map balances principal uint)`;\n\n      const result = extractDocs(source);\n\n      expect(result.maps.has(\"balances\")).toBe(true);\n      const map = result.maps.get(\"balances\")!;\n      expect(map.desc).toBe(\"User balances\");\n      expect(map.key).toBe(\"principal The user address\");\n      expect(map.value).toBe(\"uint The balance\");\n    });\n\n    it(\"should extract variable documentation\", () => {\n      const source = `;; @desc The counter value\n;; @dev Initialized to zero\n(define-data-var counter uint u0)`;\n\n      const result = extractDocs(source);\n\n      expect(result.variables.has(\"counter\")).toBe(true);\n      const variable = result.variables.get(\"counter\")!;\n      expect(variable.desc).toBe(\"The counter value\");\n      expect(variable.dev).toBe(\"Initialized to zero\");\n    });\n\n    it(\"should extract constant documentation\", () => {\n      const source = `;; @desc Maximum allowed value\n(define-constant MAX_VALUE u1000)`;\n\n      const result = extractDocs(source);\n\n      expect(result.constants.has(\"MAX_VALUE\")).toBe(true);\n      const constant = result.constants.get(\"MAX_VALUE\")!;\n      expect(constant.desc).toBe(\"Maximum allowed value\");\n    });\n\n    it(\"should handle complete contract\", () => {\n      const source = `;; @contract Complete Contract\n;; @author Developer\n\n;; @desc The counter\n(define-data-var counter uint u0)\n\n;; @desc Get counter\n;; @ok Current value\n(define-read-only (get-counter)\n  (var-get counter))\n\n;; @desc Increment\n;; @param n Amount\n(define-public (increment (n uint))\n  (ok (var-set counter (+ (var-get counter) n))))`;\n\n      const result = extractDocs(source);\n\n      expect(result.header.contract).toBe(\"Complete Contract\");\n      expect(result.variables.size).toBe(1);\n      expect(result.functions.size).toBe(2);\n      expect(result.functions.get(\"get-counter\")?.access).toBe(\"read-only\");\n      expect(result.functions.get(\"increment\")?.access).toBe(\"public\");\n    });\n  });\n});",
    "packages/clarity-docs/bunup.config.ts": "import { defineConfig } from \"bunup\";\n\nexport default defineConfig({\n  entry: [\"src/index.ts\"],\n  format: [\"esm\"],\n  dts: true,\n  splitting: false,\n  sourcemap: \"linked\",\n  minify: false,\n});",
    "packages/clarity-docs/SIP-DRAFT-claritydoc.md": "# SIP-XXX: ClarityDoc - Documentation Comment Standard for Clarity\n\n## Preamble\n\n| Field | Value |\n|-------|-------|\n| SIP Number | XXX (assigned upon acceptance) |\n| Title | ClarityDoc - Documentation Comment Standard for Clarity |\n| Authors | Ryan Waits <ryan@secondlayer.dev> |\n| Consideration | Technical |\n| Type | Standard |\n| Status | Draft |\n| Created | 2024-12-21 |\n| License | BSD-2-Clause |\n| Layer | Applications |\n\n## Abstract\n\nThis SIP proposes **ClarityDoc**, a structured documentation comment format for Clarity smart contracts. ClarityDoc extends the existing `;;` comment syntax with `@tag` annotations to provide machine-readable documentation for functions, variables, maps, and contracts.\n\nClarityDoc enables:\n- Automated API documentation generation\n- IDE integration with rich hover information\n- Documentation coverage analysis\n- Consistent documentation practices across the ecosystem\n\nThe format is designed to be backwards compatibleâ€”existing `;;` comments remain valid and are interpreted as `@notice` tags.\n\n## License and Copyright\n\nThis SIP is made available under the terms of the BSD-2-Clause license.\n\n## Introduction\n\n### Problem Statement\n\nClarity is the smart contract language for the Stacks blockchain, yet it lacks a standardized documentation format. Unlike other smart contract and programming languages:\n\n| Language | Documentation Standard | Adoption |\n|----------|----------------------|----------|\n| Solidity | NatSpec (`@param`, `@return`, `@notice`) | Universal |\n| TypeScript | JSDoc/TSDoc | Universal |\n| Rust | rustdoc (`///` comments with Markdown) | Universal |\n| Python | Docstrings (Google, NumPy, Sphinx) | High |\n| **Clarity** | **None** | N/A |\n\nDevelopers currently use ad-hoc `;;` comments without consistent structure, leading to:\n\n1. **No automated documentation** - Tools cannot extract structured API docs\n2. **Inconsistent practices** - Each project documents differently\n3. **Poor IDE support** - No hover information or parameter hints\n4. **No coverage metrics** - Cannot measure documentation completeness\n5. **Difficult auditing** - Auditors must manually parse comments\n\n### Solution\n\nClarityDoc provides a lightweight, familiar tag-based system that:\n\n- **Preserves backwards compatibility** - Plain `;;` comments still work\n- **Enables automation** - Machine-readable structure for tooling\n- **Follows conventions** - Familiar to developers from NatSpec/JSDoc\n- **Supports validation** - Tools can verify `@param` matches actual args\n\n## Specification\n\n### Comment Syntax\n\nClarityDoc comments use the existing `;;` prefix with optional `@tag` annotations:\n\n```clarity\n;; @desc Human-readable description of what this does\n;; @param name Description of the parameter\n;; @ok Description of the success value\n(define-public (function-name (name type))\n  ...)\n```\n\nComments without tags are treated as `@desc`:\n\n```clarity\n;; This is equivalent to @desc This is equivalent to\n(define-public (example) ...)\n```\n\n### Supported Tags\n\n#### Contract-Level Tags\n\n| Tag | Description | Example |\n|-----|-------------|---------|\n| `@contract` | Contract name/title | `@contract Token Contract` |\n| `@author` | Author name and/or email | `@author Alice <alice@example.com>` |\n| `@desc` | Human-readable contract description | `@desc A fungible token implementation` |\n| `@dev` | Developer notes, implementation details | `@dev Uses SIP-010 standard` |\n| `@version` | Version or deployment info | `@version 1.0.0` |\n| `@uri` | Off-chain documentation URL | `@uri https://docs.example.com/token` |\n| `@hash` | Documentation hash for integrity | `@hash sha256:abc123...` |\n\n#### Function Tags\n\n| Tag | Description | Example |\n|-----|-------------|---------|\n| `@desc` | What the function does | `@desc Transfer tokens to recipient` |\n| `@dev` | Implementation notes | `@dev Checks balance before transfer` |\n| `@param` | Parameter description | `@param amount The number of tokens` |\n| `@ok` | Success value description | `@ok The new balance` |\n| `@err` | Error case description | `@err ERR_INSUFFICIENT_BALANCE Not enough tokens` |\n| `@post` | Asset transfer/mint postcondition | `@post stx Transfers STX to recipient` |\n| `@prints` | Print statements triggered | `@prints {from: principal, to: principal} transfer Emitted on success` |\n| `@example` | Usage example | `@example (transfer u100 'SP123...)` |\n\n**Note on `@post`:** This tag documents asset movements (STX, FTs, NFTs) that occur as a result of calling the function. This helps wallets display what assets will leave the user's account. See Clarity 4's `restrict-assets?` and `with-stx`/`with-ft`/`with-nft` for programmatic asset restrictions.\n\n**`@post` Asset Types:**\n\n| Asset Type | Syntax | Example |\n|------------|--------|---------|\n| STX | `@post stx <description>` | `@post stx Transfers 10 STX to contract` |\n| Fungible Token | `@post <ft-name> <description>` | `@post token Transfers `amount` tokens to recipient` |\n| NFT | `@post <nft-name> <description>` | `@post my-nft Transfers NFT `token-id` to recipient` |\n\n**FT Examples:**\n```clarity\n;; @desc Transfer tokens between accounts\n;; @param amount Number of tokens to transfer\n;; @param recipient Destination address\n;; @post my-token Transfers `amount` tokens from sender to recipient\n;; @post stx Transfers 1 STX fee to contract\n;; @ok True on successful transfer\n(define-public (transfer (amount uint) (recipient principal))\n  (begin\n    (try! (ft-transfer? my-token amount tx-sender recipient))\n    (try! (stx-transfer? u1000000 tx-sender (as-contract tx-sender)))\n    (ok true)))\n\n;; @desc Mint new tokens\n;; @param amount Number of tokens to mint\n;; @param recipient Address to receive tokens\n;; @post my-token Mints `amount` new tokens to recipient\n;; @ok True on successful mint\n(define-public (mint (amount uint) (recipient principal))\n  (begin\n    (try! (ft-mint? my-token amount recipient))\n    (ok true)))\n\n;; @desc Burn tokens from sender\n;; @param amount Number of tokens to burn\n;; @post my-token Burns `amount` tokens from sender (destroyed)\n;; @ok True on successful burn\n(define-public (burn (amount uint))\n  (begin\n    (try! (ft-burn? my-token amount tx-sender))\n    (ok true)))\n```\n\n**NFT Examples:**\n```clarity\n;; @desc Transfer an NFT to a new owner\n;; @param token-id The NFT identifier to transfer\n;; @param recipient New owner address\n;; @post my-nft Transfers NFT `token-id` from sender to recipient\n;; @ok True on successful transfer\n(define-public (transfer-nft (token-id uint) (recipient principal))\n  (begin\n    (try! (nft-transfer? my-nft token-id tx-sender recipient))\n    (ok true)))\n\n;; @desc Mint a new NFT\n;; @param token-id The NFT identifier to mint\n;; @param recipient Owner of the new NFT\n;; @post my-nft Mints new NFT `token-id` to recipient\n;; @ok True on successful mint\n(define-public (mint (token-id uint) (recipient principal))\n  (begin\n    (try! (nft-mint? my-nft token-id recipient))\n    (ok true)))\n\n;; @desc Burn an NFT\n;; @param token-id The NFT identifier to burn\n;; @post my-nft Burns NFT `token-id` from sender (destroyed)\n;; @ok True on successful burn\n(define-public (burn (token-id uint))\n  (begin\n    (try! (nft-burn? my-nft token-id tx-sender))\n    (ok true)))\n```\n\n#### Map Tags\n\n| Tag | Description | Example |\n|-----|-------------|---------|\n| `@desc` | Map purpose | `@desc Stores user balances` |\n| `@key` | Key type description | `@key principal The account address` |\n| `@value` | Value type description | `@value uint The token balance` |\n\n#### Variable/Constant Tags\n\n| Tag | Description | Example |\n|-----|-------------|---------|\n| `@desc` | Variable purpose | `@desc Total supply of tokens` |\n| `@dev` | Implementation notes | `@dev Updated on mint/burn` |\n| `@err` | Error constant description (constants only) | `@err Balance too low` |\n| `@example` | Usage example (constants only) | `@example (asserts! (> balance u0) ERR_ZERO)` |\n\n**Error Constants:** When `@err` is used on a constant, the parser extracts the error code from `(err uXX)` values, enabling wallets and explorers to display human-readable error messages instead of cryptic codes like `(err u67)`.\n\n#### Universal Tags\n\nThese tags can be used on any definition:\n\n| Tag | Description | Example |\n|-----|-------------|---------|\n| `@deprecated` | Deprecation notice | `@deprecated Use transfer-v2 instead` |\n| `@see` | Cross-reference | `@see transfer-v2` |\n| `@custom:*` | Custom tags | `@custom:security Audited by XYZ` |\n\n### Grammar\n\n```ebnf\ndoc-block     = { doc-line } ;\ndoc-line      = \";;\" [ whitespace ] [ tag-content | free-text ] newline ;\ntag-content   = \"@\" tag-name [ whitespace tag-arg ] [ whitespace description ] ;\ntag-name      = identifier | \"custom:\" identifier ;\ntag-arg       = identifier ;\ndescription   = { any-char-except-newline } ;\nidentifier    = letter { letter | digit | \"-\" | \"_\" } ;\nfree-text     = { any-char-except-newline } ;\n```\n\n### Attachment Rules\n\n1. **Immediate attachment**: A doc block attaches to the immediately following `define-*` expression\n2. **Contract header**: The first doc block containing `@contract` or `@author` is the contract header, regardless of what follows\n3. **Block separation**: An empty line between `;;` comments creates separate doc blocks\n4. **No attachment**: Doc blocks not followed by a `define-*` (after the header) are ignored\n\n### Complete Example\n\n```clarity\n;; @contract Counter Contract\n;; @author Alice <alice@example.com>\n;; @desc A simple incrementing counter for demonstration\n;; @dev Deployed to mainnet at SP123...\n;; @version 1.0.0\n;; @uri https://docs.example.com/counter\n;; @hash sha256:a1b2c3d4e5f6...\n\n;; @desc Maximum allowed counter value\n(define-constant MAX_VALUE u1000000)\n\n;; @err Amount must be greater than zero\n(define-constant ERR_ZERO_AMOUNT (err u1))\n\n;; @err Counter would exceed MAX_VALUE\n(define-constant ERR_OVERFLOW (err u2))\n\n;; @err Caller is not authorized\n(define-constant ERR_UNAUTHORIZED (err u100))\n\n;; @desc The current counter value\n;; @dev Initialized to zero on deployment\n(define-data-var counter uint u0)\n\n;; @desc Tracks increment history per user\n;; @key principal The user's address\n;; @value uint Total increments by this user\n(define-map user-increments principal uint)\n\n;; @desc Increment the counter by a specified amount\n;; @param amount The value to add to the counter\n;; @ok The new counter value after incrementing\n;; @err ERR_OVERFLOW Counter would exceed MAX_VALUE\n;; @err ERR_ZERO_AMOUNT Amount must be greater than zero\n;; @prints {amount: uint, new-value: uint} counter-incremented Emitted after successful increment\n;; @example (increment u5)\n(define-public (increment (amount uint))\n  (let ((current (var-get counter))\n        (new-value (+ current amount)))\n    (asserts! (> amount u0) ERR_ZERO_AMOUNT)\n    (asserts! (<= new-value MAX_VALUE) ERR_OVERFLOW)\n    (var-set counter new-value)\n    (print { event: \"counter-incremented\", amount: amount, new-value: new-value })\n    (ok new-value)))\n\n;; @desc Get the current counter value\n;; @ok The current counter value as uint\n(define-read-only (get-counter)\n  (ok (var-get counter)))\n\n;; @desc Reset counter to zero\n;; @dev Only callable by contract owner\n;; @deprecated Use set-counter instead for more flexibility\n(define-public (reset)\n  (begin\n    (var-set counter u0)\n    (ok u0)))\n```\n\n## Related Work\n\n### NatSpec (Ethereum/Solidity)\n\nNatSpec is the documentation standard for Solidity smart contracts, using `///` or `/** */` comments with tags like `@notice`, `@param`, `@return`. ClarityDoc adopts some NatSpec conventions but uses Clarity-native terminology.\n\n**Differences:**\n- ClarityDoc uses `;;` prefix (Clarity's comment syntax)\n- ClarityDoc uses `@ok`/`@err` instead of `@return`/`@error` to match Clarity's response types\n- ClarityDoc uses `@desc` instead of `@notice` (aligned with original SIP-014 proposal)\n- ClarityDoc adds `@post` for postconditions (asset transfers)\n- ClarityDoc adds `@key`/`@value` for map documentation\n\n### JSDoc/TSDoc (JavaScript/TypeScript)\n\nJSDoc uses `/** */` comments with `@param`, `@returns`, `@example`. TSDoc extends this for TypeScript.\n\n**Differences:**\n- ClarityDoc uses `@ok`/`@err` to match Clarity's response types\n- ClarityDoc uses `@desc` for descriptions (aligned with SIP-014)\n- ClarityDoc adds Clarity-specific tags for maps and contract metadata\n\n### rustdoc (Rust)\n\nRust uses `///` comments with Markdown formatting. Documentation is tightly integrated with the compiler.\n\n**Differences:**\n- ClarityDoc uses structured tags rather than pure Markdown\n- Tags provide machine-readable semantics for tooling\n\n## Backwards Compatibility\n\nClarityDoc is fully backwards compatible:\n\n1. **Existing comments are valid**: Any `;;` comment without tags is treated as `@desc`\n2. **No syntax changes**: Uses existing Clarity comment syntax\n3. **Opt-in adoption**: Projects can adopt incrementally\n4. **Graceful degradation**: Tools SHOULD handle missing documentation gracefully\n\nParsers implementing this SIP:\n- MUST accept comments without tags as `@desc` content\n- MUST ignore unknown tags (with optional warning)\n- SHOULD NOT require any specific tags to be present\n\n## Design Decision: `;;` vs `;;;`\n\nThis SIP uses the standard `;;` comment syntax rather than introducing a new `;;;` doc-comment syntax. This decision was made for several reasons:\n\n### Why Not `;;;`?\n\n1. **Clarity Wasm reduces the need**: With Clarity Wasm (see [stacks-core discussion](https://github.com/stacks-network/stacks-core/pull/2926)), only the compiled WASM module is loaded at runtime. Documentation comments only affect deployment cost, not execution cost. This significantly reduces the economic pressure to strip comments.\n\n2. **Breaking change with limited benefit**: Introducing `;;;` would require updates to:\n   - The Clarity parser/lexer\n   - All syntax highlighters and IDE extensions\n   - Developer mental models and habits\n\n   The benefit (easier stripping) doesn't justify this ecosystem-wide change.\n\n3. **Stripping is a build-tool concern**: Build tools like Clarinet can strip `;;` comments before deployment without requiring special syntax. This keeps the language simple while giving developers control.\n\n4. **Backwards compatibility**: Every existing `;;` comment remains valid. Developers can adopt `@` tags incrementally without changing their commenting style.\n\n### Cost Management Strategies\n\nFor developers concerned about deployment costs, ClarityDoc provides several strategies:\n\n1. **Off-chain documentation** (`@uri` + `@hash`): Keep verbose documentation off-chain, reference it with a URL, and verify integrity with a hash.\n\n2. **Build-time stripping**: Use `stripDocs()` to remove documentation before deployment while keeping essential tags like `@err` for wallet integration.\n\n3. **Selective documentation**: Only document public-facing functions; skip internal helpers.\n\nThe reference implementation (`@secondlayer/clarity-docs`) includes utilities for all these strategies.\n\n## Activation\n\nThis SIP is considered activated when:\n\n1. **Reference implementation published**: The `@secondlayer/clarity-docs` npm package provides parsing, validation, and generation tools\n2. **Tooling adoption**: At least one of the following adopts ClarityDoc:\n   - Clarinet CLI (`clarinet docs` command)\n   - Hiro Platform documentation viewer\n   - A VS Code extension with hover support\n3. **Community feedback**: A 30-day public comment period has completed\n4. **Documentation**: The Clarity Book or Hiro docs include ClarityDoc guidance\n\n## Reference Implementations\n\n### @secondlayer/clarity-docs\n\nA TypeScript library providing:\n\n- **Parser**: Extracts structured documentation from Clarity source\n- **Validator**: Checks `@param` tags match function arguments, validates tag placement\n- **Coverage**: Calculates documentation completeness metrics\n- **Generators**: Outputs Markdown and JSON documentation\n- **Stripping**: Remove docs before deployment while preserving essential tags\n\n**Installation:**\n```bash\nnpm install @secondlayer/clarity-docs\n```\n\n**Basic Usage:**\n```typescript\nimport { extractDocs, generateMarkdown, generateJson, validateDocs } from '@secondlayer/clarity-docs';\n\n// Parse documentation from source\nconst docs = extractDocs(claritySource);\n\n// Generate Markdown documentation\nconst markdown = generateMarkdown(docs);\n\n// Generate JSON documentation\nconst json = generateJson(docs);\n\n// Validate against ABI\nconst result = validateDocs(docs, contractAbi);\nconsole.log(`Valid: ${result.valid}`);\n```\n\n**Error Constants Example:**\n```typescript\nimport { extractDocs, toJson } from '@secondlayer/clarity-docs';\n\nconst source = `\n;; @contract Token Contract\n;; @uri https://docs.example.com/token\n\n;; @err Insufficient balance for transfer\n(define-constant ERR_INSUFFICIENT_BALANCE (err u1))\n\n;; @err Transfer amount must be positive\n(define-constant ERR_INVALID_AMOUNT (err u2))\n`;\n\nconst docs = extractDocs(source);\nconst json = toJson(docs);\n\n// Access error constants for wallet integration\nfor (const constant of json.constants) {\n  if (constant.isError) {\n    console.log(`${constant.errorCode}: ${constant.errorDescription}`);\n    // Output: u1: Insufficient balance for transfer\n    //         u2: Transfer amount must be positive\n  }\n}\n\n// Access off-chain docs URL\nconsole.log(`Documentation: ${json.header.uri}`);\n// Output: Documentation: https://docs.example.com/token\n```\n\n**Tag Validation Example:**\n```typescript\nimport { extractDocs, validateDocs, TAG_RULES, isTagValidForContext } from '@secondlayer/clarity-docs';\n\n// Check if a tag is valid for a context\nconsole.log(isTagValidForContext('param', 'public'));    // true\nconsole.log(isTagValidForContext('param', 'constant'));  // false\nconsole.log(isTagValidForContext('err', 'constant'));    // true (error constants)\n\n// Validate docs with tag placement warnings\nconst docs = extractDocs(source);\nconst result = validateDocs(docs, abi);\n\nfor (const diagnostic of result.diagnostics) {\n  if (diagnostic.tag) {\n    console.log(`${diagnostic.severity}: ${diagnostic.message}`);\n    // Example: warning: Tag '@param' is not typically used on constant definitions\n  }\n}\n```\n\n**Coverage Metrics Example:**\n```typescript\nimport { extractDocs, calculateCoverage } from '@secondlayer/clarity-docs';\n\nconst docs = extractDocs(source);\nconst coverage = calculateCoverage(docs, abi);\n\nconsole.log(`Function coverage: ${coverage.functionCoverage.toFixed(1)}%`);\nconsole.log(`Map coverage: ${coverage.mapCoverage.toFixed(1)}%`);\nconsole.log(`Variable coverage: ${coverage.variableCoverage.toFixed(1)}%`);\nconsole.log(`Overall coverage: ${coverage.overallCoverage.toFixed(1)}%`);\n```\n\n**Stripping Docs for Deployment:**\n```typescript\nimport { stripDocs, estimateStrippingSavings } from '@secondlayer/clarity-docs';\n\n// Keep only @err tags for wallet integration\nconst minimal = stripDocs(source, { keepErrors: true });\n\n// Remove all documentation\nconst bare = stripDocs(source, { removeAll: true });\n\n// Keep @err and @desc\nconst balanced = stripDocs(source, { keepErrors: true, keepDesc: true });\n\n// Estimate byte savings\nconst savings = estimateStrippingSavings(source, { keepErrors: true });\nconsole.log(`Saved ${savings.savedBytes} bytes (${savings.savingsPercent.toFixed(1)}%)`);\n```\n\n**Repository:** https://github.com/ryanwaits/secondlayer\n\n### Future Implementations\n\n- **Clarinet integration**: `clarinet docs` command for generating documentation\n- **VS Code extension**: Hover information and documentation previews\n- **Documentation site generator**: Static site generation from ClarityDoc comments\n- **Wallet SDK**: Error message lookup utilities for transaction UX\n\n## Appendix A: Tag Quick Reference\n\n| Tag | Applies To | Has Argument | Description |\n|-----|-----------|--------------|-------------|\n| `@contract` | Contract | No | Contract name/title |\n| `@author` | Contract | No | Author information |\n| `@uri` | Contract | No | Off-chain documentation URL |\n| `@hash` | Contract | No | Documentation hash for integrity |\n| `@desc` | All | No | Human-readable description |\n| `@dev` | All | No | Developer notes |\n| `@param` | Functions | Yes (name) | Parameter description |\n| `@ok` | Functions | No | Success value description |\n| `@err` | Functions, Constants | Yes (code) | Error case description |\n| `@post` | Functions | Yes (asset) | Postcondition (asset transfer/mint) |\n| `@prints` | Functions | Yes (name) | Print statements triggered |\n| `@example` | Functions, Constants | No | Usage example |\n| `@key` | Maps | No | Map key description |\n| `@value` | Maps | No | Map value description |\n| `@version` | All | No | Version information |\n| `@deprecated` | All | No | Deprecation notice |\n| `@see` | All | No | Cross-reference |\n| `@custom:*` | All | No | Custom extension tags |\n\n## Appendix B: Validation Rules\n\nConforming tools SHOULD implement these validation rules:\n\n| Rule | Severity | Description |\n|------|----------|-------------|\n| V001 | Error | `@param` name does not match any function argument |\n| V002 | Warning | Function argument missing `@param` documentation |\n| V003 | Warning | Public/read-only function missing `@desc` |\n| V004 | Info | Public/read-only function missing `@ok` |\n| V005 | Info | Map missing `@key` or `@value` documentation |\n| V006 | Warning | `@deprecated` without replacement suggestion |\n| V007 | Warning | Tag used on incompatible definition type |\n\n## Appendix C: Tag Placement Matrix\n\nTags are validated based on definition context. Using a tag outside its valid context generates a warning:\n\n| Tag | Contract | Function | Constant | Variable | Map | Trait |\n|-----|:--------:|:--------:|:--------:|:--------:|:---:|:-----:|\n| `@contract` | âœ“ | | | | | |\n| `@author` | âœ“ | | | | | |\n| `@uri` | âœ“ | | | | | |\n| `@hash` | âœ“ | | | | | |\n| `@implements` | âœ“ | | | | | |\n| `@desc` | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ |\n| `@dev` | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ |\n| `@version` | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ |\n| `@deprecated` | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ |\n| `@see` | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ |\n| `@param` | | âœ“ | | | | |\n| `@ok` | | âœ“ | | | | |\n| `@err` | | âœ“ | âœ“ | | | |\n| `@post` | | âœ“ | | | | |\n| `@prints` | | âœ“ | | | | |\n| `@example` | | âœ“ | âœ“ | | | |\n| `@calls` | | âœ“ | | | | |\n| `@caller` | | âœ“ | | | | |\n| `@key` | | | | | âœ“ | |\n| `@value` | | | | | âœ“ | |\n| `@custom:*` | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ | âœ“ |\n\n## Appendix D: Off-Chain Documentation\n\nThe `@uri` and `@hash` tags support hybrid documentation strategies:\n\n### Use Cases\n\n1. **Localization**: Host translated documentation off-chain\n2. **Rich Media**: Link to diagrams, videos, or interactive examples\n3. **Cost Reduction**: Keep verbose docs off-chain to reduce deployment costs\n4. **Versioning**: Point to versioned documentation sites\n\n### Integrity Verification\n\nWhen `@hash` is provided, clients SHOULD verify fetched documentation:\n\n```typescript\n// Fetch and verify off-chain docs\nconst response = await fetch(contractDoc.header.uri);\nconst content = await response.text();\nconst hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(content));\nconst hashHex = 'sha256:' + Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');\n\nif (hashHex !== contractDoc.header.docsHash) {\n  console.warn('Documentation hash mismatch - content may have changed');\n}\n```\n\n## Appendix E: Error Constants for Wallet Integration\n\nError constants with `@err` enable wallets and explorers to display human-readable error messages:\n\n### Contract Definition\n\n```clarity\n;; @err Balance too low for transfer\n(define-constant ERR_BALANCE_TOO_LOW (err u67))\n\n;; @err Recipient address is invalid\n(define-constant ERR_INVALID_RECIPIENT (err u68))\n```\n\n### JSON Output\n\n```json\n{\n  \"constants\": [\n    {\n      \"name\": \"ERR_BALANCE_TOO_LOW\",\n      \"type\": \"constant\",\n      \"isError\": true,\n      \"errorDescription\": \"Balance too low for transfer\",\n      \"errorCode\": \"u67\"\n    },\n    {\n      \"name\": \"ERR_INVALID_RECIPIENT\",\n      \"type\": \"constant\",\n      \"isError\": true,\n      \"errorDescription\": \"Recipient address is invalid\",\n      \"errorCode\": \"u68\"\n    }\n  ]\n}\n```\n\n### Wallet Integration\n\n```typescript\n// Map error response to human-readable message\nfunction getErrorMessage(errorResponse: string, contractDocs: JsonContractDoc): string {\n  // Extract error code from \"(err u67)\" format\n  const match = errorResponse.match(/\\(err\\s+u(\\d+)\\)/);\n  if (!match) return errorResponse;\n\n  const errorCode = `u${match[1]}`;\n  const errorConstant = contractDocs.constants.find(\n    c => c.isError && c.errorCode === errorCode\n  );\n\n  return errorConstant?.errorDescription || errorResponse;\n}\n\n// Usage\nconst result = await callContract('transfer', args);\nif (result.error) {\n  const message = getErrorMessage(result.error, contractDocs);\n  showError(message); // \"Balance too low for transfer\" instead of \"(err u67)\"\n}\n```\n\n## Appendix F: Documentation Stripping\n\nFor cost-sensitive deployments, build tools can strip documentation before deployment.\n\n### Stripping Strategies\n\n| Strategy | Use Case | Keeps |\n|----------|----------|-------|\n| `removeAll` | Absolute minimum size | Nothing |\n| `keepErrors` | Wallet integration | `@err` tags only |\n| `keepDesc` + `keepErrors` | Basic docs + errors | `@desc` and `@err` |\n| `@uri` + `@hash` | Full docs off-chain | Reference only |\n\n### Reference Implementation\n\n```typescript\nimport { stripDocs, estimateStrippingSavings } from '@secondlayer/clarity-docs';\n\n// Original contract with full documentation\nconst source = `\n;; @contract Token Contract\n;; @author Alice\n;; @desc A fungible token with transfer limits\n;; @dev Implements SIP-010\n;; @uri https://docs.example.com/token\n;; @version 1.0.0\n\n;; @err Insufficient balance\n(define-constant ERR_INSUFFICIENT_BALANCE (err u1))\n\n;; @err Transfer amount exceeds limit\n(define-constant ERR_EXCEEDS_LIMIT (err u2))\n\n;; @desc Transfer tokens between accounts\n;; @param amount Number of tokens to transfer\n;; @param sender Source account\n;; @param recipient Destination account\n;; @ok True on successful transfer\n;; @err ERR_INSUFFICIENT_BALANCE When sender lacks funds\n;; @err ERR_EXCEEDS_LIMIT When amount exceeds daily limit\n;; @example (transfer u100 tx-sender 'SP123...)\n(define-public (transfer (amount uint) (sender principal) (recipient principal))\n  ...)\n`;\n\n// Strategy 1: Keep only error constants for wallet UX\nconst minimal = stripDocs(source, { keepErrors: true });\n// Result: Only ;; @err lines remain\n\n// Strategy 2: Remove everything\nconst bare = stripDocs(source, { removeAll: true });\n// Result: No ;; comments remain\n\n// Strategy 3: Keep errors and descriptions\nconst balanced = stripDocs(source, { keepErrors: true, keepDesc: true });\n// Result: @err and @desc lines remain\n\n// Estimate savings\nconst savings = estimateStrippingSavings(source, { keepErrors: true });\nconsole.log(`Saved ${savings.savedBytes} bytes (${savings.savingsPercent.toFixed(1)}%)`);\n```\n\n### Recommended Workflow\n\n1. **Development**: Full documentation with all tags\n2. **Testnet**: Full documentation (cost is minimal)\n3. **Mainnet**: Strip to `keepErrors: true` or use `@uri` for off-chain docs\n\n### Clarinet Integration (Future)\n\n```toml\n# Clarinet.toml\n[deployment.mainnet]\nstrip_docs = true\nkeep_error_docs = true\n```\n\n```bash\n# Command line\nclarinet deploy --strip-docs --keep-errors\n```\n\n## Appendix G: Clarity 4 Asset Restrictions\n\nClarity 4 introduces built-in functions for programmatic asset restrictions that complement ClarityDoc's `@post` tag:\n\n### New Functions\n\n| Function | Purpose |\n|----------|---------|\n| `restrict-assets?` | Wrap expressions with asset outflow limits |\n| `as-contract?` | Execute as contract with asset allowances |\n| `with-stx` | Allow STX outflow up to amount |\n| `with-ft` | Allow FT outflow up to amount |\n| `with-nft` | Allow specific NFT outflow |\n| `with-stacking` | Allow stacking up to amount |\n\n### Relationship to `@post`\n\nThe `@post` tag documents *expected* asset movements for human readers and wallets. Clarity 4's `restrict-assets?` *enforces* limits programmatically:\n\n```clarity\n;; @desc Swap tokens for STX\n;; @param amount Tokens to sell\n;; @post token Transfers `amount` tokens to contract\n;; @post stx Receives STX from contract (amount varies by rate)\n;; @ok STX amount received\n(define-public (swap (amount uint))\n  (restrict-assets? tx-sender\n    ((with-ft .token \"my-token\" amount))  ;; Enforce: max `amount` tokens leave\n    (let ((stx-out (calculate-stx-out amount)))\n      (try! (ft-transfer? my-token amount tx-sender (as-contract tx-sender)))\n      (try! (as-contract? ((with-stx stx-out))\n        (stx-transfer? stx-out tx-sender tx-sender)))\n      (ok stx-out))))\n```\n\n### Best Practice\n\n- Use `@post` to document intent for humans/wallets\n- Use `restrict-assets?` to enforce limits in code\n- Both should alignâ€”if `@post` says \"max 100 STX\", code should enforce it",
    "packages/clarity-docs/tsconfig.json": "{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}",
    "packages/clarity-docs/vitest.config.ts": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: \"node\",\n  },\n});",
    "packages/clarity-types/src/types/composites.ts": "import type { ClarityPrimitiveType } from \"./primitives\";\n\n/**\n * Clarity composite types\n */\n\n// Use interface for recursive type definition\nexport interface ClarityListType {\n  list: {\n    type: ClarityType;\n    length: number;\n  };\n}\n\nexport interface ClarityTupleType {\n  tuple: ReadonlyArray<{\n    name: string;\n    type: ClarityType;\n  }>;\n}\n\nexport interface ClarityOptionalType {\n  optional: ClarityType;\n}\n\nexport interface ClarityResponseType {\n  response: {\n    ok: ClarityType;\n    error: ClarityType;\n  };\n}\n\nexport type ClarityType =\n  | ClarityPrimitiveType\n  | ClarityListType\n  | ClarityTupleType\n  | ClarityOptionalType\n  | ClarityResponseType;\n\n// Generic versions for better type inference\nexport type ClarityList<\n  T extends ClarityType = ClarityType,\n  L extends number = number\n> = {\n  list: {\n    type: T;\n    length: L;\n  };\n};\n\nexport type ClarityTuple<\n  T extends ReadonlyArray<{ name: string; type: ClarityType }>\n> = {\n  tuple: T;\n};\n\nexport type ClarityOptional<T extends ClarityType = ClarityType> = {\n  optional: T;\n};\n\nexport type ClarityResponse<\n  O extends ClarityType = ClarityType,\n  E extends ClarityType = ClarityType\n> = {\n  response: {\n    ok: O;\n    error: E;\n  };\n};",
    "packages/clarity-types/tests/camelcase-conversion.test.ts": "import { describe, it } from \"vitest\";\nimport { expectTypeOf } from \"vitest\";\nimport type { ClarityToTS } from \"../src/types/mappings\";\nimport type { ClarityContract, ExtractFunctionArgs } from \"../src\";\n\ndescribe(\"CamelCase conversion for hyphenated names\", () => {\n  it(\"should convert hyphenated tuple field names to camelCase\", () => {\n    type PriceFunctionTuple = ClarityToTS<{\n      tuple: [\n        { name: \"base\"; type: \"uint128\" },\n        { name: \"buckets\"; type: { list: { type: \"uint128\"; length: 16 } } },\n        { name: \"coeff\"; type: \"uint128\" },\n        { name: \"no-vowel-discount\"; type: \"uint128\" },\n        { name: \"nonalpha-discount\"; type: \"uint128\" }\n      ];\n    }>;\n\n    // Should convert hyphenated names to camelCase\n    expectTypeOf<PriceFunctionTuple>().toEqualTypeOf<{\n      base: bigint;\n      buckets: bigint[];\n      coeff: bigint;\n      noVowelDiscount: bigint; // no-vowel-discount -> noVowelDiscount\n      nonalphaDiscount: bigint; // nonalpha-discount -> nonalphaDiscount\n    }>();\n  });\n\n  it(\"should convert hyphenated function argument names to camelCase\", () => {\n    const contractAbi = {\n      functions: [\n        {\n          name: \"test-function\",\n          access: \"public\" as const,\n          args: [\n            { name: \"user-id\", type: \"uint128\" as const },\n            { name: \"asset-contract\", type: \"trait_reference\" as const },\n            { name: \"no-vowel-discount\", type: \"uint128\" as const },\n            { name: \"multi-word-arg\", type: \"bool\" as const },\n          ],\n          outputs: {\n            response: { ok: \"bool\" as const, error: \"uint128\" as const },\n          } as const,\n        },\n      ],\n    } as const satisfies ClarityContract;\n\n    type Args = ExtractFunctionArgs<typeof contractAbi, \"test-function\">;\n\n    // Should convert hyphenated argument names to camelCase\n    expectTypeOf<Args>().toEqualTypeOf<{\n      userId: bigint; // user-id -> userId\n      assetContract: string; // asset-contract -> assetContract\n      noVowelDiscount: bigint; // no-vowel-discount -> noVowelDiscount\n      multiWordArg: boolean; // multi-word-arg -> multiWordArg\n    }>();\n  });\n\n  it(\"should handle nested tuples with hyphenated names\", () => {\n    type ComplexType = ClarityToTS<{\n      tuple: [\n        { name: \"simple-field\"; type: \"uint128\" },\n        {\n          name: \"nested-data\";\n          type: {\n            tuple: [\n              { name: \"inner-value\"; type: \"bool\" },\n              { name: \"another-field\"; type: \"principal\" }\n            ];\n          };\n        }\n      ];\n    }>;\n\n    expectTypeOf<ComplexType>().toEqualTypeOf<{\n      simpleField: bigint; // simple-field -> simpleField\n      nestedData: {\n        // nested-data -> nestedData\n        innerValue: boolean; // inner-value -> innerValue\n        anotherField: string; // another-field -> anotherField\n      };\n    }>();\n  });\n\n  it(\"should preserve non-hyphenated names unchanged\", () => {\n    type MixedTuple = ClarityToTS<{\n      tuple: [\n        { name: \"normal\"; type: \"uint128\" },\n        { name: \"camelCase\"; type: \"bool\" },\n        { name: \"with-hyphens\"; type: \"principal\" },\n        { name: \"PascalCase\"; type: \"uint128\" }\n      ];\n    }>;\n\n    expectTypeOf<MixedTuple>().toEqualTypeOf<{\n      normal: bigint; // unchanged\n      camelCase: boolean; // unchanged\n      withHyphens: string; // with-hyphens -> withHyphens\n      PascalCase: bigint; // unchanged\n    }>();\n  });\n});",
    "packages/clarity-types/tests/trait-reference.test.ts": "import { describe, it, expect } from \"vitest\";\nimport { jsToClarity } from \"../src/converters\";\nimport type { ClarityToTS } from \"../src/types/mappings\";\nimport type { ClarityContract, ExtractFunctionArgs } from \"../src\";\n\ndescribe(\"trait_reference support\", () => {\n  it(\"should handle trait_reference type correctly in type system\", () => {\n    // Test the type mapping\n    type TraitRefType = ClarityToTS<\"trait_reference\">;\n    const value: TraitRefType =\n      \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.my-trait\";\n    expect(typeof value).toBe(\"string\");\n  });\n\n  it(\"should validate trait_reference values in jsToClarity\", () => {\n    const validContractPrincipal =\n      \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.my-trait\";\n    const validStandardPrincipal = \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9\";\n\n    expect(() =>\n      jsToClarity(\"trait_reference\", validContractPrincipal)\n    ).not.toThrow();\n    expect(() =>\n      jsToClarity(\"trait_reference\", validStandardPrincipal)\n    ).not.toThrow();\n\n    expect(() => jsToClarity(\"trait_reference\", \"invalid-principal\")).toThrow();\n    expect(() => jsToClarity(\"trait_reference\", 123)).toThrow();\n  });\n\n  it(\"should work with contract ABI extraction\", () => {\n    const contractAbi = {\n      functions: [\n        {\n          name: \"get-balance-of\",\n          access: \"public\" as const,\n          args: [{ name: \"assetContract\", type: \"trait_reference\" as const }],\n          outputs: {\n            response: {\n              ok: \"uint128\" as const,\n              error: \"uint128\" as const,\n            },\n          } as const,\n        },\n      ],\n    } as const satisfies ClarityContract;\n\n    type Args = ExtractFunctionArgs<typeof contractAbi, \"get-balance-of\">;\n\n    // This should infer { assetContract: string }\n    const args: Args = {\n      assetContract: \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.my-token\",\n    };\n\n    expect(typeof args.assetContract).toBe(\"string\");\n  });\n});",
    "packages/clarity-types/bunup.config.ts": "import { defineConfig } from \"bunup\";\n\nexport default defineConfig({\n  entry: [\"src/index.ts\"],\n  format: [\"esm\"],\n  dts: true,\n  splitting: false,\n  sourcemap: \"linked\",\n  minify: false,\n});",
    "packages/clarity-types/gpt-5.1-codex-max-high-clarity-types-audit.md": "# Clarity Types Audit (gpt-5.1-codex-max-high)\n\nScope: @secondlayer/clarity-types package. Focus: fragile, hardcoded, regex-like solutions that should lean on existing tooling for scalable and robust Clarity type coverage.\n\n## Findings\n\n1) Principal validation is regex-based and bypasses the canonical address/parsing utilities.\n- Evidence: Regex constants and guards rely on `/^S[0-9A-Z]{39,40}/` variants and `test()` calls (`packages/clarity-types/src/types/primitives.ts`, `packages/clarity-types/src/validation/guards.ts`).\n- Risks: No c32 checksum verification; network prefixes beyond `S` are not enforced; contract IDs arenâ€™t parsed; malformed principals can slip through or valid testnet forms could be rejected under edge cases.\n- Recommendation: Replace regex validation with Stacks JS primitives: `@stacks/transactions` (`validateStacksAddress`, `principalCV`, `contractPrincipalCV`, `parsePrincipalString`) which already perform c32check decoding and contract-name validation. This avoids maintaining home-grown regex and stays aligned with protocol rules.\n\n2) Runtime conversion only validates primitives; composite Clarity types are left unvalidated.\n- Evidence: `jsToClarity` handles a few primitives and buffers/strings, then returns values for lists/tuples/optionals/responses without checks (`packages/clarity-types/src/converters/index.ts`, TODO at the composite branch).\n- Risks: Nested structures, list length limits, tuple field shapes, optional/response envelopes, and nested principals are not validated. Downstream code may send malformed arguments while appearing â€œvalidatedâ€.\n- Recommendation: Drive conversion off official Clarity value constructors from `@stacks/transactions` (`uintCV`, `intCV`, `boolCV`, `bufferCV`, `stringAsciiCV`, `stringUtf8CV`, `listCV`, `tupleCV`, `optionalCV`, `responseOkCV/responseErrorCV`). These enforce length/shape and will fail fast. Use ABI metadata to recurse through types instead of manual branching.\n\n3) String/buffer validation is minimal and home-built.\n- Evidence: ASCII strings only check JS type and length, not character set; UTF-8 uses `TextEncoder` length only; buffers allow any `Uint8Array` up to max length (`packages/clarity-types/src/converters/index.ts`).\n- Risks: Non-ASCII characters pass for `string-ascii`; buffer sizing/encoding rules rely on ad-hoc checks; behavior may drift from Clarityâ€™s exact constraints.\n- Recommendation: Delegate to `stringAsciiCV` / `stringUtf8CV` / `bufferCV` in `@stacks/transactions` so encoding and length constraints match the VM. If staying local, add explicit ASCII byte validation and enforce exact/expected lengths from ABI.\n\n4) ABI shape/types are redefined manually and omit parts of the canonical schema.\n- Evidence: Custom `ClarityContract`, `ClarityFunction`, and `ClarityType` definitions (`packages/clarity-types/src/abi/functions.ts`, `packages/clarity-types/src/types/composites.ts`) exclude newer ABI fields (token definitions, fungible/non-fungible tokens, maps metadata, traits) present in `@stacks/transactions`â€™ `ClarityAbi` types.\n- Risks: Drift from upstream ABI spec; generated ABIs from `@stacks/cli` may not type-check or be fully covered; downstream tooling cannot rely on parity with Stacksâ€™ standard library.\n- Recommendation: Import and reuse the official `ClarityAbi`, `ClarityAbiFunction`, and `ClarityAbiType*` types from `@stacks/transactions` instead of duplicating. This removes manual maintenance and ensures forward compatibility when the ABI evolves.\n\n5) List/collection guards ignore ABI length constraints.\n- Evidence: `isArray` only checks every element against a guard and never enforces declared list length; composite validation is TODO (`packages/clarity-types/src/validation/guards.ts`, `packages/clarity-types/src/converters/index.ts`).\n- Risks: Calls can send lists longer than ABI limits and still be considered â€œvalidated.â€\n- Recommendation: When adopting ABI-driven recursion, include list length enforcement (exact or max per Clarity spec). The `listCV` helper already enforces lengths when given the intended size.\n\n## Suggested next steps\n- Swap regex/address checks for Stacks JS address/principal utilities to gain checksum and contract-name validation for free.\n- Refactor `jsToClarity` into an ABI-driven recursive converter that builds Clarity Values via `@stacks/transactions`, covering lists/tuples/optionals/responses and enforcing lengths/encodings.\n- Replace bespoke ABI/type definitions with the upstream `ClarityAbi*` types to avoid drift and improve coverage for tokens/maps/traits.\n- Augment tests to cover the above (invalid principals that fail checksum, over-length lists/buffers, non-ASCII strings, malformed tuples) to lock in the stronger behavior.",
    "packages/clarity-types/tsconfig.json": "{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}",
    "packages/clarity-types/vitest.config.ts": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: \"node\",\n  },\n});",
    "packages/cli/src/generated/stacks-api.ts": "/**\n * Stacks API utility functions\n * Implements missing API functions using Stacks blockchain endpoints\n * DO NOT EDIT MANUALLY\n */\n\nexport interface StacksNetwork {\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}\n\n/**\n * Get the API base URL for the given network\n */\nfunction getApiUrl(network: StacksNetwork): string {\n  if (network.apiUrl) {\n    return network.apiUrl\n  }\n\n  switch (network.network) {\n    case 'mainnet':\n      return 'https://api.hiro.so'\n    case 'testnet':\n      return 'https://api.testnet.hiro.so'\n    case 'devnet':\n      return 'http://localhost:3999'\n    default:\n      return 'https://api.testnet.hiro.so'\n  }\n}\n\n/**\n * Get the RPC API base URL for the given network\n */\nfunction getRpcApiUrl(network: StacksNetwork): string {\n  switch (network.network) {\n    case 'mainnet':\n      return 'https://stacks-node-api.mainnet.stacks.co'\n    case 'testnet':\n      return 'https://stacks-node-api.testnet.stacks.co'\n    case 'devnet':\n      return 'http://localhost:20443'\n    default:\n      return 'https://stacks-node-api.testnet.stacks.co'\n  }\n}\n\n/**\n * Fetch account information\n */\nexport async function fetchAccountInfo({\n  address,\n  network,\n  apiUrl,\n}: {\n  address: string\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const rpcUrl = getRpcApiUrl(networkConfig)\n\n  try {\n    // Try RPC API first (more decentralized)\n    const response = await fetch(`${rpcUrl}/v2/accounts/${address}`)\n    if (!response.ok) {\n      throw new Error(`RPC API failed: ${response.status}`)\n    }\n    return await response.json()\n  } catch (error) {\n    // Fallback to Hiro API\n    const apiUrlFallback = getApiUrl(networkConfig)\n    const response = await fetch(`${apiUrlFallback}/extended/v1/address/${address}/balances`)\n    if (!response.ok) {\n      throw new Error(`Failed to fetch account info: ${response.status}`)\n    }\n    return await response.json()\n  }\n}\n\n/**\n * Fetch transaction information\n */\nexport async function fetchTransaction({\n  txId,\n  network,\n  apiUrl,\n}: {\n  txId: string\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const apiUrlResolved = getApiUrl(networkConfig)\n\n  const response = await fetch(`${apiUrlResolved}/extended/v1/tx/${txId}`)\n  if (!response.ok) {\n    throw new Error(`Failed to fetch transaction: ${response.status}`)\n  }\n  return await response.json()\n}\n\n/**\n * Fetch block information\n */\nexport async function fetchBlock({\n  height,\n  network,\n  apiUrl,\n}: {\n  height: number\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const apiUrlResolved = getApiUrl(networkConfig)\n\n  const response = await fetch(`${apiUrlResolved}/extended/v1/block/by_height/${height}`)\n  if (!response.ok) {\n    throw new Error(`Failed to fetch block: ${response.status}`)\n  }\n  return await response.json()\n}\n\n/**\n * Fetch account transactions\n */\nexport async function fetchAccountTransactions({\n  address,\n  network,\n  apiUrl,\n  limit = 50,\n  offset = 0,\n}: {\n  address: string\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n  limit?: number\n  offset?: number\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const apiUrlResolved = getApiUrl(networkConfig)\n\n  const response = await fetch(\n    `${apiUrlResolved}/extended/v1/address/${address}/transactions?limit=${limit}&offset=${offset}`\n  )\n  if (!response.ok) {\n    throw new Error(`Failed to fetch account transactions: ${response.status}`)\n  }\n  return await response.json()\n}",
    "packages/cli/src/generators/stacks-api.ts": "/**\n * Stacks API utility functions\n * Implements missing API functions using Stacks blockchain endpoints\n */\n\nexport interface StacksNetwork {\n  network: \"mainnet\" | \"testnet\" | \"devnet\";\n  apiUrl?: string;\n}\n\n/**\n * Get the API base URL for the given network\n */\nfunction getApiUrl(network: StacksNetwork): string {\n  if (network.apiUrl) {\n    return network.apiUrl;\n  }\n\n  switch (network.network) {\n    case \"mainnet\":\n      return \"https://api.hiro.so\";\n    case \"testnet\":\n      return \"https://api.testnet.hiro.so\";\n    case \"devnet\":\n      return \"http://localhost:3999\";\n    default:\n      return \"https://api.testnet.hiro.so\";\n  }\n}\n\n/**\n * Get the RPC API base URL for the given network\n */\nfunction getRpcApiUrl(network: StacksNetwork): string {\n  switch (network.network) {\n    case \"mainnet\":\n      return \"https://stacks-node-api.mainnet.stacks.co\";\n    case \"testnet\":\n      return \"https://stacks-node-api.testnet.stacks.co\";\n    case \"devnet\":\n      return \"http://localhost:20443\";\n    default:\n      return \"https://stacks-node-api.testnet.stacks.co\";\n  }\n}\n\n/**\n * Fetch account information\n */\nexport async function fetchAccountInfo({\n  address,\n  network,\n  apiUrl,\n}: {\n  address: string;\n  network: \"mainnet\" | \"testnet\" | \"devnet\";\n  apiUrl?: string;\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl };\n  const rpcUrl = getRpcApiUrl(networkConfig);\n\n  try {\n    // Try RPC API first (more decentralized)\n    const response = await fetch(`${rpcUrl}/v2/accounts/${address}`);\n    if (!response.ok) {\n      throw new Error(`RPC API failed: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    // Fallback to Hiro API\n    const apiUrlFallback = getApiUrl(networkConfig);\n    const response = await fetch(\n      `${apiUrlFallback}/extended/v1/address/${address}/balances`\n    );\n    if (!response.ok) {\n      throw new Error(`Failed to fetch account info: ${response.status}`);\n    }\n    return await response.json();\n  }\n}\n\n/**\n * Fetch transaction information\n */\nexport async function fetchTransaction({\n  txId,\n  network,\n  apiUrl,\n}: {\n  txId: string;\n  network: \"mainnet\" | \"testnet\" | \"devnet\";\n  apiUrl?: string;\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl };\n  const apiUrlResolved = getApiUrl(networkConfig);\n\n  const response = await fetch(`${apiUrlResolved}/extended/v1/tx/${txId}`);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch transaction: ${response.status}`);\n  }\n  return await response.json();\n}\n\n/**\n * Fetch block information\n */\nexport async function fetchBlock({\n  height,\n  network,\n  apiUrl,\n}: {\n  height: number;\n  network: \"mainnet\" | \"testnet\" | \"devnet\";\n  apiUrl?: string;\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl };\n  const apiUrlResolved = getApiUrl(networkConfig);\n\n  const response = await fetch(\n    `${apiUrlResolved}/extended/v1/block/by_height/${height}`\n  );\n  if (!response.ok) {\n    throw new Error(`Failed to fetch block: ${response.status}`);\n  }\n  return await response.json();\n}\n\n/**\n * Fetch account transactions\n */\nexport async function fetchAccountTransactions({\n  address,\n  network,\n  apiUrl,\n  limit = 50,\n  offset = 0,\n}: {\n  address: string;\n  network: \"mainnet\" | \"testnet\" | \"devnet\";\n  apiUrl?: string;\n  limit?: number;\n  offset?: number;\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl };\n  const apiUrlResolved = getApiUrl(networkConfig);\n\n  const response = await fetch(\n    `${apiUrlResolved}/extended/v1/address/${address}/transactions?limit=${limit}&offset=${offset}`\n  );\n  if (!response.ok) {\n    throw new Error(`Failed to fetch account transactions: ${response.status}`);\n  }\n  return await response.json();\n}",
    "packages/cli/src/plugins/react/index.ts": "/**\n * React Plugin for @secondlayer/cli\n * Generates React hooks for contract interfaces and generic Stacks functionality\n */\n\nimport type { PluginFactory, GenerateContext } from \"../../types/plugin\";\nimport type { ReactPluginOptions } from \"./types\";\nimport { generateProvider } from \"./provider/index\";\nimport { generateGenericHooks } from \"./generators/generic\";\nimport { generateContractHooks } from \"./generators/contract\";\n\n/**\n * React plugin factory\n */\nexport const react: PluginFactory<ReactPluginOptions> = (options = {}) => {\n  const excludeList = options.exclude || [];\n\n  return {\n    name: \"@secondlayer/cli/plugin-react\",\n    version: \"1.0.0\",\n\n    async generate(context: GenerateContext): Promise<void> {\n      if (options.debug) {\n        context.logger.debug(\n          `React plugin generating hooks (excluding: ${excludeList.join(\", \") || \"none\"})`\n        );\n      }\n\n      // Generate provider (always generated)\n      const provider = await generateProvider();\n      context.addOutput(\"provider\", {\n        path: \"./src/generated/provider.tsx\",\n        content: provider,\n        type: \"config\",\n      });\n\n      // Generate generic hooks (all by default, minus excludes)\n      const genericHooks = await generateGenericHooks(excludeList);\n      context.addOutput(\"generic-hooks\", {\n        path: \"./src/generated/hooks.ts\",\n        content: genericHooks,\n        type: \"hooks\",\n      });\n\n      // Generate contract hooks (all contracts, minus excludes)\n      if (context.contracts.length > 0) {\n        const contractHooks = await generateContractHooks(\n          context.contracts,\n          excludeList\n        );\n\n        // Only add output if there are hooks to generate\n        if (contractHooks.trim()) {\n          context.addOutput(\"contract-hooks\", {\n            path: \"./src/generated/contract-hooks.ts\",\n            content: contractHooks,\n            type: \"hooks\",\n          });\n        }\n      }\n\n      if (options.debug) {\n        context.logger.success(\n          `React plugin generated ${context.contracts.length} contract hook sets`\n        );\n      }\n    },\n  };\n};\n\n// Re-export types for convenience\nexport type { ReactPluginOptions } from \"./types\";",
    "packages/cli/src/plugins/testing/index.ts": "/**\n * Testing plugin for @secondlayer/cli\n * Generates type-safe helpers for Clarinet SDK unit tests\n */\n\nimport type { PluginFactory, GenerateContext } from \"../../types/plugin\";\nimport { generateTestingHelpers } from \"./generators\";\n\nexport interface TestingPluginOptions {\n  /** Include only specific contracts */\n  include?: string[];\n\n  /** Exclude specific contracts */\n  exclude?: string[];\n\n  /** Output path for generated testing helpers (default: ./src/generated/testing.ts) */\n  out?: string;\n\n  /** Include private function helpers (default: false) */\n  includePrivate?: boolean;\n\n  /** Enable debug output */\n  debug?: boolean;\n}\n\nexport const testing: PluginFactory<TestingPluginOptions> = (options = {}) => {\n  return {\n    name: \"@secondlayer/cli/plugin-testing\",\n    version: \"1.0.0\",\n\n    async generate(context: GenerateContext): Promise<void> {\n      const { contracts } = context;\n\n      // Filter contracts based on options\n      const filteredContracts = contracts.filter((contract) => {\n        if (options.include && !options.include.includes(contract.name)) {\n          return false;\n        }\n        if (options.exclude && options.exclude.includes(contract.name)) {\n          return false;\n        }\n        return true;\n      });\n\n      if (filteredContracts.length === 0) {\n        if (options.debug) {\n          context.logger.debug(\"Testing plugin: No contracts to process\");\n        }\n        return;\n      }\n\n      if (options.debug) {\n        context.logger.debug(\n          `Testing plugin: Generating helpers for ${filteredContracts.length} contracts`\n        );\n      }\n\n      // Generate testing helpers\n      const testingCode = await generateTestingHelpers(\n        filteredContracts,\n        options\n      );\n\n      const outputPath = options.out || \"./src/generated/testing.ts\";\n\n      context.addOutput(\"testing\", {\n        path: outputPath,\n        content: testingCode,\n        type: \"utils\",\n      });\n\n      if (options.debug) {\n        context.logger.debug(\n          `Testing plugin: Generated helpers for ${filteredContracts.length} contracts`\n        );\n      }\n    },\n  };\n};",
    "packages/cli/tests/fixtures/counter.clar": ";; Counter Contract\n\n(define-data-var counter uint u0)\n\n(define-public (increment)\n  (begin\n    (var-set counter (+ (var-get counter) u1))\n    (ok (var-get counter))\n  )\n)\n\n(define-public (decrement)\n  (begin\n    (var-set counter (- (var-get counter) u1))\n    (ok (var-get counter))\n  )\n)\n\n(define-read-only (get-counter)\n  (ok (var-get counter))\n)",
    "packages/cli/tests/fixtures/simple-token.clar": ";; Simple Token Contract\n\n(define-public (transfer (amount uint) (sender principal) (recipient principal))\n  (ok true)\n)\n\n(define-read-only (get-balance (account principal))\n  (ok u0)\n)\n\n(define-read-only (get-name)\n  (ok \"Simple Token\")\n)",
    "packages/cli/biome.json": "{\n\t\"$schema\": \"https://biomejs.dev/schemas/1.9.0/schema.json\",\n\t\"formatter\": {\n\t\t\"enabled\": true,\n\t\t\"indentStyle\": \"tab\",\n\t\t\"lineWidth\": 80\n\t},\n\t\"javascript\": {\n\t\t\"formatter\": {\n\t\t\t\"semicolons\": \"always\",\n\t\t\t\"quoteStyle\": \"single\"\n\t\t}\n\t},\n\t\"organizeImports\": {\n\t\t\"enabled\": true\n\t}\n}",
    "packages/cli/tsconfig.json": "{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}",
    "LICENSE": "MIT License\n\nCopyright (c) 2025 Ryan Waits\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the â€œSoftwareâ€), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.",
    "packages/clarity-docs/CHANGELOG.md": "# @secondlayer/clarity-docs\n\n## 0.2.1\n\n### Patch Changes\n\n- fix clarity-types dependency to use explicit version\n\n## 0.2.0\n\n### Minor Changes\n\n- Add clarity-docs package for parsing and generating Clarity documentation",
    "packages/clarity-types/src/integration/connect.ts": "import type { ClarityContract } from \"../abi/functions\";\nimport type {\n  ExtractFunctionArgs,\n  ExtractPublicFunctions,\n  ExtractReadOnlyFunctions,\n} from \"../abi/extractors\";\n\n/**\n * Integration types for @stacks/connect\n *\n * Note: The actual contract interface implementations are generated by the CLI tool.\n * This module only exports type definitions for type-safe contract interactions.\n */\n\n/**\n * Type that matches @stacks/connect contract call options\n */\nexport interface ContractCallParams {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ReadonlyArray<unknown>;\n}\n\n/**\n * Type for read-only function calls\n */\nexport interface ReadOnlyCallParams {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ReadonlyArray<unknown>;\n}\n\n/**\n * Type-safe contract interface type.\n * Maps public functions to ContractCallParams and read-only functions to ReadOnlyCallParams.\n */\nexport type ContractInterface<C extends ClarityContract> = {\n  // Public functions return ContractCallParams\n  [K in ExtractPublicFunctions<C>]: {\n    (args: ExtractFunctionArgs<C, K>): ContractCallParams;\n    (...args: unknown[]): ContractCallParams;\n  };\n} & {\n  // Read-only functions return ReadOnlyCallParams\n  [K in ExtractReadOnlyFunctions<C>]: {\n    (args: ExtractFunctionArgs<C, K>): ReadOnlyCallParams;\n    (...args: unknown[]): ReadOnlyCallParams;\n  };\n};\n\n/**\n * Contract interface with metadata (address and name).\n */\nexport type ContractInterfaceWithMeta<C extends ClarityContract> =\n  ContractInterface<C> & {\n    contractAddress: string;\n    contractName: string;\n  };",
    "packages/clarity-types/src/types/mappings.ts": "import type { ClarityType } from \"./composites\";\nimport type { ToCamelCase } from \"../utils\";\n\n/**\n * Type mapping from Clarity types to TypeScript types\n */\n\ntype TupleToObject<\n  T extends ReadonlyArray<{ name: string; type: ClarityType }>\n> = {\n  [K in T[number][\"name\"] as ToCamelCase<K>]: ClarityToTS<\n    Extract<T[number], { name: K }>[\"type\"]\n  >;\n};\n\nexport type ClarityToTS<T extends ClarityType> = T extends \"uint128\"\n  ? bigint\n  : T extends \"int128\"\n  ? bigint\n  : T extends \"bool\"\n  ? boolean\n  : T extends \"principal\"\n  ? string\n  : T extends \"trait_reference\"\n  ? string\n  : T extends { \"string-ascii\": any }\n  ? string\n  : T extends { \"string-utf8\": any }\n  ? string\n  : T extends { buff: any }\n  ? Uint8Array\n  : T extends { list: { type: infer U extends ClarityType } }\n  ? Array<ClarityToTS<U>>\n  : T extends { optional: infer U extends ClarityType }\n  ? ClarityToTS<U> | null\n  : T extends {\n      response: {\n        ok: infer O extends ClarityType;\n        error: infer E extends ClarityType;\n      };\n    }\n  ? { ok: ClarityToTS<O> } | { err: ClarityToTS<E> }\n  : T extends {\n      tuple: infer Fields extends ReadonlyArray<{\n        name: string;\n        type: ClarityType;\n      }>;\n    }\n  ? TupleToObject<Fields>\n  : never;\n\nexport type ResponseOk<T> = { ok: T };\nexport type ResponseErr<E> = { err: E };\nexport type Response<T, E> = ResponseOk<T> | ResponseErr<E>;",
    "packages/clarity-types/src/types/primitives.ts": "/**\n * Clarity primitive types\n */\n\nexport type ClarityUInt128 = \"uint128\";\nexport type ClarityInt128 = \"int128\";\n\nexport type ClarityBool = \"bool\";\n\nexport type ClarityPrincipal = \"principal\";\n\nexport type ClarityTraitReference = \"trait_reference\";\n\nexport type ClarityStringAscii<L extends number = number> = {\n  \"string-ascii\": {\n    length: L;\n  };\n};\n\nexport type ClarityStringUtf8<L extends number = number> = {\n  \"string-utf8\": {\n    length: L;\n  };\n};\n\nexport type ClarityBuffer<L extends number = number> = {\n  buff: {\n    length: L;\n  };\n};\n\nexport type ClarityPrimitiveType =\n  | ClarityUInt128\n  | ClarityInt128\n  | ClarityBool\n  | ClarityPrincipal\n  | ClarityTraitReference\n  | ClarityStringAscii\n  | ClarityStringUtf8\n  | ClarityBuffer;\n\nexport const MAX_U128 = 2n ** 128n - 1n;\nexport const MAX_I128 = 2n ** 127n - 1n;\nexport const MIN_I128 = -(2n ** 127n);\n\n// Contract name validation regex (used after address validation)\nexport const CONTRACT_NAME_REGEX = /^[a-zA-Z][a-zA-Z0-9\\-]{0,127}$/;",
    "packages/clarity-types/src/utils/index.ts": "/**\n * Shared utilities for clarity-types\n */\n\n/**\n * Type-level utility to convert kebab-case to camelCase\n */\nexport type ToCamelCase<S extends string> =\n  S extends `${infer P1}-${infer P2}${infer P3}`\n    ? `${P1}${Capitalize<ToCamelCase<`${P2}${P3}`>>}`\n    : S;\n\n/**\n * Runtime utility to convert kebab-case to camelCase\n *\n * Handles all edge cases:\n * - `-a` â†’ `A` (lowercase after hyphen becomes uppercase)\n * - `-A` â†’ `A` (uppercase after hyphen stays uppercase, hyphen removed)\n * - `-1` â†’ `1` (digit after hyphen stays as-is, hyphen removed)\n * - Leading digits are prefixed with `_` (e.g., `1foo` â†’ `_1foo`)\n * - Any remaining hyphens are removed\n */\nexport function toCamelCase(str: string): string {\n  return str\n    .replace(/-([a-z])/g, (_, letter) => letter.toUpperCase()) // Convert -a to A\n    .replace(/-([A-Z])/g, (_, letter) => letter) // Convert -A to A\n    .replace(/-(\\d)/g, (_, digit) => digit) // Convert -1 to 1\n    .replace(/-/g, \"\") // Remove any remaining hyphens\n    .replace(/^\\d/, \"_$&\"); // Prefix leading digits with _\n}",
    "packages/clarity-types/tests/types.test.ts": "import { describe, it, expectTypeOf } from \"vitest\";\nimport type {\n  ClarityToTS,\n  ClarityContract,\n  ExtractFunctionNames,\n  ExtractFunctionArgs,\n  ExtractFunctionOutput,\n  ContractInterface,\n  ExtractMapNames,\n  ExtractMapKey,\n  ExtractMapValue,\n  ExtractVariableNames,\n  ExtractVariableType,\n  ExtractConstants,\n  ExtractDataVars,\n  ExtractFungibleTokenNames,\n  ExtractNonFungibleTokenNames,\n  ExtractNFTAssetType,\n  ExtractDefinedTraitNames,\n  ExtractImplementedTraits,\n  ExtractPrivateFunctions,\n} from \"../src\";\n\n/**\n * Type-level tests for clarity-types\n */\n\ndescribe(\"Type Inference\", () => {\n  it(\"should infer primitive types correctly\", () => {\n    // Numeric types\n    type TestUint = ClarityToTS<\"uint128\">;\n    expectTypeOf<TestUint>().toEqualTypeOf<bigint>();\n\n    type TestInt = ClarityToTS<\"int128\">;\n    expectTypeOf<TestInt>().toEqualTypeOf<bigint>();\n\n    // Boolean\n    type TestBool = ClarityToTS<\"bool\">;\n    expectTypeOf<TestBool>().toEqualTypeOf<boolean>();\n\n    // Principal\n    type TestPrincipal = ClarityToTS<\"principal\">;\n    expectTypeOf<TestPrincipal>().toEqualTypeOf<string>();\n  });\n\n  it(\"should infer string types correctly\", () => {\n    type TestAscii = ClarityToTS<{ \"string-ascii\": { length: 50 } }>;\n    expectTypeOf<TestAscii>().toEqualTypeOf<string>();\n\n    type TestUtf8 = ClarityToTS<{ \"string-utf8\": { length: 100 } }>;\n    expectTypeOf<TestUtf8>().toEqualTypeOf<string>();\n  });\n\n  it(\"should infer buffer types correctly\", () => {\n    type TestBuffer = ClarityToTS<{ buff: { length: 32 } }>;\n    expectTypeOf<TestBuffer>().toEqualTypeOf<Uint8Array>();\n  });\n\n  it(\"should infer optional types correctly\", () => {\n    type TestOptional = ClarityToTS<{ optional: \"uint128\" }>;\n    expectTypeOf<TestOptional>().toEqualTypeOf<bigint | null>();\n\n    type TestOptionalString = ClarityToTS<{\n      optional: { \"string-ascii\": { length: 10 } };\n    }>;\n    expectTypeOf<TestOptionalString>().toEqualTypeOf<string | null>();\n  });\n\n  it(\"should infer response types correctly\", () => {\n    type TestResponse = ClarityToTS<{\n      response: {\n        ok: \"bool\";\n        error: \"uint128\";\n      };\n    }>;\n    expectTypeOf<TestResponse>().toEqualTypeOf<\n      { ok: boolean } | { err: bigint }\n    >();\n  });\n\n  it(\"should infer list types correctly\", () => {\n    type TestList = ClarityToTS<{\n      list: {\n        type: \"uint128\";\n        length: 10;\n      };\n    }>;\n    expectTypeOf<TestList>().toEqualTypeOf<bigint[]>();\n  });\n\n  it(\"should infer tuple types correctly\", () => {\n    type TestTuple = ClarityToTS<{\n      tuple: [\n        { name: \"id\"; type: \"uint128\" },\n        { name: \"owner\"; type: \"principal\" },\n        { name: \"active\"; type: \"bool\" }\n      ];\n    }>;\n    expectTypeOf<TestTuple>().toEqualTypeOf<{\n      id: bigint;\n      owner: string;\n      active: boolean;\n    }>();\n  });\n});\n\ndescribe(\"Contract Type Extraction\", () => {\n  // Test contract\n  const testContract = {\n    functions: [\n      {\n        name: \"transfer\",\n        access: \"public\",\n        args: [\n          { name: \"id\", type: \"uint128\" },\n          { name: \"sender\", type: \"principal\" },\n          { name: \"recipient\", type: \"principal\" },\n        ],\n        outputs: {\n          response: {\n            ok: \"bool\",\n            error: \"uint128\",\n          },\n        },\n      },\n      {\n        name: \"get-owner\",\n        access: \"read-only\",\n        args: [{ name: \"id\", type: \"uint128\" }],\n        outputs: {\n          optional: \"principal\",\n        },\n      },\n      {\n        name: \"mint\",\n        access: \"public\",\n        args: [\n          { name: \"recipient\", type: \"principal\" },\n          {\n            name: \"metadata\",\n            type: {\n              tuple: [\n                { name: \"uri\", type: { \"string-ascii\": { length: 256 } } },\n                { name: \"name\", type: { \"string-utf8\": { length: 50 } } },\n              ],\n            },\n          },\n        ],\n        outputs: {\n          response: {\n            ok: \"uint128\",\n            error: \"uint128\",\n          },\n        },\n      },\n    ],\n  } as const satisfies ClarityContract;\n\n  it(\"should extract function names\", () => {\n    type FunctionNames = ExtractFunctionNames<typeof testContract>;\n    expectTypeOf<FunctionNames>().toEqualTypeOf<\n      \"transfer\" | \"get-owner\" | \"mint\"\n    >();\n  });\n\n  it(\"should extract function arguments\", () => {\n    type TransferArgs = ExtractFunctionArgs<typeof testContract, \"transfer\">;\n    expectTypeOf<TransferArgs>().toEqualTypeOf<{\n      id: bigint;\n      sender: string;\n      recipient: string;\n    }>();\n\n    type MintArgs = ExtractFunctionArgs<typeof testContract, \"mint\">;\n    expectTypeOf<MintArgs>().toEqualTypeOf<{\n      recipient: string;\n      metadata: {\n        uri: string;\n        name: string;\n      };\n    }>();\n  });\n\n  it(\"should extract function outputs\", () => {\n    type TransferOutput = ExtractFunctionOutput<\n      typeof testContract,\n      \"transfer\"\n    >;\n    expectTypeOf<TransferOutput>().toEqualTypeOf<\n      { ok: boolean } | { err: bigint }\n    >();\n\n    type GetOwnerOutput = ExtractFunctionOutput<\n      typeof testContract,\n      \"get-owner\"\n    >;\n    expectTypeOf<GetOwnerOutput>().toEqualTypeOf<string | null>();\n  });\n\n  it(\"should generate contract interface\", () => {\n    type Interface = ContractInterface<typeof testContract>;\n\n    // Test the type structure without runtime calls\n    expectTypeOf<Interface>().toHaveProperty(\"transfer\");\n    expectTypeOf<Interface>().toHaveProperty(\"mint\");\n\n    // Test that transfer accepts both object and positional args\n    type TransferFn = Interface[\"transfer\"];\n    expectTypeOf<TransferFn>().toBeCallableWith({\n      id: 1n,\n      sender: \"SP...\",\n      recipient: \"SP...\",\n    });\n    expectTypeOf<TransferFn>().toBeCallableWith(1n, \"SP...\", \"SP...\");\n\n    // Test that mint accepts the right arguments\n    type MintFn = Interface[\"mint\"];\n    expectTypeOf<MintFn>().toBeCallableWith({\n      recipient: \"SP...\",\n      metadata: { uri: \"https://...\", name: \"Test\" },\n    });\n    expectTypeOf<MintFn>().toBeCallableWith(\"SP...\", {\n      uri: \"https://...\",\n      name: \"Test\",\n    });\n\n    // Test return type\n    expectTypeOf<ReturnType<TransferFn>>().toEqualTypeOf<ContractCallParams>();\n  });\n});\n\ndescribe(\"Complex Type Inference\", () => {\n  it(\"should handle nested complex types\", () => {\n    // List of tuples\n    type ComplexType1 = ClarityToTS<{\n      list: {\n        type: {\n          tuple: [\n            { name: \"id\"; type: \"uint128\" },\n            {\n              name: \"data\";\n              type: { optional: { \"string-utf8\": { length: 50 } } };\n            }\n          ];\n        };\n        length: 100;\n      };\n    }>;\n\n    expectTypeOf<ComplexType1>().toEqualTypeOf<\n      Array<{\n        id: bigint;\n        data: string | null;\n      }>\n    >();\n\n    // Response with tuple\n    type ComplexType2 = ClarityToTS<{\n      response: {\n        ok: {\n          tuple: [\n            { name: \"status\"; type: \"bool\" },\n            { name: \"count\"; type: \"uint128\" }\n          ];\n        };\n        error: { \"string-ascii\": { length: 100 } };\n      };\n    }>;\n\n    expectTypeOf<ComplexType2>().toEqualTypeOf<\n      { ok: { status: boolean; count: bigint } } | { err: string }\n    >();\n  });\n});\n\ndescribe(\"Map and Variable Extraction\", () => {\n  const contractWithMapsAndVars = {\n    functions: [\n      {\n        name: \"internal-helper\",\n        access: \"private\",\n        args: [],\n        outputs: \"bool\",\n      },\n    ],\n    maps: [\n      {\n        name: \"balances\",\n        key: \"principal\",\n        value: \"uint128\",\n      },\n      {\n        name: \"token-owners\",\n        key: \"uint128\",\n        value: { optional: \"principal\" },\n      },\n    ],\n    variables: [\n      { name: \"contract-owner\", type: \"principal\", access: \"constant\" },\n      { name: \"total-supply\", type: \"uint128\", access: \"variable\" },\n    ],\n    fungible_tokens: [{ name: \"my-token\" }],\n    non_fungible_tokens: [{ name: \"my-nft\", type: \"uint128\" }],\n    implemented_traits: [\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7.sip-010-trait\"],\n    defined_traits: [\n      {\n        name: \"transfer-trait\",\n        functions: [\n          {\n            name: \"transfer\",\n            access: \"public\",\n            args: [{ name: \"amount\", type: \"uint128\" }],\n            outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n          },\n        ],\n      },\n    ],\n  } as const satisfies ClarityContract;\n\n  it(\"should extract map names\", () => {\n    type MapNames = ExtractMapNames<typeof contractWithMapsAndVars>;\n    expectTypeOf<MapNames>().toEqualTypeOf<\"balances\" | \"token-owners\">();\n  });\n\n  it(\"should extract map key and value types\", () => {\n    type BalanceKey = ExtractMapKey<typeof contractWithMapsAndVars, \"balances\">;\n    type BalanceValue = ExtractMapValue<typeof contractWithMapsAndVars, \"balances\">;\n    expectTypeOf<BalanceKey>().toEqualTypeOf<string>();\n    expectTypeOf<BalanceValue>().toEqualTypeOf<bigint>();\n  });\n\n  it(\"should extract variable names by access\", () => {\n    type AllVars = ExtractVariableNames<typeof contractWithMapsAndVars>;\n    type Constants = ExtractConstants<typeof contractWithMapsAndVars>;\n    type DataVars = ExtractDataVars<typeof contractWithMapsAndVars>;\n\n    expectTypeOf<AllVars>().toEqualTypeOf<\"contract-owner\" | \"total-supply\">();\n    expectTypeOf<Constants>().toEqualTypeOf<\"contract-owner\">();\n    expectTypeOf<DataVars>().toEqualTypeOf<\"total-supply\">();\n  });\n\n  it(\"should extract variable types\", () => {\n    type SupplyType = ExtractVariableType<typeof contractWithMapsAndVars, \"total-supply\">;\n    expectTypeOf<SupplyType>().toEqualTypeOf<bigint>();\n  });\n\n  it(\"should extract token names\", () => {\n    type FTNames = ExtractFungibleTokenNames<typeof contractWithMapsAndVars>;\n    type NFTNames = ExtractNonFungibleTokenNames<typeof contractWithMapsAndVars>;\n    expectTypeOf<FTNames>().toEqualTypeOf<\"my-token\">();\n    expectTypeOf<NFTNames>().toEqualTypeOf<\"my-nft\">();\n  });\n\n  it(\"should extract NFT asset type\", () => {\n    type NFTAsset = ExtractNFTAssetType<typeof contractWithMapsAndVars, \"my-nft\">;\n    expectTypeOf<NFTAsset>().toEqualTypeOf<bigint>();\n  });\n\n  it(\"should extract trait names\", () => {\n    type DefinedTraits = ExtractDefinedTraitNames<typeof contractWithMapsAndVars>;\n    type ImplementedTraits = ExtractImplementedTraits<typeof contractWithMapsAndVars>;\n    expectTypeOf<DefinedTraits>().toEqualTypeOf<\"transfer-trait\">();\n    expectTypeOf<ImplementedTraits>().toEqualTypeOf<\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7.sip-010-trait\">();\n  });\n\n  it(\"should extract private functions\", () => {\n    type PrivateFns = ExtractPrivateFunctions<typeof contractWithMapsAndVars>;\n    expectTypeOf<PrivateFns>().toEqualTypeOf<\"internal-helper\">();\n  });\n});",
    "packages/cli/src/generators/stacks-api-generator.ts": "import { formatCode } from \"../utils/format\";\n\n/**\n * Generate Stacks API utilities file\n */\nexport async function generateStacksApiUtils(): Promise<string> {\n  const code = `/**\n * Stacks API utility functions\n * Implements missing API functions using Stacks blockchain endpoints\n * DO NOT EDIT MANUALLY\n */\n\nexport interface StacksNetwork {\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}\n\n/**\n * Get the API base URL for the given network\n */\nfunction getApiUrl(network: StacksNetwork): string {\n  if (network.apiUrl) {\n    return network.apiUrl\n  }\n  \n  switch (network.network) {\n    case 'mainnet':\n      return 'https://api.hiro.so'\n    case 'testnet':\n      return 'https://api.testnet.hiro.so'\n    case 'devnet':\n      return 'http://localhost:3999'\n    default:\n      return 'https://api.testnet.hiro.so'\n  }\n}\n\n/**\n * Get the RPC API base URL for the given network\n */\nfunction getRpcApiUrl(network: StacksNetwork): string {\n  switch (network.network) {\n    case 'mainnet':\n      return 'https://stacks-node-api.mainnet.stacks.co'\n    case 'testnet':\n      return 'https://stacks-node-api.testnet.stacks.co'\n    case 'devnet':\n      return 'http://localhost:20443'\n    default:\n      return 'https://stacks-node-api.testnet.stacks.co'\n  }\n}\n\n/**\n * Fetch account information\n */\nexport async function fetchAccountInfo({ \n  address, \n  network,\n  apiUrl\n}: { \n  address: string\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const rpcUrl = getRpcApiUrl(networkConfig)\n  \n  try {\n    // Try RPC API first (more decentralized)\n    const response = await fetch(\\`\\${rpcUrl}/v2/accounts/\\${address}\\`)\n    if (!response.ok) {\n      throw new Error(\\`RPC API failed: \\${response.status}\\`)\n    }\n    return await response.json()\n  } catch (error) {\n    // Fallback to Hiro API\n    const apiUrlFallback = getApiUrl(networkConfig)\n    const response = await fetch(\\`\\${apiUrlFallback}/extended/v1/address/\\${address}/balances\\`)\n    if (!response.ok) {\n      throw new Error(\\`Failed to fetch account info: \\${response.status}\\`)\n    }\n    return await response.json()\n  }\n}\n\n/**\n * Fetch transaction information\n */\nexport async function fetchTransaction({ \n  txId, \n  network,\n  apiUrl\n}: { \n  txId: string\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const apiUrlResolved = getApiUrl(networkConfig)\n  \n  const response = await fetch(\\`\\${apiUrlResolved}/extended/v1/tx/\\${txId}\\`)\n  if (!response.ok) {\n    throw new Error(\\`Failed to fetch transaction: \\${response.status}\\`)\n  }\n  return await response.json()\n}\n\n/**\n * Fetch block information\n */\nexport async function fetchBlock({ \n  height, \n  network,\n  apiUrl\n}: { \n  height: number\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const apiUrlResolved = getApiUrl(networkConfig)\n  \n  const response = await fetch(\\`\\${apiUrlResolved}/extended/v1/block/by_height/\\${height}\\`)\n  if (!response.ok) {\n    throw new Error(\\`Failed to fetch block: \\${response.status}\\`)\n  }\n  return await response.json()\n}\n\n/**\n * Fetch account transactions\n */\nexport async function fetchAccountTransactions({ \n  address, \n  network,\n  apiUrl,\n  limit = 50,\n  offset = 0\n}: { \n  address: string\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiUrl?: string\n  limit?: number\n  offset?: number\n}) {\n  const networkConfig: StacksNetwork = { network, apiUrl }\n  const apiUrlResolved = getApiUrl(networkConfig)\n  \n  const response = await fetch(\n    \\`\\${apiUrlResolved}/extended/v1/address/\\${address}/transactions?limit=\\${limit}&offset=\\${offset}\\`\n  )\n  if (!response.ok) {\n    throw new Error(\\`Failed to fetch account transactions: \\${response.status}\\`)\n  }\n  return await response.json()\n}`;\n\n  return formatCode(code);\n}",
    "packages/cli/src/plugins/react/provider/context.ts": "/**\n * React Context for SecondLayer configuration\n */\n\nimport { createContext } from \"react\";\nimport type { SecondLayerReactConfig } from \"../types\";\n\n/**\n * React context for SecondLayer configuration\n */\nexport const SecondLayerContext = createContext<SecondLayerReactConfig | undefined>(\n  undefined\n);\n\n/**\n * Display name for debugging\n */\nSecondLayerContext.displayName = \"SecondLayerContext\";",
    "packages/cli/src/plugins/react/provider/provider.tsx": "/**\n * React Provider for SecondLayer configuration\n */\n\nimport React from \"react\";\nimport { SecondLayerContext } from \"./context\";\nimport type { SecondLayerProviderProps, SecondLayerReactConfig } from \"../types\";\n\n/**\n * Create a SecondLayer React configuration with defaults\n */\nexport function createSecondLayerConfig(\n  config: SecondLayerReactConfig\n): SecondLayerReactConfig {\n  return {\n    network: config.network,\n    apiKey: config.apiKey,\n    apiUrl: config.apiUrl,\n    senderAddress: config.senderAddress || \"SP000000000000000000002Q6VF78\",\n  };\n}\n\n/**\n * Provider component that makes SecondLayer configuration available to hooks\n */\nexport function SecondLayerProvider({ children, config }: SecondLayerProviderProps) {\n  const resolvedConfig = createSecondLayerConfig(config);\n\n  return (\n    <SecondLayerContext.Provider value={resolvedConfig}>\n      {children}\n    </SecondLayerContext.Provider>\n  );\n}\n\n/**\n * Hook to access the SecondLayer configuration\n */\nexport function useSecondLayerConfig(): SecondLayerReactConfig {\n  const context = React.useContext(SecondLayerContext);\n\n  if (context === undefined) {\n    throw new Error(\n      \"useSecondLayerConfig must be used within a SecondLayerProvider. \" +\n        \"Make sure to wrap your app with <SecondLayerProvider config={...}>\"\n    );\n  }\n\n  return context;\n}",
    "packages/cli/src/plugins/react/provider/types.ts": "/**\n * Provider-specific types (re-exports for convenience)\n */\n\nexport type { SecondLayerReactConfig, SecondLayerProviderProps } from \"../types\";",
    "packages/cli/src/plugins/react/types.ts": "/**\n * React Plugin Types for @secondlayer/cli\n */\n\nimport type { PluginOptions } from \"../../types/plugin\";\n\n/**\n * React plugin configuration options\n */\nexport interface ReactPluginOptions extends PluginOptions {\n  /**\n   * Hooks to exclude from generation (both generic and contract-specific)\n   * By default, all hooks are generated\n   */\n  exclude?: string[];\n}\n\n/**\n * React-specific configuration types for the provider\n */\nexport interface SecondLayerReactConfig {\n  /**\n   * Network to use for API calls\n   */\n  network: \"mainnet\" | \"testnet\" | \"devnet\";\n\n  /**\n   * API key for Stacks API (optional)\n   */\n  apiKey?: string;\n\n  /**\n   * Base URL for Stacks API (optional override)\n   */\n  apiUrl?: string;\n\n  /**\n   * Default sender address for read-only calls\n   */\n  senderAddress?: string;\n}\n\n/**\n * Provider component props\n */\nexport interface SecondLayerProviderProps {\n  children: React.ReactNode;\n  config: SecondLayerReactConfig;\n}",
    "packages/cli/src/plugins/testing/generators.ts": "/**\n * Code generators for the testing plugin\n * Generates type-safe helpers for Clarinet SDK unit tests\n */\n\nimport type { ProcessedContract } from \"../../types/plugin\";\nimport {\n  toCamelCase,\n  type ClarityFunction,\n  type ClarityMap,\n  type ClarityVariable,\n} from \"@secondlayer/clarity-types\";\nimport type { TestingPluginOptions } from \"./index\";\nimport { getTypeForArg } from \"../../utils/type-mapping\";\n\n/**\n * Convert string to PascalCase\n */\nfunction toPascalCase(str: string): string {\n  const camel = toCamelCase(str);\n  return camel.charAt(0).toUpperCase() + camel.slice(1);\n}\n\n/**\n * Generate arguments signature for helper functions\n */\nfunction generateArgsSignature(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n\n  const argsTypes = args\n    .map((arg) => {\n      const camelName = toCamelCase(arg.name);\n      return `${camelName}: ${getTypeForArg(arg)}`;\n    })\n    .join(\"; \");\n\n  return `args: { ${argsTypes} }, `;\n}\n\n/**\n * Convert TypeScript value to ClarityValue based on the argument type\n */\nfunction generateClarityConversion(argName: string, argType: any): string {\n  const type = argType.type;\n\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"uint128\":\n        return `Cl.uint(${argName})`;\n      case \"int128\":\n        return `Cl.int(${argName})`;\n      case \"bool\":\n        return `Cl.bool(${argName})`;\n      case \"principal\":\n      case \"trait_reference\":\n        return `(() => {\n          const principal = ${argName};\n          if (principal.includes(\".\")) {\n            const [address, contractName] = principal.split(\".\") as [string, string];\n            return Cl.contractPrincipal(address, contractName);\n          } else {\n            return Cl.standardPrincipal(principal);\n          }\n        })()`;\n      default:\n        return `${argName}`;\n    }\n  }\n\n  if (type[\"string-ascii\"]) {\n    return `Cl.stringAscii(${argName})`;\n  }\n\n  if (type[\"string-utf8\"]) {\n    return `Cl.stringUtf8(${argName})`;\n  }\n\n  if (type.buff) {\n    return `(() => {\n      const value = ${argName};\n      if (value instanceof Uint8Array) {\n        return Cl.buffer(value);\n      }\n      if (typeof value === 'object' && value !== null && 'type' in value && 'value' in value) {\n        switch (value.type) {\n          case 'ascii':\n            return Cl.bufferFromAscii(value.value);\n          case 'utf8':\n            return Cl.bufferFromUtf8(value.value);\n          case 'hex':\n            return Cl.bufferFromHex(value.value);\n          default:\n            throw new Error(\\`Unsupported buffer type: \\${value.type}\\`);\n        }\n      }\n      if (typeof value === 'string') {\n        if (value.startsWith('0x') || /^[0-9a-fA-F]+$/.test(value)) {\n          return Cl.bufferFromHex(value);\n        }\n        if (!/^[\\\\x00-\\\\x7F]*$/.test(value)) {\n          return Cl.bufferFromUtf8(value);\n        }\n        return Cl.bufferFromAscii(value);\n      }\n      throw new Error(\\`Invalid buffer value: \\${value}\\`);\n    })()`;\n  }\n\n  if (type.optional) {\n    const innerConversion = generateClarityConversion(\"inner\", {\n      type: type.optional,\n    });\n    return `${argName} !== null ? Cl.some((() => { const inner = ${argName}; return ${innerConversion}; })()) : Cl.none()`;\n  }\n\n  if (type.list) {\n    const innerConversion = generateClarityConversion(\"item\", {\n      type: type.list.type,\n    });\n    const maxLength = type.list.length || 100;\n    return `(() => {\n      const listValue = ${argName};\n      if (listValue.length > ${maxLength}) {\n        throw new Error(\\`List length \\${listValue.length} exceeds max ${maxLength}\\`);\n      }\n      return Cl.list(listValue.map(item => ${innerConversion}));\n    })()`;\n  }\n\n  if (type.tuple) {\n    const requiredFields = type.tuple.map((f: any) => f.name);\n    const fieldNames = JSON.stringify(requiredFields);\n    const fields = type.tuple\n      .map((field: any) => {\n        const camelFieldName = toCamelCase(field.name);\n        const fieldConversion = generateClarityConversion(\n          `tupleValue.${camelFieldName}`,\n          { type: field.type }\n        );\n        return `\"${field.name}\": ${fieldConversion}`;\n      })\n      .join(\", \");\n    return `(() => {\n      const tupleValue = ${argName};\n      const requiredFields = ${fieldNames};\n      for (const fieldName of requiredFields) {\n        const camelName = fieldName.replace(/-([a-z])/g, (_: string, l: string) => l.toUpperCase());\n        if (!(fieldName in tupleValue) && !(camelName in tupleValue)) {\n          throw new Error(\\`Missing tuple field: \\${fieldName}\\`);\n        }\n      }\n      return Cl.tuple({ ${fields} });\n    })()`;\n  }\n\n  if (type.response) {\n    const okConversion = generateClarityConversion(`responseValue.ok`, {\n      type: type.response.ok,\n    });\n    const errConversion = generateClarityConversion(`responseValue.err`, {\n      type: type.response.error,\n    });\n    return `(() => {\n      const responseValue = ${argName};\n      const hasOk = 'ok' in responseValue;\n      const hasErr = 'err' in responseValue;\n      if (hasOk && !hasErr) {\n        return Cl.ok(${okConversion});\n      }\n      if (hasErr && !hasOk) {\n        return Cl.error(${errConversion});\n      }\n      throw new Error(\"Response must have exactly 'ok' or 'err' property\");\n    })()`;\n  }\n\n  return `${argName}`;\n}\n\n/**\n * Generate Clarity arguments for function calls\n */\nfunction generateClarityArgs(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n\n  return args\n    .map((arg) => {\n      const argName = `args.${toCamelCase(arg.name)}`;\n      return generateClarityConversion(argName, arg);\n    })\n    .join(\", \");\n}\n\n/**\n * Generate a public function helper\n */\nfunction generatePublicFunction(\n  func: ClarityFunction,\n  contractId: string\n): string {\n  const methodName = toCamelCase(func.name);\n  const argsSignature = generateArgsSignature(func.args);\n  const clarityArgs = generateClarityArgs(func.args);\n\n  return `${methodName}: (${argsSignature}caller: string) => {\n      const callerAddr = accounts.get(caller) ?? caller;\n      return simnet.callPublicFn(\n        '${contractId}',\n        '${func.name}',\n        [${clarityArgs}],\n        callerAddr\n      );\n    }`;\n}\n\n/**\n * Generate a read-only function helper\n */\nfunction generateReadOnlyFunction(\n  func: ClarityFunction,\n  contractId: string\n): string {\n  const methodName = toCamelCase(func.name);\n  const argsSignature = generateArgsSignature(func.args);\n  const clarityArgs = generateClarityArgs(func.args);\n\n  // Read-only functions don't need a caller, use deployer as default\n  const hasArgs = func.args.length > 0;\n  const argsParam = hasArgs ? argsSignature : \"\";\n\n  return `${methodName}: (${argsParam}) => {\n      return simnet.callReadOnlyFn(\n        '${contractId}',\n        '${func.name}',\n        [${clarityArgs}],\n        accounts.get('deployer')!\n      );\n    }`;\n}\n\n/**\n * Generate a private function helper (for testing only)\n */\nfunction generatePrivateFunction(\n  func: ClarityFunction,\n  contractId: string\n): string {\n  const methodName = toCamelCase(func.name);\n  const argsSignature = generateArgsSignature(func.args);\n  const clarityArgs = generateClarityArgs(func.args);\n\n  return `${methodName}: (${argsSignature}caller: string) => {\n      const callerAddr = accounts.get(caller) ?? caller;\n      return simnet.callPrivateFn(\n        '${contractId}',\n        '${func.name}',\n        [${clarityArgs}],\n        callerAddr\n      );\n    }`;\n}\n\n/**\n * Generate a data variable accessor helper\n */\nfunction generateDataVarHelper(\n  variable: ClarityVariable,\n  contractId: string\n): string {\n  const methodName = toCamelCase(variable.name);\n\n  return `${methodName}: () => {\n      return simnet.getDataVar('${contractId}', '${variable.name}');\n    }`;\n}\n\n/**\n * Generate TypeScript type for map key based on its structure\n */\nfunction getMapKeyType(keyType: any): string {\n  // Map keys are typically tuples\n  if (keyType.tuple) {\n    const fields = keyType.tuple\n      .map(\n        (field: any) =>\n          `${toCamelCase(field.name)}: ${getTypeForArg({ type: field.type })}`\n      )\n      .join(\"; \");\n    return `{ ${fields} }`;\n  }\n\n  // Single-value keys (less common but possible)\n  return getTypeForArg({ type: keyType });\n}\n\n/**\n * Generate Clarity conversion for map key\n */\nfunction generateMapKeyConversion(keyType: any): string {\n  // Map keys are typically tuples\n  if (keyType.tuple) {\n    const fields = keyType.tuple\n      .map((field: any) => {\n        const camelFieldName = toCamelCase(field.name);\n        const fieldConversion = generateClarityConversion(\n          `key.${camelFieldName}`,\n          { type: field.type }\n        );\n        return `\"${field.name}\": ${fieldConversion}`;\n      })\n      .join(\", \");\n    return `Cl.tuple({ ${fields} })`;\n  }\n\n  // Single-value keys\n  return generateClarityConversion(\"key\", { type: keyType });\n}\n\n/**\n * Generate a map entry accessor helper\n */\nfunction generateMapEntryHelper(map: ClarityMap, contractId: string): string {\n  const methodName = toCamelCase(map.name);\n  const keyType = getMapKeyType(map.key);\n  const keyConversion = generateMapKeyConversion(map.key);\n\n  return `${methodName}: (key: ${keyType}) => {\n      return simnet.getMapEntry(\n        '${contractId}',\n        '${map.name}',\n        ${keyConversion}\n      );\n    }`;\n}\n\n/**\n * Generate the vars object containing all data variable accessors\n */\nfunction generateVarsObject(\n  variables: ClarityVariable[],\n  contractId: string\n): string {\n  // Filter to only include mutable variables (not constants)\n  const dataVars = variables.filter((v) => v.access === \"variable\");\n\n  if (dataVars.length === 0) {\n    return \"\";\n  }\n\n  const varHelpers = dataVars.map((v) => generateDataVarHelper(v, contractId));\n\n  return `vars: {\n      ${varHelpers.join(\",\\n\\n      \")}\n    }`;\n}\n\n/**\n * Generate the maps object containing all map entry accessors\n */\nfunction generateMapsObject(maps: ClarityMap[], contractId: string): string {\n  if (maps.length === 0) {\n    return \"\";\n  }\n\n  const mapHelpers = maps.map((m) => generateMapEntryHelper(m, contractId));\n\n  return `maps: {\n      ${mapHelpers.join(\",\\n\\n      \")}\n    }`;\n}\n\n/**\n * Generate a contract helper factory function\n */\nfunction generateContractHelper(\n  contract: ProcessedContract,\n  options: TestingPluginOptions\n): string {\n  const { abi, name, address } = contract;\n  const functions = abi.functions || [];\n  const variables: ClarityVariable[] = abi.variables || [];\n  const maps: ClarityMap[] = abi.maps || [];\n  const pascalName = toPascalCase(name);\n\n  // Filter functions by access type\n  const publicFns = functions.filter(\n    (f: ClarityFunction) => f.access === \"public\"\n  );\n  const readOnlyFns = functions.filter(\n    (f: ClarityFunction) =>\n      (f.access as any) === \"read_only\" || f.access === \"read-only\"\n  );\n  const privateFns = options.includePrivate\n    ? functions.filter((f: ClarityFunction) => f.access === \"private\")\n    : [];\n\n  // Generate function helpers\n  const publicHelpers = publicFns.map((f: ClarityFunction) =>\n    generatePublicFunction(f, address)\n  );\n  const readOnlyHelpers = readOnlyFns.map((f: ClarityFunction) =>\n    generateReadOnlyFunction(f, address)\n  );\n  const privateHelpers = privateFns.map((f: ClarityFunction) =>\n    generatePrivateFunction(f, address)\n  );\n\n  // Generate data variable and map accessors\n  const varsObject = generateVarsObject(variables, address);\n  const mapsObject = generateMapsObject(maps, address);\n\n  const allHelpers = [...publicHelpers, ...readOnlyHelpers, ...privateHelpers];\n\n  // Include vars and maps objects if they have content\n  if (varsObject) {\n    allHelpers.push(varsObject);\n  }\n  if (mapsObject) {\n    allHelpers.push(mapsObject);\n  }\n\n  if (allHelpers.length === 0) {\n    return \"\";\n  }\n\n  return `export function get${pascalName}(simnet: Simnet) {\n  const accounts = simnet.getAccounts();\n\n  return {\n    ${allHelpers.join(\",\\n\\n    \")}\n  };\n}`;\n}\n\n/**\n * Generate the getContracts convenience wrapper\n */\nfunction generateGetContracts(contracts: ProcessedContract[]): string {\n  const contractEntries = contracts\n    .map((contract) => {\n      const camelName = toCamelCase(contract.name);\n      const pascalName = toPascalCase(contract.name);\n      return `${camelName}: get${pascalName}(simnet)`;\n    })\n    .join(\",\\n    \");\n\n  return `export function getContracts(simnet: Simnet) {\n  const accounts = simnet.getAccounts();\n\n  return {\n    accounts,\n    ${contractEntries}\n  };\n}`;\n}\n\n/**\n * Generate type exports for consumer convenience\n */\nfunction generateTypeExports(contracts: ProcessedContract[]): string {\n  const typeExports = contracts\n    .map((contract) => {\n      const pascalName = toPascalCase(contract.name);\n      return `export type ${pascalName}Helpers = ReturnType<typeof get${pascalName}>;`;\n    })\n    .join(\"\\n\");\n\n  return `${typeExports}\nexport type Contracts = ReturnType<typeof getContracts>;`;\n}\n\n/**\n * Main entry point - generates the full testing helpers file\n */\nexport async function generateTestingHelpers(\n  contracts: ProcessedContract[],\n  options: TestingPluginOptions\n): Promise<string> {\n  const contractHelpers = contracts\n    .map((contract) => generateContractHelper(contract, options))\n    .filter(Boolean);\n\n  if (contractHelpers.length === 0) {\n    return `// No contracts with functions to generate helpers for\nexport {};`;\n  }\n\n  const getContractsCode = generateGetContracts(contracts);\n  const typeExports = generateTypeExports(contracts);\n\n  return `/**\n * Generated by @secondlayer/cli testing plugin\n * Type-safe helpers for Clarinet SDK unit tests\n */\n\nimport { type Simnet, Cl } from '@hirosystems/clarinet-sdk';\n\n// ============================================\n// Per-contract factory functions\n// ============================================\n\n${contractHelpers.join(\"\\n\\n\")}\n\n// ============================================\n// Convenience: all contracts at once\n// ============================================\n\n${getContractsCode}\n\n// ============================================\n// Type exports\n// ============================================\n\n${typeExports}\n`;\n}",
    "packages/cli/src/react/config.ts": "import type { SecondLayerReactConfig } from \"./types\";\n\n/**\n * Create a SecondLayer React configuration\n */\nexport function createSecondLayerConfig(\n  config: SecondLayerReactConfig\n): SecondLayerReactConfig {\n  return {\n    network: config.network,\n    apiKey: config.apiKey,\n    apiUrl: config.apiUrl,\n    senderAddress: config.senderAddress || \"SP000000000000000000002Q6VF78\",\n  };\n}",
    "packages/cli/src/react/hooks.ts": "import type { SecondLayerReactConfig } from \"./types\";\n\n/**\n * Hook to access the SecondLayer configuration\n * This will be generated in user projects that have React\n */\nexport function useSecondLayerConfig(): SecondLayerReactConfig {\n  throw new Error(\n    \"useSecondLayerConfig is only available in generated React hooks. Make sure you have React installed and hooks enabled in your config.\"\n  );\n}",
    "packages/cli/src/react/index.ts": "/**\n * React integration for @secondlayer/cli\n */\n\nexport { useSecondLayerConfig } from \"./hooks\";\nexport { createSecondLayerConfig } from \"./config\";\nexport type { SecondLayerReactConfig } from \"./types\";",
    "packages/cli/src/react/types.ts": "import type { NetworkName } from \"../types/config\";\n\n/**\n * React-specific configuration types\n */\n\nexport interface SecondLayerReactConfig {\n  /**\n   * Network to use for API calls\n   */\n  network: NetworkName;\n\n  /**\n   * API key for Stacks API (optional)\n   */\n  apiKey?: string;\n\n  /**\n   * Base URL for Stacks API (optional override)\n   */\n  apiUrl?: string;\n\n  /**\n   * Default sender address for read-only calls\n   */\n  senderAddress?: string;\n}",
    "packages/cli/src/utils/abi-compat.ts": "/**\n * ABI compatibility layer for normalizing different ABI formats\n *\n * Handles differences between:\n * - Upstream ClarityAbi types (uses `buffer`, `read_only`)\n * - Internal format (uses `buff`, `read-only`)\n */\n\nimport type {\n  ClarityContract,\n  ClarityFunction,\n  ClarityMap,\n  ClarityVariable,\n  ClarityType,\n} from \"@secondlayer/clarity-types\";\n\n/**\n * Normalize function access type from various formats to internal format\n */\nexport function normalizeAccess(\n  access: string\n): \"public\" | \"read-only\" | \"private\" {\n  if (access === \"read_only\") return \"read-only\";\n  return access as \"public\" | \"read-only\" | \"private\";\n}\n\n/**\n * Normalize a Clarity type from API format to internal format\n * Handles buffer vs buff, and recursively normalizes nested types\n */\nexport function normalizeType(type: unknown): ClarityType {\n  if (typeof type === \"string\") {\n    // Handle string primitive types\n    switch (type) {\n      case \"uint128\":\n      case \"int128\":\n      case \"bool\":\n      case \"principal\":\n      case \"trait_reference\":\n        return type;\n      default:\n        // Unknown string type, return as-is\n        return type as ClarityType;\n    }\n  }\n\n  if (typeof type !== \"object\" || type === null) {\n    throw new Error(`Invalid ABI type: expected object, got ${typeof type}`);\n  }\n\n  const typeObj = type as Record<string, unknown>;\n\n  // Handle buffer vs buff (API uses buffer, we use buff)\n  if (\"buffer\" in typeObj) {\n    const buffer = typeObj.buffer as { length?: number };\n    return {\n      buff: {\n        length: buffer?.length ?? 32,\n      },\n    };\n  }\n\n  // Already in internal format\n  if (\"buff\" in typeObj) {\n    const buff = typeObj.buff as { length?: number };\n    return {\n      buff: {\n        length: buff?.length ?? 32,\n      },\n    };\n  }\n\n  // String types\n  if (\"string-ascii\" in typeObj) {\n    const strAscii = typeObj[\"string-ascii\"] as { length?: number };\n    return {\n      \"string-ascii\": {\n        length: strAscii?.length ?? 256,\n      },\n    };\n  }\n\n  if (\"string-utf8\" in typeObj) {\n    const strUtf8 = typeObj[\"string-utf8\"] as { length?: number };\n    return {\n      \"string-utf8\": {\n        length: strUtf8?.length ?? 256,\n      },\n    };\n  }\n\n  // Response type - recursively normalize ok and error types\n  if (\"response\" in typeObj) {\n    const response = typeObj.response as { ok?: unknown; error?: unknown };\n    return {\n      response: {\n        ok: normalizeType(response?.ok ?? \"bool\"),\n        error: normalizeType(response?.error ?? \"uint128\"),\n      },\n    };\n  }\n\n  // Optional type - recursively normalize inner type\n  if (\"optional\" in typeObj) {\n    return {\n      optional: normalizeType(typeObj.optional),\n    };\n  }\n\n  // List type - recursively normalize element type\n  if (\"list\" in typeObj) {\n    const list = typeObj.list as { type?: unknown; length?: number };\n    return {\n      list: {\n        type: normalizeType(list?.type ?? \"uint128\"),\n        length: list?.length ?? 100,\n      },\n    };\n  }\n\n  // Tuple type - recursively normalize field types\n  if (\"tuple\" in typeObj) {\n    const tuple = typeObj.tuple as Array<{ name: string; type: unknown }>;\n    return {\n      tuple: tuple.map((field) => ({\n        name: field.name,\n        type: normalizeType(field.type),\n      })),\n    };\n  }\n\n  // Unknown type - fail explicitly\n  throw new Error(`Unknown ABI type structure: ${JSON.stringify(type)}`);\n}\n\n/**\n * Normalize a function definition from API format to internal format\n */\nexport function normalizeFunction(func: Record<string, unknown>): ClarityFunction {\n  const access = normalizeAccess(func.access as string);\n  const args = (func.args as Array<{ name: string; type: unknown }>) ?? [];\n  const outputs = func.outputs as { type?: unknown } | unknown;\n\n  return {\n    name: func.name as string,\n    access,\n    args: args.map((arg) => ({\n      name: arg.name,\n      type: normalizeType(arg.type),\n    })),\n    outputs: normalizeType(\n      typeof outputs === \"object\" && outputs !== null && \"type\" in outputs\n        ? (outputs as { type: unknown }).type\n        : outputs\n    ),\n  };\n}\n\n/**\n * Normalize a map definition from API format to internal format\n */\nexport function normalizeMap(map: Record<string, unknown>): ClarityMap {\n  return {\n    name: map.name as string,\n    key: normalizeType(map.key),\n    value: normalizeType(map.value),\n  };\n}\n\n/**\n * Normalize a variable definition from API format to internal format\n */\nexport function normalizeVariable(\n  variable: Record<string, unknown>\n): ClarityVariable {\n  return {\n    name: variable.name as string,\n    type: normalizeType(variable.type),\n    access: variable.access as \"constant\" | \"variable\",\n  };\n}\n\n/**\n * Normalize an entire ABI from various sources to consistent internal format\n *\n * This handles ABIs from:\n * - Hiro API responses\n * - Clarinet SDK\n * - Upstream @stacks/transactions types\n */\nexport function normalizeAbi(abi: unknown): ClarityContract {\n  if (typeof abi !== \"object\" || abi === null) {\n    return { functions: [] };\n  }\n\n  const abiObj = abi as Record<string, unknown>;\n\n  const functions: ClarityFunction[] = [];\n  const maps: ClarityMap[] = [];\n  const variables: ClarityVariable[] = [];\n\n  // Normalize functions\n  if (Array.isArray(abiObj.functions)) {\n    for (const func of abiObj.functions) {\n      if (typeof func === \"object\" && func !== null) {\n        functions.push(normalizeFunction(func as Record<string, unknown>));\n      }\n    }\n  }\n\n  // Normalize maps\n  if (Array.isArray(abiObj.maps)) {\n    for (const map of abiObj.maps) {\n      if (typeof map === \"object\" && map !== null) {\n        maps.push(normalizeMap(map as Record<string, unknown>));\n      }\n    }\n  }\n\n  // Normalize variables\n  if (Array.isArray(abiObj.variables)) {\n    for (const variable of abiObj.variables) {\n      if (typeof variable === \"object\" && variable !== null) {\n        variables.push(normalizeVariable(variable as Record<string, unknown>));\n      }\n    }\n  }\n\n  return {\n    functions,\n    maps: maps.length > 0 ? maps : undefined,\n    variables: variables.length > 0 ? variables : undefined,\n  };\n}",
    "packages/cli/src/utils/format.ts": "/**\n * Shared code formatting utilities using Biome\n */\n\nimport { Biome, Distribution } from \"@biomejs/js-api\";\n\nlet biome: Biome | null = null;\n\n/**\n * Lazily initialize Biome singleton\n */\nasync function getBiome(): Promise<Biome> {\n\tif (!biome) {\n\t\tbiome = await Biome.create({\n\t\t\tdistribution: Distribution.NODE,\n\t\t});\n\n\t\tbiome.applyConfiguration({\n\t\t\tformatter: {\n\t\t\t\tenabled: true,\n\t\t\t\tindentStyle: \"tab\",\n\t\t\t\tlineWidth: 80,\n\t\t\t},\n\t\t\tjavascript: {\n\t\t\t\tformatter: {\n\t\t\t\t\tsemicolons: \"always\",\n\t\t\t\t\tquoteStyle: \"single\",\n\t\t\t\t},\n\t\t\t},\n\t\t\torganizeImports: {\n\t\t\t\tenabled: true,\n\t\t\t},\n\t\t\tlinter: {\n\t\t\t\tenabled: true,\n\t\t\t},\n\t\t\tassists: {\n\t\t\t\tenabled: true,\n\t\t\t},\n\t\t});\n\n\t\tbiome.registerProjectFolder();\n\t}\n\n\treturn biome;\n}\n\n/**\n * Format TypeScript code using Biome\n */\nexport async function formatCode(code: string): Promise<string> {\n\tconst b = await getBiome();\n\n\t// Use lintContent with SafeFixes to organize imports\n\tconst linted = b.lintContent(code, {\n\t\tfilePath: \"generated.ts\",\n\t\tfixFileMode: \"SafeFixes\",\n\t});\n\n\t// Then format\n\tconst formatted = b.formatContent(linted.content, {\n\t\tfilePath: \"generated.ts\",\n\t});\n\n\treturn formatted.content;\n}",
    "packages/cli/src/index.ts": "/**\n * @secondlayer/cli\n * CLI tool for generating type-safe Stacks contract interfaces\n */\n\nexport { defineConfig } from \"./utils/config\";\nexport type {\n  SecondLayerConfig,\n  ContractSource,\n  NetworkName,\n} from \"./types/config\";\n\nexport type {\n  ClarityContract,\n  ClarityFunction,\n  ClarityType,\n  ContractCallParams,\n  ReadOnlyCallParams,\n} from \"@secondlayer/clarity-types\";\n\n// Plugin system exports\nexport type {\n  SecondLayerPlugin,\n  PluginFactory,\n  PluginOptions,\n  UserConfig,\n  ResolvedConfig,\n  GenerateContext,\n  PluginContext,\n  Logger,\n  PluginUtils,\n  GeneratedOutput,\n  ProcessedContract,\n  ContractConfig,\n  OutputType,\n} from \"./types/plugin\";\n\nexport { PluginManager } from \"./core/plugin-manager\";",
    "packages/cli/tests/actions-plugin.test.ts": "import { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { generateActionHelpers } from \"../src/plugins/actions/generators\";\nimport type { ProcessedContract } from \"../src/types/plugin\";\nimport type { ActionsPluginOptions } from \"../src/plugins/actions/index\";\n\ndescribe(\"Actions Plugin\", () => {\n  const sampleContract: ProcessedContract = {\n    name: \"testContract\",\n    address: \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9\",\n    contractName: \"test-contract\",\n    abi: {\n      functions: [\n        {\n          name: \"transfer\",\n          access: \"public\",\n          args: [\n            { name: \"amount\", type: \"uint128\" },\n            { name: \"sender\", type: \"principal\" },\n            { name: \"recipient\", type: \"principal\" },\n          ],\n          outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n        },\n        {\n          name: \"get-balance\",\n          access: \"read-only\",\n          args: [{ name: \"account\", type: \"principal\" }],\n          outputs: \"uint128\",\n        },\n        {\n          name: \"get-total-supply\",\n          access: \"read-only\",\n          args: [],\n          outputs: \"uint128\",\n        },\n        {\n          name: \"mint\",\n          access: \"public\",\n          args: [{ name: \"amount\", type: \"uint128\" }],\n          outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n        },\n      ],\n    },\n    source: \"local\",\n    metadata: { source: \"clarinet\" },\n  };\n\n  describe(\"Read Helper Generation\", () => {\n    it(\"should generate read helpers for read-only functions\", async () => {\n      const options: ActionsPluginOptions = {};\n      const code = await generateActionHelpers(sampleContract, options);\n\n      // Should contain read helper functions\n      expect(code).toContain(\"read: {\");\n      expect(code).toContain(\"async getBalance(\");\n      expect(code).toContain(\"async getTotalSupply(\");\n\n      // Should use fetchCallReadOnlyFunction\n      expect(code).toContain(\"fetchCallReadOnlyFunction\");\n\n      // Should handle arguments correctly\n      expect(code).toContain(\"args: { account: string }\");\n\n      // Should handle no-argument functions\n      expect(code).toContain(\"async getTotalSupply(options?:\");\n    });\n\n    it(\"should filter read functions based on includeFunctions option\", async () => {\n      const options: ActionsPluginOptions = {\n        includeFunctions: [\"get-balance\"],\n      };\n      const code = await generateActionHelpers(sampleContract, options);\n\n      expect(code).toContain(\"async getBalance(\");\n      expect(code).not.toContain(\"async getTotalSupply(\");\n    });\n\n    it(\"should filter read functions based on excludeFunctions option\", async () => {\n      const options: ActionsPluginOptions = {\n        excludeFunctions: [\"get-balance\"],\n      };\n      const code = await generateActionHelpers(sampleContract, options);\n\n      expect(code).not.toContain(\"async getBalance(\");\n      expect(code).toContain(\"async getTotalSupply(\");\n    });\n  });\n\n  describe(\"Write Helper Generation\", () => {\n    it(\"should generate write helpers for public functions\", async () => {\n      const options: ActionsPluginOptions = {};\n      const code = await generateActionHelpers(sampleContract, options);\n\n      // Should contain write helper functions\n      expect(code).toContain(\"write: {\");\n      expect(code).toContain(\"async transfer(\");\n      expect(code).toContain(\"async mint(\");\n\n      // Should use makeContractCall\n      expect(code).toContain(\"makeContractCall\");\n\n      // Should have optional senderKey parameter\n      expect(code).toContain(\"senderKey?: string\");\n\n      // Should have env var fallback\n      expect(code).toContain(\"process.env.STX_SENDER_KEY\");\n      expect(code).toContain(\"senderKey required: pass as argument or set STX_SENDER_KEY env var\");\n\n      // Should handle arguments correctly\n      expect(code).toContain(\n        \"args: { amount: bigint; sender: string; recipient: string }\"\n      );\n    });\n\n    it(\"should filter write functions based on includeFunctions option\", async () => {\n      const options: ActionsPluginOptions = {\n        includeFunctions: [\"transfer\"],\n      };\n      const code = await generateActionHelpers(sampleContract, options);\n\n      expect(code).toContain(\"async transfer(\");\n      expect(code).not.toContain(\"async mint(\");\n    });\n\n    it(\"should filter write functions based on excludeFunctions option\", async () => {\n      const options: ActionsPluginOptions = {\n        excludeFunctions: [\"transfer\"],\n      };\n      const code = await generateActionHelpers(sampleContract, options);\n\n      expect(code).not.toContain(\"async transfer(\");\n      expect(code).toContain(\"async mint(\");\n    });\n\n    it(\"should use custom senderKeyEnv when provided\", async () => {\n      const options: ActionsPluginOptions = {\n        senderKeyEnv: \"MY_CUSTOM_KEY\",\n      };\n      const code = await generateActionHelpers(sampleContract, options);\n\n      expect(code).toContain(\"process.env.MY_CUSTOM_KEY\");\n      expect(code).toContain(\"senderKey required: pass as argument or set MY_CUSTOM_KEY env var\");\n      expect(code).not.toContain(\"STX_SENDER_KEY\");\n    });\n  });\n\n  describe(\"Edge Cases\", () => {\n    it(\"should handle contracts with only read-only functions\", async () => {\n      const readOnlyContract: ProcessedContract = {\n        name: \"readOnlyContract\",\n        address: \"SP123\",\n        contractName: \"read-only\",\n        abi: {\n          functions: [\n            {\n              name: \"get-data\",\n              access: \"read-only\",\n              args: [{ name: \"id\", type: \"uint128\" }],\n              outputs: \"uint128\",\n            },\n          ],\n        },\n        source: \"local\",\n        metadata: { source: \"clarinet\" },\n      };\n\n      const code = await generateActionHelpers(readOnlyContract, {});\n\n      expect(code).toContain(\"read: {\");\n      expect(code).not.toContain(\"write: {\");\n    });\n\n    it(\"should handle contracts with only public functions\", async () => {\n      const writeOnlyContract: ProcessedContract = {\n        name: \"writeOnlyContract\",\n        address: \"SP123\",\n        contractName: \"write-only\",\n        abi: {\n          functions: [\n            {\n              name: \"set-data\",\n              access: \"public\",\n              args: [{ name: \"value\", type: \"uint128\" }],\n              outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n            },\n          ],\n        },\n        source: \"local\",\n        metadata: { source: \"clarinet\" },\n      };\n\n      const code = await generateActionHelpers(writeOnlyContract, {});\n\n      expect(code).toContain(\"write: {\");\n      expect(code).not.toContain(\"read: {\");\n    });\n\n    it(\"should return empty string for contracts with no public or read-only functions\", async () => {\n      const emptyContract: ProcessedContract = {\n        name: \"emptyContract\",\n        address: \"SP123\",\n        contractName: \"empty\",\n        abi: {\n          functions: [\n            {\n              name: \"internal-function\",\n              access: \"private\",\n              args: [],\n              outputs: \"bool\",\n            },\n          ],\n        },\n        source: \"local\",\n        metadata: { source: \"clarinet\" },\n      };\n\n      const code = await generateActionHelpers(emptyContract, {});\n\n      expect(code).toBe(\"\");\n    });\n  });\n});",
    "packages/cli/tests/buffer-conversion.test.ts": "import { describe, it, expect } from \"vitest\";\nimport { generateContractInterface } from \"../src/generators/contract\";\nimport type { ResolvedContract } from \"../src/types/config\";\n\ndescribe(\"Buffer Conversion Enhancement\", () => {\n  const contractWithBuffer: ResolvedContract = {\n    name: \"mega\",\n    address: \"SP466FNC0P7JWTNM2R9T199QRZN1MYEDTAR0KP27\",\n    contractName: \"miamicoin-core-v1\",\n    abi: {\n      functions: [\n        {\n          name: \"callback\",\n          access: \"public\",\n          args: [\n            { name: \"sender\", type: \"principal\" },\n            { name: \"memo\", type: { buff: 34 } },\n          ],\n          outputs: {\n            response: {\n              ok: \"bool\",\n              error: \"uint128\",\n            },\n          },\n        },\n        {\n          name: \"store-data\",\n          access: \"public\",\n          args: [\n            { name: \"key\", type: { \"string-ascii\": 32 } },\n            { name: \"data\", type: { buff: 1024 } },\n          ],\n          outputs: {\n            response: {\n              ok: \"bool\",\n              error: \"uint128\",\n            },\n          },\n        },\n      ],\n    },\n    source: \"api\",\n  };\n\n  it(\"should generate flexible buffer conversion code\", async () => {\n    const code = await generateContractInterface([contractWithBuffer]);\n\n    // Should generate runtime conversion logic\n    expect(code).toContain(\"value instanceof Uint8Array\");\n    expect(code).toContain(\"Cl.bufferFromAscii\");\n    expect(code).toContain(\"Cl.bufferFromUtf8\");\n    expect(code).toContain(\"Cl.bufferFromHex\");\n    expect(code).toContain(\"value.startsWith('0x')\");\n  });\n\n  it(\"should handle different buffer input formats in generated code\", async () => {\n    const code = await generateContractInterface([contractWithBuffer]);\n\n    // Verify the code contains the logic for all supported formats\n    expect(code).toContain('case \"ascii\":');\n    expect(code).toContain('case \"utf8\":');\n    expect(code).toContain('case \"hex\":');\n    expect(code).toContain(\"throw new Error(`Invalid buffer value\");\n  });\n\n  it(\"should generate contract interface that accepts the flexible buffer types\", async () => {\n    const code = await generateContractInterface([contractWithBuffer]);\n\n    // The generated interface should allow these patterns:\n    // 1. mega.callback({ sender: \"SP...\", memo: \"Hello\" })\n    // 2. mega.callback({ sender: \"SP...\", memo: new Uint8Array([72, 101, 108, 108, 111]) })\n    // 3. mega.callback({ sender: \"SP...\", memo: { type: 'ascii', value: 'Hello' } })\n    // 4. mega.callback(\"SP...\", \"Hello\")\n\n    expect(code).toContain(\"callback(\");\n    expect(code).toContain(\"storeData(\");\n  });\n});",
    "packages/cli/tests/generator.test.ts": "import { describe, it, expect } from \"vitest\";\nimport { generateContractInterface } from \"../src/generators/contract\";\nimport type { ResolvedContract } from \"../src/types/config\";\n\ndescribe(\"Contract Generator\", () => {\n  const sampleContract: ResolvedContract = {\n    name: \"testContract\",\n    address: \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9\",\n    contractName: \"test-contract\",\n    abi: {\n      functions: [\n        {\n          name: \"transfer\",\n          access: \"public\",\n          args: [\n            { name: \"amount\", type: \"uint128\" },\n            { name: \"sender\", type: \"principal\" },\n            { name: \"recipient\", type: \"principal\" },\n          ],\n          outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n        },\n        {\n          name: \"get-balance\",\n          access: \"read-only\",\n          args: [{ name: \"account\", type: \"principal\" }],\n          outputs: \"uint128\",\n        },\n        {\n          name: \"get-info\",\n          access: \"read-only\",\n          args: [],\n          outputs: {\n            tuple: [\n              { name: \"total-supply\", type: \"uint128\" },\n              { name: \"name\", type: { \"string-ascii\": 32 } },\n            ],\n          },\n        },\n        {\n          name: \"internal-function\",\n          access: \"private\",\n          args: [],\n          outputs: \"bool\",\n        },\n      ],\n    },\n    source: \"api\",\n  };\n\n  describe(\"Basic Contract Generation\", () => {\n    it(\"should generate a contract interface with type-safe methods\", async () => {\n      const code = await generateContractInterface([sampleContract]);\n\n      // Check imports\n      expect(code).toContain(\n        \"import { Cl, validateStacksAddress } from '@stacks/transactions'\"\n      );\n\n      // Check contract generation\n      expect(code).toContain(\"export const testContract\");\n      expect(code).toContain(\n        \"address: 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9'\"\n      );\n      expect(code).toContain(\"contractName: 'test-contract'\");\n\n      // Check method generation\n      expect(code).toContain(\"transfer(\");\n      expect(code).toContain(\"getBalance(\");\n      expect(code).toContain(\"getInfo()\");\n\n      // Should not include private functions\n      expect(code).not.toContain(\"internalFunction\");\n\n      // Should generate ABI constant\n      expect(code).toContain(\"export const testContractAbi\");\n    });\n\n    it(\"should handle contracts with no arguments\", async () => {\n      const noArgsContract: ResolvedContract = {\n        name: \"simpleContract\",\n        address: \"SP123\",\n        contractName: \"simple\",\n        abi: {\n          functions: [\n            {\n              name: \"get-total\",\n              access: \"read-only\",\n              args: [],\n              outputs: \"uint128\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([noArgsContract]);\n\n      expect(code).toContain(\"getTotal() {\");\n      expect(code).toContain(\"functionArgs: []\");\n    });\n\n    it(\"should handle single argument functions with flexible syntax\", async () => {\n      const singleArgContract: ResolvedContract = {\n        name: \"singleArgContract\",\n        address: \"SP123\",\n        contractName: \"single-arg\",\n        abi: {\n          functions: [\n            {\n              name: \"get-user-balance\",\n              access: \"read-only\",\n              args: [{ name: \"user\", type: \"principal\" }],\n              outputs: \"uint128\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([singleArgContract]);\n\n      // Should support both object and direct argument syntax\n      expect(code).toContain(\"getUserBalance(...args:\");\n      expect(code).toContain(\"[{ user: string }] | [string]\");\n    });\n\n    it(\"should handle multiple contracts\", async () => {\n      const contract2: ResolvedContract = {\n        name: \"secondContract\",\n        address: \"SP456\",\n        contractName: \"second-contract\",\n        abi: {\n          functions: [\n            {\n              name: \"mint\",\n              access: \"public\",\n              args: [{ name: \"amount\", type: \"uint128\" }],\n              outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([sampleContract, contract2]);\n\n      expect(code).toContain(\"export const testContract\");\n      expect(code).toContain(\"export const secondContract\");\n      expect(code).toContain(\"export const testContractAbi\");\n      expect(code).toContain(\"export const secondContractAbi\");\n    });\n  });\n\n  describe(\"Type Conversion\", () => {\n    it(\"should generate correct TypeScript types for Clarity types\", async () => {\n      const typesContract: ResolvedContract = {\n        name: \"typesContract\",\n        address: \"SP123\",\n        contractName: \"types\",\n        abi: {\n          functions: [\n            {\n              name: \"test-types\",\n              access: \"public\",\n              args: [\n                { name: \"uint-val\", type: \"uint128\" },\n                { name: \"int-val\", type: \"int128\" },\n                { name: \"bool-val\", type: \"bool\" },\n                { name: \"principal-val\", type: \"principal\" },\n                { name: \"ascii-val\", type: { \"string-ascii\": 32 } },\n                { name: \"utf8-val\", type: { \"string-utf8\": 32 } },\n                { name: \"buffer-val\", type: { buff: 32 } },\n              ],\n              outputs: \"bool\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([typesContract]);\n\n      expect(code).toContain(\"uintVal: bigint\");\n      expect(code).toContain(\"intVal: bigint\");\n      expect(code).toContain(\"boolVal: boolean\");\n      expect(code).toContain(\"principalVal: string\");\n      expect(code).toContain(\"asciiVal: string\");\n      expect(code).toContain(\"utf8Val: string\");\n      // Biome formats union types across multiple lines\n      expect(code).toContain(\"bufferVal:\");\n      expect(code).toContain(\"Uint8Array\");\n      expect(code).toContain(\"value: string\");\n    });\n\n    it(\"should handle optional and list types\", async () => {\n      const complexTypesContract: ResolvedContract = {\n        name: \"complexContract\",\n        address: \"SP123\",\n        contractName: \"complex\",\n        abi: {\n          functions: [\n            {\n              name: \"complex-function\",\n              access: \"public\",\n              args: [\n                { name: \"optional-val\", type: { optional: \"uint128\" } },\n                {\n                  name: \"list-val\",\n                  type: { list: { type: \"uint128\", length: 10 } },\n                },\n              ],\n              outputs: \"bool\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([complexTypesContract]);\n\n      expect(code).toContain(\"optionalVal: bigint | null\");\n      expect(code).toContain(\"listVal: bigint[]\");\n    });\n  });\n\n  describe(\"Edge Cases\", () => {\n    it(\"should handle contracts with only read-only functions\", async () => {\n      const readOnlyContract: ResolvedContract = {\n        name: \"readOnlyContract\",\n        address: \"SP123\",\n        contractName: \"read-only\",\n        abi: {\n          functions: [\n            {\n              name: \"get-data\",\n              access: \"read-only\",\n              args: [{ name: \"id\", type: \"uint128\" }],\n              outputs: \"uint128\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([readOnlyContract]);\n\n      expect(code).toContain(\"getData(\");\n      expect(code).toContain(\"export const readOnlyContract\");\n    });\n\n    it(\"should handle contracts with only public functions\", async () => {\n      const writeOnlyContract: ResolvedContract = {\n        name: \"writeOnlyContract\",\n        address: \"SP123\",\n        contractName: \"write-only\",\n        abi: {\n          functions: [\n            {\n              name: \"set-data\",\n              access: \"public\",\n              args: [{ name: \"value\", type: \"uint128\" }],\n              outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([writeOnlyContract]);\n\n      expect(code).toContain(\"setData(\");\n      expect(code).toContain(\"export const writeOnlyContract\");\n    });\n\n    it(\"should handle empty contracts\", async () => {\n      const emptyContract: ResolvedContract = {\n        name: \"emptyContract\",\n        address: \"SP123\",\n        contractName: \"empty\",\n        abi: {\n          functions: [],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([emptyContract]);\n\n      expect(code).toContain(\"export const emptyContract\");\n      expect(code).toContain(\"export const emptyContractAbi\");\n    });\n\n    it(\"should sanitize function names with hyphens and numbers\", async () => {\n      const hyphenContract: ResolvedContract = {\n        name: \"hyphenContract\",\n        address: \"SP123\",\n        contractName: \"hyphen-test\",\n        abi: {\n          functions: [\n            {\n              name: \"test-function-1\",\n              access: \"public\",\n              args: [],\n              outputs: \"bool\",\n            },\n            {\n              name: \"testListOf-10\",\n              access: \"read-only\",\n              args: [\n                {\n                  name: \"input\",\n                  type: { list: { type: \"uint128\", length: 10 } },\n                },\n              ],\n              outputs: \"bool\",\n            },\n            {\n              name: \"get-user-DATA\",\n              access: \"read-only\",\n              args: [],\n              outputs: \"uint128\",\n            },\n            {\n              name: \"test-\",\n              access: \"read-only\",\n              args: [],\n              outputs: \"bool\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([hyphenContract]);\n\n      // Function names should be converted to valid JavaScript identifiers\n      expect(code).toContain(\"testFunction1(\"); // test-function-1 -> testFunction1\n      expect(code).toContain(\"testListOf10(\"); // testListOf-10 -> testListOf10\n      expect(code).toContain(\"getUserDATA(\"); // get-user-DATA -> getUserDATA\n      expect(code).toContain(\"test(\"); // test- -> test\n\n      // Should not contain any hyphens in method names\n      expect(code).not.toMatch(/\\w+-\\w+\\s*\\(/); // No hyphenated method names\n    });\n\n    it(\"should sanitize contract names with hyphens to camelCase\", async () => {\n      const hyphenatedNameContract: ResolvedContract = {\n        name: \"createRandom\", // This should be camelCase\n        address: \"SP123\",\n        contractName: \"create-random\",\n        abi: {\n          functions: [\n            {\n              name: \"get-random\",\n              access: \"read-only\",\n              args: [],\n              outputs: \"uint128\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const getTenureContract: ResolvedContract = {\n        name: \"getTenureForBlock\", // This should be camelCase\n        address: \"SP456\",\n        contractName: \"get-tenure-for-block\",\n        abi: {\n          functions: [\n            {\n              name: \"get-tenure\",\n              access: \"read-only\",\n              args: [],\n              outputs: \"uint128\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([\n        hyphenatedNameContract,\n        getTenureContract,\n      ]);\n\n      // Contract exports should use camelCase names\n      expect(code).toContain(\"export const createRandom =\");\n      expect(code).toContain(\"export const createRandomAbi =\");\n      expect(code).toContain(\"export const getTenureForBlock =\");\n      expect(code).toContain(\"export const getTenureForBlockAbi =\");\n\n      // Should not contain underscores in export names\n      expect(code).not.toContain(\"create_random\");\n      expect(code).not.toContain(\"get_tenure_for_block\");\n    });\n  });\n});",
    "packages/cli/tests/maps-variables.test.ts": "import { describe, it, expect } from \"vitest\";\nimport { generateContractInterface } from \"../src/generators/contract\";\nimport { generateContractHooks } from \"../src/plugins/react/generators/contract\";\nimport type { ResolvedContract } from \"../src/types/config\";\nimport type { ProcessedContract } from \"../src/types/plugin\";\n\ndescribe(\"Maps, Variables, and Constants Generation\", () => {\n  const contractWithState: ResolvedContract = {\n    name: \"tokenContract\",\n    address: \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9\",\n    contractName: \"token-contract\",\n    abi: {\n      functions: [\n        {\n          name: \"transfer\",\n          access: \"public\",\n          args: [\n            { name: \"amount\", type: \"uint128\" },\n            { name: \"recipient\", type: \"principal\" },\n          ],\n          outputs: { response: { ok: \"bool\", error: \"uint128\" } },\n        },\n        {\n          name: \"get-balance\",\n          access: \"read-only\",\n          args: [{ name: \"account\", type: \"principal\" }],\n          outputs: \"uint128\",\n        },\n      ],\n      maps: [\n        {\n          name: \"balances\",\n          key: \"principal\",\n          value: \"uint128\",\n        },\n        {\n          name: \"allowances\",\n          key: {\n            tuple: [\n              { name: \"owner\", type: \"principal\" },\n              { name: \"spender\", type: \"principal\" },\n            ],\n          },\n          value: \"uint128\",\n        },\n      ],\n      variables: [\n        {\n          name: \"total-supply\",\n          type: \"uint128\",\n          access: \"variable\",\n        },\n        {\n          name: \"token-name\",\n          type: { \"string-ascii\": { length: 32 } },\n          access: \"constant\",\n        },\n        {\n          name: \"token-decimals\",\n          type: \"uint128\",\n          access: \"constant\",\n        },\n        {\n          name: \"contract-owner\",\n          type: \"principal\",\n          access: \"variable\",\n        },\n      ],\n    },\n    source: \"api\",\n  };\n\n  describe(\"Contract Generator - Maps\", () => {\n    it(\"should generate maps object with typed get methods\", async () => {\n      const code = await generateContractInterface([contractWithState]);\n\n      // Should have maps object\n      expect(code).toContain(\"maps: {\");\n      expect(code).toContain(\"balances: {\");\n      expect(code).toContain(\"allowances: {\");\n\n      // Should have get method with key parameter\n      expect(code).toContain(\"key: string\");\n\n      // Should have network option parameter\n      expect(code).toContain(\"network?:\");\n    });\n\n    it(\"should generate proper tuple key types for maps\", async () => {\n      const code = await generateContractInterface([contractWithState]);\n\n      // Allowances map has tuple key\n      expect(code).toContain(\"owner: string\");\n      expect(code).toContain(\"spender: string\");\n    });\n\n    it(\"should generate API call for map entry\", async () => {\n      const code = await generateContractInterface([contractWithState]);\n\n      // Should use Hiro API endpoint for map entries\n      expect(code).toContain(\"/v2/map_entry/\");\n      expect(code).toContain(\"POST\");\n    });\n  });\n\n  describe(\"Contract Generator - Variables\", () => {\n    it(\"should generate vars object for data variables\", async () => {\n      const code = await generateContractInterface([contractWithState]);\n\n      // Should have vars object\n      expect(code).toContain(\"vars: {\");\n      expect(code).toContain(\"totalSupply: {\");\n      expect(code).toContain(\"contractOwner: {\");\n    });\n\n    it(\"should generate get method for variables\", async () => {\n      const code = await generateContractInterface([contractWithState]);\n\n      // Should have get method\n      expect(code).toContain(\"async get(\");\n      // Should use data_var endpoint\n      expect(code).toContain(\"/v2/data_var/\");\n    });\n  });\n\n  describe(\"Contract Generator - Constants\", () => {\n    it(\"should generate constants object\", async () => {\n      const code = await generateContractInterface([contractWithState]);\n\n      // Should have constants object\n      expect(code).toContain(\"constants: {\");\n      expect(code).toContain(\"tokenName: {\");\n      expect(code).toContain(\"tokenDecimals: {\");\n    });\n\n    it(\"should generate get method for constants\", async () => {\n      const code = await generateContractInterface([contractWithState]);\n\n      // Should use constant_val endpoint\n      expect(code).toContain(\"/v2/constant_val/\");\n    });\n  });\n\n  describe(\"Contract Generator - Edge Cases\", () => {\n    it(\"should handle contract with no maps or variables\", async () => {\n      const simpleContract: ResolvedContract = {\n        name: \"simpleContract\",\n        address: \"SP123\",\n        contractName: \"simple\",\n        abi: {\n          functions: [\n            {\n              name: \"get-data\",\n              access: \"read-only\",\n              args: [],\n              outputs: \"uint128\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([simpleContract]);\n\n      // Should not have maps/vars/constants if not defined\n      expect(code).not.toContain(\"maps: {\");\n      expect(code).not.toContain(\"vars: {\");\n      expect(code).not.toContain(\"constants: {\");\n    });\n\n    it(\"should handle contract with only maps\", async () => {\n      const mapsOnlyContract: ResolvedContract = {\n        name: \"mapsContract\",\n        address: \"SP123\",\n        contractName: \"maps-only\",\n        abi: {\n          functions: [],\n          maps: [\n            {\n              name: \"user-data\",\n              key: \"principal\",\n              value: \"uint128\",\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([mapsOnlyContract]);\n\n      expect(code).toContain(\"maps: {\");\n      expect(code).toContain(\"userData: {\");\n    });\n\n    it(\"should handle complex map value types\", async () => {\n      const complexMapContract: ResolvedContract = {\n        name: \"complexMap\",\n        address: \"SP123\",\n        contractName: \"complex-map\",\n        abi: {\n          functions: [],\n          maps: [\n            {\n              name: \"user-info\",\n              key: \"principal\",\n              value: {\n                tuple: [\n                  { name: \"balance\", type: \"uint128\" },\n                  { name: \"last-update\", type: \"uint128\" },\n                  { name: \"is-active\", type: \"bool\" },\n                ],\n              },\n            },\n          ],\n        },\n        source: \"api\",\n      };\n\n      const code = await generateContractInterface([complexMapContract]);\n\n      expect(code).toContain(\"maps: {\");\n      expect(code).toContain(\"userInfo: {\");\n    });\n  });\n\n  describe(\"React Plugin - Map Hooks\", () => {\n    const processedContract: ProcessedContract = {\n      name: \"tokenContract\",\n      address: \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9\",\n      contractName: \"token-contract\",\n      abi: {\n        functions: [\n          {\n            name: \"get-balance\",\n            access: \"read-only\",\n            args: [{ name: \"account\", type: \"principal\" }],\n            outputs: \"uint128\",\n          },\n        ],\n        maps: [\n          {\n            name: \"balances\",\n            key: \"principal\",\n            value: \"uint128\",\n          },\n        ],\n        variables: [\n          {\n            name: \"total-supply\",\n            type: \"uint128\",\n            access: \"variable\",\n          },\n          {\n            name: \"token-name\",\n            type: { \"string-ascii\": { length: 32 } },\n            access: \"constant\",\n          },\n        ],\n      },\n    };\n\n    it(\"should generate map hooks with correct names\", async () => {\n      const code = await generateContractHooks([processedContract]);\n\n      expect(code).toContain(\"useTokenContractBalances\");\n      expect(code).toContain(\"export function useTokenContractBalances(\");\n    });\n\n    it(\"should generate map hooks with key parameter\", async () => {\n      const code = await generateContractHooks([processedContract]);\n\n      // Map hook should accept key parameter\n      expect(code).toContain(\"key: string\");\n    });\n\n    it(\"should generate map hooks with useQuery\", async () => {\n      const code = await generateContractHooks([processedContract]);\n\n      expect(code).toContain(\"useQuery\");\n      expect(code).toContain(\"queryKey:\");\n    });\n\n    it(\"should generate variable hooks\", async () => {\n      const code = await generateContractHooks([processedContract]);\n\n      expect(code).toContain(\"useTokenContractTotalSupply\");\n      expect(code).toContain(\"export function useTokenContractTotalSupply(\");\n    });\n\n    it(\"should generate constant hooks with staleTime Infinity\", async () => {\n      const code = await generateContractHooks([processedContract]);\n\n      expect(code).toContain(\"useTokenContractTokenName\");\n      // Biome converts Infinity to Number.POSITIVE_INFINITY\n      expect(code).toMatch(/staleTime:\\s*(Infinity|Number\\.POSITIVE_INFINITY)/);\n    });\n\n    it(\"should not generate hooks for excluded names\", async () => {\n      const code = await generateContractHooks([processedContract], [\n        \"useTokenContractBalances\",\n      ]);\n\n      expect(code).not.toContain(\"useTokenContractBalances\");\n      // Other hooks should still be generated\n      expect(code).toContain(\"useTokenContractTotalSupply\");\n    });\n  });\n\n  describe(\"React Plugin - Return Types\", () => {\n    it(\"should generate correct return type for map hooks\", async () => {\n      const processedContract: ProcessedContract = {\n        name: \"typedContract\",\n        address: \"SP123\",\n        contractName: \"typed\",\n        abi: {\n          functions: [],\n          maps: [\n            {\n              name: \"scores\",\n              key: \"principal\",\n              value: \"uint128\",\n            },\n          ],\n        },\n      };\n\n      const code = await generateContractHooks([processedContract]);\n\n      // Map hooks return nullable value type\n      expect(code).toContain(\"useQuery<bigint | null>\");\n    });\n\n    it(\"should generate correct return type for variable hooks\", async () => {\n      const processedContract: ProcessedContract = {\n        name: \"typedContract\",\n        address: \"SP123\",\n        contractName: \"typed\",\n        abi: {\n          functions: [],\n          variables: [\n            {\n              name: \"counter\",\n              type: \"uint128\",\n              access: \"variable\",\n            },\n          ],\n        },\n      };\n\n      const code = await generateContractHooks([processedContract]);\n\n      expect(code).toContain(\"useQuery<bigint>\");\n    });\n\n    it(\"should generate correct tuple return type for complex maps\", async () => {\n      const processedContract: ProcessedContract = {\n        name: \"complexContract\",\n        address: \"SP123\",\n        contractName: \"complex\",\n        abi: {\n          functions: [],\n          maps: [\n            {\n              name: \"user-data\",\n              key: \"principal\",\n              value: {\n                tuple: [\n                  { name: \"balance\", type: \"uint128\" },\n                  { name: \"is-active\", type: \"bool\" },\n                ],\n              },\n            },\n          ],\n        },\n      };\n\n      const code = await generateContractHooks([processedContract]);\n\n      // Should have typed tuple return\n      expect(code).toContain(\"balance: bigint\");\n      expect(code).toContain(\"isActive: boolean\");\n    });\n  });\n});",
    "packages/cli/tests/type-safety.test.ts": "import { describe, it, expect } from \"vitest\";\nimport { clarityTypeToTS } from \"../src/plugins/react/generators/utils\";\n\ndescribe(\"Type Safety - clarityTypeToTS\", () => {\n  describe(\"Primitive Types\", () => {\n    it(\"handles uint128 type\", () => {\n      expect(clarityTypeToTS(\"uint128\")).toBe(\"bigint\");\n    });\n\n    it(\"handles int128 type\", () => {\n      expect(clarityTypeToTS(\"int128\")).toBe(\"bigint\");\n    });\n\n    it(\"handles principal type\", () => {\n      expect(clarityTypeToTS(\"principal\")).toBe(\"string\");\n    });\n\n    it(\"handles bool type\", () => {\n      expect(clarityTypeToTS(\"bool\")).toBe(\"boolean\");\n    });\n\n    it(\"handles string types\", () => {\n      expect(clarityTypeToTS(\"string-ascii\")).toBe(\"string\");\n      expect(clarityTypeToTS(\"string-utf8\")).toBe(\"string\");\n      expect(clarityTypeToTS({ \"string-ascii\": { length: 100 } })).toBe(\"string\");\n      expect(clarityTypeToTS({ \"string-utf8\": { length: 100 } })).toBe(\"string\");\n    });\n\n    it(\"handles buffer type\", () => {\n      // Shorthand string format\n      expect(clarityTypeToTS(\"buff\")).toBe(\"Uint8Array | string | { type: 'ascii' | 'utf8' | 'hex'; value: string }\");\n      // Full object format from ABI\n      expect(clarityTypeToTS({ buff: { length: 32 } })).toBe(\"Uint8Array | string | { type: 'ascii' | 'utf8' | 'hex'; value: string }\");\n    });\n  });\n\n  describe(\"Response Types\", () => {\n    it(\"handles simple response types\", () => {\n      const responseType = {\n        response: {\n          ok: \"uint128\",\n          error: \"uint128\",\n        },\n      };\n\n      expect(clarityTypeToTS(responseType)).toBe(\n        \"{ ok: bigint } | { err: bigint }\"\n      );\n    });\n\n    it(\"handles response with bool ok type\", () => {\n      const responseType = {\n        response: {\n          ok: \"bool\",\n          error: \"uint128\",\n        },\n      };\n\n      expect(clarityTypeToTS(responseType)).toBe(\n        \"{ ok: boolean } | { err: bigint }\"\n      );\n    });\n\n    it(\"handles nested response types with tuple ok\", () => {\n      const responseType = {\n        response: {\n          ok: {\n            tuple: [\n              { name: \"balance\", type: \"uint128\" },\n              { name: \"owner\", type: \"principal\" },\n            ],\n          },\n          error: \"uint128\",\n        },\n      };\n\n      expect(clarityTypeToTS(responseType)).toBe(\n        \"{ ok: { balance: bigint; owner: string } } | { err: bigint }\"\n      );\n    });\n  });\n\n  describe(\"Tuple Types\", () => {\n    it(\"handles simple tuple types\", () => {\n      const tupleType = {\n        tuple: [\n          { name: \"owner\", type: \"principal\" },\n          { name: \"amount\", type: \"uint128\" },\n        ],\n      };\n\n      expect(clarityTypeToTS(tupleType)).toBe(\n        \"{ owner: string; amount: bigint }\"\n      );\n    });\n\n    it(\"handles tuple with hyphenated names (converts to camelCase)\", () => {\n      const tupleType = {\n        tuple: [\n          { name: \"total-supply\", type: \"uint128\" },\n          { name: \"token-name\", type: { \"string-ascii\": { length: 32 } } },\n        ],\n      };\n\n      expect(clarityTypeToTS(tupleType)).toBe(\n        \"{ totalSupply: bigint; tokenName: string }\"\n      );\n    });\n\n    it(\"handles nested tuples\", () => {\n      const tupleType = {\n        tuple: [\n          { name: \"id\", type: \"uint128\" },\n          {\n            name: \"metadata\",\n            type: {\n              tuple: [\n                { name: \"name\", type: { \"string-utf8\": { length: 50 } } },\n                { name: \"value\", type: \"uint128\" },\n              ],\n            },\n          },\n        ],\n      };\n\n      expect(clarityTypeToTS(tupleType)).toBe(\n        \"{ id: bigint; metadata: { name: string; value: bigint } }\"\n      );\n    });\n  });\n\n  describe(\"List Types\", () => {\n    it(\"handles simple list types\", () => {\n      const listType = {\n        list: {\n          type: \"uint128\",\n          length: 100,\n        },\n      };\n\n      expect(clarityTypeToTS(listType)).toBe(\"bigint[]\");\n    });\n\n    it(\"handles list of principals\", () => {\n      const listType = {\n        list: {\n          type: \"principal\",\n          length: 50,\n        },\n      };\n\n      expect(clarityTypeToTS(listType)).toBe(\"string[]\");\n    });\n\n    it(\"handles list of tuples\", () => {\n      const listType = {\n        list: {\n          type: {\n            tuple: [\n              { name: \"id\", type: \"uint128\" },\n              { name: \"owner\", type: \"principal\" },\n            ],\n          },\n          length: 10,\n        },\n      };\n\n      expect(clarityTypeToTS(listType)).toBe(\n        \"{ id: bigint; owner: string }[]\"\n      );\n    });\n  });\n\n  describe(\"Optional Types\", () => {\n    it(\"handles optional primitive types\", () => {\n      const optionalType = {\n        optional: \"uint128\",\n      };\n\n      expect(clarityTypeToTS(optionalType)).toBe(\"bigint | null\");\n    });\n\n    it(\"handles optional tuple types\", () => {\n      const optionalType = {\n        optional: {\n          tuple: [\n            { name: \"balance\", type: \"uint128\" },\n            { name: \"locked\", type: \"bool\" },\n          ],\n        },\n      };\n\n      expect(clarityTypeToTS(optionalType)).toBe(\n        \"{ balance: bigint; locked: boolean } | null\"\n      );\n    });\n  });\n\n  describe(\"Complex Nested Types\", () => {\n    it(\"handles deeply nested types\", () => {\n      const complexType = {\n        response: {\n          ok: {\n            list: {\n              type: {\n                tuple: [\n                  { name: \"id\", type: \"uint128\" },\n                  { name: \"owner\", type: \"principal\" },\n                ],\n              },\n              length: 50,\n            },\n          },\n          error: \"uint128\",\n        },\n      };\n\n      expect(clarityTypeToTS(complexType)).toBe(\n        \"{ ok: { id: bigint; owner: string }[] } | { err: bigint }\"\n      );\n    });\n\n    it(\"handles response with optional in tuple\", () => {\n      const complexType = {\n        response: {\n          ok: {\n            tuple: [\n              { name: \"amount\", type: \"uint128\" },\n              { name: \"memo\", type: { optional: { \"string-utf8\": { length: 100 } } } },\n            ],\n          },\n          error: \"uint128\",\n        },\n      };\n\n      expect(clarityTypeToTS(complexType)).toBe(\n        \"{ ok: { amount: bigint; memo: string | null } } | { err: bigint }\"\n      );\n    });\n\n    it(\"handles list of optionals\", () => {\n      const listType = {\n        list: {\n          type: {\n            optional: \"principal\",\n          },\n          length: 20,\n        },\n      };\n\n      expect(clarityTypeToTS(listType)).toBe(\"(string | null)[]\");\n    });\n  });\n\n  describe(\"Edge Cases\", () => {\n    it(\"returns any for unknown types\", () => {\n      expect(clarityTypeToTS(\"unknown-type\")).toBe(\"any\");\n      expect(clarityTypeToTS({ unknownProperty: true })).toBe(\"any\");\n    });\n\n    it(\"handles empty tuple\", () => {\n      const emptyTuple = {\n        tuple: [],\n      };\n\n      expect(clarityTypeToTS(emptyTuple)).toBe(\"{  }\");\n    });\n  });\n});",
    ".gitignore": "# Dependencies\nnode_modules/\nbun.lockb\n\n# Build output\ndist/\n*.tsbuildinfo\n\n# Generated files (for examples)\nexamples/generated/\n\n# IDE\n.vscode/\n.idea/\n*.swp\n*.swo\n*~\n\n# OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Test coverage\ncoverage/\n.nyc_output/\n\n# Environment variables\n.env\n.env.local\n.env.*.local\n\n# Temporary files\n*.tmp\n*.temp\ndocs/\n\n# Config files (users should create their own)\nsecondlayer.config.ts\nsecondlayer.config.js\nsecondlayer.config.mjs",
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\"],\n    \"moduleResolution\": \"bundler\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"allowImportingTsExtensions\": true,\n    \"noEmit\": true\n  }\n}",
    "packages/clarity-types/src/abi/extractors.ts": "import type { ClarityContract, FunctionAccess, VariableAccess } from \"./functions\";\nimport type { ClarityToTS } from \"../types/mappings\";\nimport type { ClarityType } from \"../types/composites\";\nimport type { ToCamelCase } from \"../utils\";\n\n/**\n * Type extraction utilities for contract ABIs\n */\n\nexport type ExtractFunctionNames<\n  C extends ClarityContract,\n  Access extends FunctionAccess = FunctionAccess\n> = Extract<C[\"functions\"][number], { access: Access }>[\"name\"];\n\nexport type ExtractFunction<\n  C extends ClarityContract,\n  N extends ExtractFunctionNames<C>\n> = Extract<C[\"functions\"][number], { name: N }>;\n\nexport type ExtractFunctionArgs<\n  C extends ClarityContract,\n  N extends ExtractFunctionNames<C>\n> = ExtractFunction<C, N> extends {\n  args: infer Args extends ReadonlyArray<{ name: string; type: any }>;\n}\n  ? {\n      [K in Args[number][\"name\"] as ToCamelCase<K>]: ClarityToTS<\n        Extract<Args[number], { name: K }>[\"type\"]\n      >;\n    }\n  : never;\n\nexport type ExtractFunctionArgsTuple<\n  C extends ClarityContract,\n  N extends ExtractFunctionNames<C>\n> = ExtractFunction<C, N> extends {\n  args: infer Args extends ReadonlyArray<{ type: any }>;\n}\n  ? {\n      [K in keyof Args]: Args[K] extends { type: infer T extends ClarityType }\n        ? ClarityToTS<T>\n        : never;\n    }\n  : never;\n\nexport type ExtractFunctionOutput<\n  C extends ClarityContract,\n  N extends ExtractFunctionNames<C>\n> = ExtractFunction<C, N> extends { outputs: infer O extends ClarityType }\n  ? ClarityToTS<O>\n  : never;\n\nexport type ExtractPublicFunctions<C extends ClarityContract> =\n  ExtractFunctionNames<C, \"public\">;\n\nexport type ExtractReadOnlyFunctions<C extends ClarityContract> =\n  ExtractFunctionNames<C, \"read-only\">;\n\n// ============================================================================\n// Private Functions Extractor\n// ============================================================================\n\nexport type ExtractPrivateFunctions<C extends ClarityContract> =\n  ExtractFunctionNames<C, \"private\">;\n\n// ============================================================================\n// Map Extractors\n// ============================================================================\n\nexport type ExtractMapNames<C extends ClarityContract> =\n  C[\"maps\"] extends ReadonlyArray<{ name: infer N extends string }>\n    ? N\n    : never;\n\nexport type ExtractMap<\n  C extends ClarityContract,\n  N extends ExtractMapNames<C>\n> = C[\"maps\"] extends ReadonlyArray<infer M>\n  ? Extract<M, { name: N }>\n  : never;\n\nexport type ExtractMapKey<\n  C extends ClarityContract,\n  N extends ExtractMapNames<C>\n> = ExtractMap<C, N> extends { key: infer K extends ClarityType }\n  ? ClarityToTS<K>\n  : never;\n\nexport type ExtractMapValue<\n  C extends ClarityContract,\n  N extends ExtractMapNames<C>\n> = ExtractMap<C, N> extends { value: infer V extends ClarityType }\n  ? ClarityToTS<V>\n  : never;\n\n// ============================================================================\n// Variable Extractors\n// ============================================================================\n\nexport type ExtractVariableNames<\n  C extends ClarityContract,\n  Access extends VariableAccess = VariableAccess\n> = C[\"variables\"] extends ReadonlyArray<infer V>\n  ? V extends { name: infer N extends string; access: Access }\n    ? N\n    : never\n  : never;\n\nexport type ExtractVariable<\n  C extends ClarityContract,\n  N extends ExtractVariableNames<C>\n> = C[\"variables\"] extends ReadonlyArray<infer V>\n  ? Extract<V, { name: N }>\n  : never;\n\nexport type ExtractVariableType<\n  C extends ClarityContract,\n  N extends ExtractVariableNames<C>\n> = ExtractVariable<C, N> extends { type: infer T extends ClarityType }\n  ? ClarityToTS<T>\n  : never;\n\nexport type ExtractConstants<C extends ClarityContract> =\n  ExtractVariableNames<C, \"constant\">;\n\nexport type ExtractDataVars<C extends ClarityContract> =\n  ExtractVariableNames<C, \"variable\">;\n\n// ============================================================================\n// Token Extractors\n// ============================================================================\n\nexport type ExtractFungibleTokenNames<C extends ClarityContract> =\n  C[\"fungible_tokens\"] extends ReadonlyArray<{ name: infer N extends string }>\n    ? N\n    : never;\n\nexport type ExtractNonFungibleTokenNames<C extends ClarityContract> =\n  C[\"non_fungible_tokens\"] extends ReadonlyArray<{ name: infer N extends string }>\n    ? N\n    : never;\n\nexport type ExtractNFTAssetType<\n  C extends ClarityContract,\n  N extends ExtractNonFungibleTokenNames<C>\n> = C[\"non_fungible_tokens\"] extends ReadonlyArray<infer T>\n  ? Extract<T, { name: N }> extends { type: infer A extends ClarityType }\n    ? ClarityToTS<A>\n    : never\n  : never;\n\n// ============================================================================\n// Trait Extractors\n// ============================================================================\n\nexport type ExtractDefinedTraitNames<C extends ClarityContract> =\n  C[\"defined_traits\"] extends ReadonlyArray<{ name: infer N extends string }>\n    ? N\n    : never;\n\nexport type ExtractImplementedTraits<C extends ClarityContract> =\n  C[\"implemented_traits\"] extends ReadonlyArray<infer T extends string>\n    ? T\n    : never;",
    "packages/clarity-types/src/abi/functions.ts": "import type { ClarityType } from \"../types/composites\";\n\n/**\n * Contract function definitions\n */\n\nexport type FunctionAccess = \"public\" | \"read-only\" | \"private\";\n\nexport interface FunctionArg {\n  name: string;\n  type: ClarityType;\n}\n\nexport interface ClarityFunction {\n  name: string;\n  access: FunctionAccess;\n  args: ReadonlyArray<FunctionArg>;\n  outputs: ClarityType;\n}\n\n/**\n * Clarity data variable definition\n */\nexport type VariableAccess = \"constant\" | \"variable\";\n\nexport interface ClarityVariable {\n  name: string;\n  type: ClarityType;\n  access: VariableAccess;\n}\n\n/**\n * Clarity data map definition\n */\nexport interface ClarityMap {\n  name: string;\n  key: ClarityType;\n  value: ClarityType;\n}\n\n/**\n * Clarity fungible token definition (define-fungible-token)\n */\nexport interface ClarityFungibleToken {\n  name: string;\n}\n\n/**\n * Clarity non-fungible token definition (define-non-fungible-token)\n */\nexport interface ClarityNonFungibleToken {\n  name: string;\n  type: ClarityType;\n}\n\n/**\n * Trait function signature (used in define-trait)\n */\nexport interface ClarityTraitFunction {\n  name: string;\n  access: \"public\" | \"read-only\";\n  args: ReadonlyArray<FunctionArg>;\n  outputs: ClarityType;\n}\n\n/**\n * Clarity trait definition (define-trait)\n */\nexport interface ClarityTraitDefinition {\n  name: string;\n  functions: ReadonlyArray<ClarityTraitFunction>;\n}\n\nexport interface ClarityContract {\n  functions: ReadonlyArray<ClarityFunction>;\n  maps?: ReadonlyArray<ClarityMap>;\n  variables?: ReadonlyArray<ClarityVariable>;\n  fungible_tokens?: ReadonlyArray<ClarityFungibleToken>;\n  non_fungible_tokens?: ReadonlyArray<ClarityNonFungibleToken>;\n  implemented_traits?: ReadonlyArray<string>;\n  defined_traits?: ReadonlyArray<ClarityTraitDefinition>;\n}\n\n// Helper type to ensure const assertion\nexport type AsConst<T> = T extends ClarityContract ? T : never;",
    "packages/clarity-types/src/converters/index.ts": "import type { ClarityType } from \"../types/composites\";\nimport type { ClarityFunction } from \"../abi/functions\";\nimport {\n  isUint128,\n  isInt128,\n  isBool,\n  isPrincipal,\n  isString,\n  isUint8Array,\n  isClarityList,\n  isClarityTuple,\n  isClarityOptional,\n  isClarityResponse,\n  isClarityBuffer,\n  isClarityStringAscii,\n  isClarityStringUtf8,\n} from \"../validation/guards\";\nimport { toCamelCase } from \"../utils\";\n\n/**\n * Value converters between JavaScript and Clarity representations\n */\n\nexport class ClarityConversionError extends Error {\n  constructor(\n    message: string,\n    public readonly type: ClarityType,\n    public readonly value: unknown\n  ) {\n    super(message);\n    this.name = \"ClarityConversionError\";\n  }\n}\n\n/**\n * Convert and validate JS value to Clarity value.\n * Performs full recursive validation for all Clarity types including composites.\n */\nexport function jsToClarity(type: ClarityType, value: unknown): unknown {\n  // Primitive types\n  if (type === \"uint128\") {\n    if (!isUint128(value)) {\n      throw new ClarityConversionError(\"Invalid uint128 value\", type, value);\n    }\n    return value;\n  }\n\n  if (type === \"int128\") {\n    if (!isInt128(value)) {\n      throw new ClarityConversionError(\"Invalid int128 value\", type, value);\n    }\n    return value;\n  }\n\n  if (type === \"bool\") {\n    if (!isBool(value)) {\n      throw new ClarityConversionError(\"Invalid bool value\", type, value);\n    }\n    return value;\n  }\n\n  if (type === \"principal\") {\n    if (!isPrincipal(value)) {\n      throw new ClarityConversionError(\"Invalid principal value\", type, value);\n    }\n    return value;\n  }\n\n  if (type === \"trait_reference\") {\n    if (!isPrincipal(value)) {\n      throw new ClarityConversionError(\n        \"Invalid trait_reference value\",\n        type,\n        value\n      );\n    }\n    return value;\n  }\n\n  // String types with length validation\n  if (isClarityStringAscii(type)) {\n    if (!isString(value)) {\n      throw new ClarityConversionError(\n        \"Invalid string-ascii value\",\n        type,\n        value\n      );\n    }\n    const str = value as string;\n\n    // Validate ASCII only (0x00-0x7F)\n    for (let i = 0; i < str.length; i++) {\n      if (str.charCodeAt(i) > 127) {\n        throw new ClarityConversionError(\n          `Non-ASCII character at position ${i}: '${str[i]}' (code ${str.charCodeAt(i)})`,\n          type,\n          value\n        );\n      }\n    }\n\n    if (str.length > type[\"string-ascii\"].length) {\n      throw new ClarityConversionError(\n        `String length ${str.length} exceeds max ${type[\"string-ascii\"].length}`,\n        type,\n        value\n      );\n    }\n    return value;\n  }\n\n  if (isClarityStringUtf8(type)) {\n    if (!isString(value)) {\n      throw new ClarityConversionError(\n        \"Invalid string-utf8 value\",\n        type,\n        value\n      );\n    }\n    const str = value as string;\n    const byteLength = new TextEncoder().encode(str).length;\n    if (byteLength > type[\"string-utf8\"].length) {\n      throw new ClarityConversionError(\n        `String byte length ${byteLength} exceeds max ${type[\"string-utf8\"].length}`,\n        type,\n        value\n      );\n    }\n    return value;\n  }\n\n  // Buffer type with length validation\n  if (isClarityBuffer(type)) {\n    if (!isUint8Array(value)) {\n      throw new ClarityConversionError(\"Invalid buffer value\", type, value);\n    }\n    const buff = value as Uint8Array;\n    if (buff.length > type.buff.length) {\n      throw new ClarityConversionError(\n        `Buffer length ${buff.length} exceeds max ${type.buff.length}`,\n        type,\n        value\n      );\n    }\n    return value;\n  }\n\n  // List type with length enforcement and recursive element validation\n  if (isClarityList(type)) {\n    if (!Array.isArray(value)) {\n      throw new ClarityConversionError(\n        \"Expected array for list type\",\n        type,\n        value\n      );\n    }\n    if (value.length > type.list.length) {\n      throw new ClarityConversionError(\n        `List length ${value.length} exceeds max ${type.list.length}`,\n        type,\n        value\n      );\n    }\n    return value.map((item) => jsToClarity(type.list.type, item));\n  }\n\n  // Tuple type with field validation\n  if (isClarityTuple(type)) {\n    if (typeof value !== \"object\" || value === null) {\n      throw new ClarityConversionError(\n        \"Expected object for tuple type\",\n        type,\n        value\n      );\n    }\n    const result: Record<string, unknown> = {};\n    for (const field of type.tuple) {\n      const camelKey = toCamelCase(field.name);\n      // Check both original and camelCase keys for flexibility\n      const hasOriginal = field.name in (value as object);\n      const hasCamel = camelKey in (value as object);\n      if (!hasOriginal && !hasCamel) {\n        throw new ClarityConversionError(\n          `Missing tuple field: ${field.name}`,\n          type,\n          value\n        );\n      }\n      const fieldValue = hasOriginal\n        ? (value as Record<string, unknown>)[field.name]\n        : (value as Record<string, unknown>)[camelKey];\n      result[field.name] = jsToClarity(field.type, fieldValue);\n    }\n    return result;\n  }\n\n  // Optional type - null/undefined means none\n  if (isClarityOptional(type)) {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    return jsToClarity(type.optional, value);\n  }\n\n  // Response type - must have exactly 'ok' or 'err'\n  if (isClarityResponse(type)) {\n    if (typeof value !== \"object\" || value === null) {\n      throw new ClarityConversionError(\n        \"Expected object for response type\",\n        type,\n        value\n      );\n    }\n    const hasOk = \"ok\" in value;\n    const hasErr = \"err\" in value;\n\n    if (hasOk && !hasErr) {\n      return { ok: jsToClarity(type.response.ok, (value as { ok: unknown }).ok) };\n    }\n    if (hasErr && !hasOk) {\n      return {\n        err: jsToClarity(type.response.error, (value as { err: unknown }).err),\n      };\n    }\n    throw new ClarityConversionError(\n      \"Response must have exactly 'ok' or 'err' property\",\n      type,\n      value\n    );\n  }\n\n  throw new ClarityConversionError(`Unknown Clarity type`, type, value);\n}\n\n// Helper to prepare function arguments\nexport function prepareArgs<F extends ClarityFunction>(\n  func: F,\n  args: Record<string, unknown>\n): unknown[] {\n  return func.args.map((arg) => {\n    if (!(arg.name in args)) {\n      throw new Error(`Missing argument: ${arg.name}`);\n    }\n    return jsToClarity(arg.type, args[arg.name]);\n  });\n}\n\n// Helper to validate function arguments (named)\nexport function validateArgs<F extends ClarityFunction>(\n  func: F,\n  args: Record<string, unknown>\n): void {\n  for (const arg of func.args) {\n    if (!(arg.name in args)) {\n      throw new Error(`Missing argument: ${arg.name}`);\n    }\n    jsToClarity(arg.type, args[arg.name]);\n  }\n}\n\n// Helper to validate function arguments (positional)\nexport function validateArgsArray<F extends ClarityFunction>(\n  func: F,\n  args: unknown[]\n): void {\n  if (args.length !== func.args.length) {\n    throw new Error(\n      `Expected ${func.args.length} arguments, got ${args.length}`\n    );\n  }\n\n  func.args.forEach((arg, i) => {\n    jsToClarity(arg.type, args[i]);\n  });\n}",
    "packages/clarity-types/src/validation/guards.ts": "import { validateStacksAddress } from \"@stacks/transactions\";\nimport {\n  MAX_U128,\n  MIN_I128,\n  MAX_I128,\n  CONTRACT_NAME_REGEX,\n} from \"../types/primitives\";\nimport type { ResponseOk, ResponseErr } from \"../types/mappings\";\n\n/**\n * Runtime type guards for Clarity values\n */\n\nexport function isUint128(value: unknown): value is bigint {\n  return typeof value === \"bigint\" && value >= 0n && value <= MAX_U128;\n}\n\nexport function isInt128(value: unknown): value is bigint {\n  return typeof value === \"bigint\" && value >= MIN_I128 && value <= MAX_I128;\n}\n\nexport function isBool(value: unknown): value is boolean {\n  return typeof value === \"boolean\";\n}\n\n/**\n * Validates a Stacks principal (standard or contract) using upstream validation.\n * Supports mainnet (SP), testnet (ST), and other network prefixes with proper checksum validation.\n */\nexport function isPrincipal(value: unknown): value is string {\n  if (typeof value !== \"string\") return false;\n  const [address, contractName] = value.split(\".\");\n  if (!validateStacksAddress(address)) return false;\n  // If there's a contract name part, validate it\n  if (contractName !== undefined) {\n    return CONTRACT_NAME_REGEX.test(contractName);\n  }\n  return true;\n}\n\n/**\n * Validates a standard Stacks principal (address only, no contract).\n * Supports mainnet (SP), testnet (ST), and other network prefixes.\n */\nexport function isStandardPrincipal(value: unknown): value is string {\n  if (typeof value !== \"string\") return false;\n  if (value.includes(\".\")) return false;\n  return validateStacksAddress(value);\n}\n\n/**\n * Validates a contract principal (address.contract-name format).\n * Uses upstream address validation with contract name regex validation.\n */\nexport function isContractPrincipal(value: unknown): value is string {\n  if (typeof value !== \"string\") return false;\n  if (!value.includes(\".\")) return false;\n  const [address, contractName] = value.split(\".\");\n  if (!validateStacksAddress(address)) return false;\n  return CONTRACT_NAME_REGEX.test(contractName);\n}\n\n/**\n * Validates a trait reference (contract principal pointing to a trait).\n * Trait references are contract principals - the trait itself is identified\n * by context (function parameter type).\n */\nexport function isTraitReference(value: unknown): value is string {\n  return isContractPrincipal(value);\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isUint8Array(value: unknown): value is Uint8Array {\n  return value instanceof Uint8Array;\n}\n\nexport function isArray<T>(\n  value: unknown,\n  itemGuard: (item: unknown) => item is T\n): value is T[] {\n  return Array.isArray(value) && value.every(itemGuard);\n}\n\nexport function isOptional<T>(\n  value: unknown,\n  guard: (val: unknown) => val is T\n): value is T | null {\n  return value === null || guard(value);\n}\n\nexport function isOkResponse<T>(\n  response: { ok: T } | { err: any }\n): response is ResponseOk<T> {\n  return \"ok\" in response && !(\"err\" in response);\n}\n\nexport function isErrResponse<E>(\n  response: { ok: any } | { err: E }\n): response is ResponseErr<E> {\n  return \"err\" in response && !(\"ok\" in response);\n}\n\nexport function isResponse<T, E>(\n  value: unknown,\n  okGuard: (val: unknown) => val is T,\n  errGuard: (val: unknown) => val is E\n): value is ResponseOk<T> | ResponseErr<E> {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  if (\"ok\" in value && !(\"err\" in value)) {\n    return okGuard((value as any).ok);\n  }\n\n  if (\"err\" in value && !(\"ok\" in value)) {\n    return errGuard((value as any).err);\n  }\n\n  return false;\n}\n\n// ============================================================================\n// Clarity ABI Type Guards\n// These guards check if a Clarity type definition is of a specific composite type\n// ============================================================================\n\nimport type {\n  ClarityType,\n  ClarityListType,\n  ClarityTupleType,\n  ClarityOptionalType,\n  ClarityResponseType,\n} from \"../types/composites\";\nimport type {\n  ClarityBuffer,\n  ClarityStringAscii,\n  ClarityStringUtf8,\n  ClarityTraitReference,\n} from \"../types/primitives\";\n\n/**\n * Type guard for Clarity list type definitions\n */\nexport function isClarityList(type: ClarityType): type is ClarityListType {\n  return typeof type === \"object\" && type !== null && \"list\" in type;\n}\n\n/**\n * Type guard for Clarity tuple type definitions\n */\nexport function isClarityTuple(type: ClarityType): type is ClarityTupleType {\n  return typeof type === \"object\" && type !== null && \"tuple\" in type;\n}\n\n/**\n * Type guard for Clarity optional type definitions\n */\nexport function isClarityOptional(\n  type: ClarityType\n): type is ClarityOptionalType {\n  return typeof type === \"object\" && type !== null && \"optional\" in type;\n}\n\n/**\n * Type guard for Clarity response type definitions\n */\nexport function isClarityResponse(\n  type: ClarityType\n): type is ClarityResponseType {\n  return typeof type === \"object\" && type !== null && \"response\" in type;\n}\n\n/**\n * Type guard for Clarity buffer type definitions\n */\nexport function isClarityBuffer(type: ClarityType): type is ClarityBuffer {\n  return typeof type === \"object\" && type !== null && \"buff\" in type;\n}\n\n/**\n * Type guard for Clarity string-ascii type definitions\n */\nexport function isClarityStringAscii(\n  type: ClarityType\n): type is ClarityStringAscii {\n  return typeof type === \"object\" && type !== null && \"string-ascii\" in type;\n}\n\n/**\n * Type guard for Clarity string-utf8 type definitions\n */\nexport function isClarityStringUtf8(\n  type: ClarityType\n): type is ClarityStringUtf8 {\n  return typeof type === \"object\" && type !== null && \"string-utf8\" in type;\n}\n\n/**\n * Type guard for Clarity trait_reference type definitions\n */\nexport function isClarityTraitReference(\n  type: ClarityType\n): type is ClarityTraitReference {\n  return type === \"trait_reference\";\n}",
    "packages/clarity-types/tests/runtime.test.ts": "import { describe, it, expect } from \"vitest\";\nimport {\n  isUint128,\n  isInt128,\n  isBool,\n  isPrincipal,\n  isStandardPrincipal,\n  isContractPrincipal,\n  isTraitReference,\n  isOkResponse,\n  isErrResponse,\n  isResponse,\n  isArray,\n  isOptional,\n  isClarityList,\n  isClarityTuple,\n  isClarityOptional,\n  isClarityResponse,\n  isClarityBuffer,\n  isClarityStringAscii,\n  isClarityStringUtf8,\n  isClarityTraitReference,\n  jsToClarity,\n  prepareArgs,\n  validateArgs,\n  ClarityConversionError,\n  MAX_U128,\n  MIN_I128,\n  MAX_I128,\n  toCamelCase,\n} from \"../src\";\n\ndescribe(\"Type Guards\", () => {\n  describe(\"isUint128\", () => {\n    it(\"should validate valid uint128 values\", () => {\n      expect(isUint128(0n)).toBe(true);\n      expect(isUint128(123n)).toBe(true);\n      expect(isUint128(MAX_U128)).toBe(true);\n    });\n\n    it(\"should reject invalid uint128 values\", () => {\n      expect(isUint128(-1n)).toBe(false);\n      expect(isUint128(MAX_U128 + 1n)).toBe(false);\n      expect(isUint128(123)).toBe(false);\n      expect(isUint128(\"123\")).toBe(false);\n      expect(isUint128(null)).toBe(false);\n    });\n  });\n\n  describe(\"isInt128\", () => {\n    it(\"should validate valid int128 values\", () => {\n      expect(isInt128(0n)).toBe(true);\n      expect(isInt128(123n)).toBe(true);\n      expect(isInt128(-123n)).toBe(true);\n      expect(isInt128(MIN_I128)).toBe(true);\n      expect(isInt128(MAX_I128)).toBe(true);\n    });\n\n    it(\"should reject invalid int128 values\", () => {\n      expect(isInt128(MIN_I128 - 1n)).toBe(false);\n      expect(isInt128(MAX_I128 + 1n)).toBe(false);\n      expect(isInt128(123)).toBe(false);\n      expect(isInt128(\"123\")).toBe(false);\n    });\n  });\n\n  describe(\"Principal validation with @stacks/transactions\", () => {\n    it(\"should validate mainnet standard principals\", () => {\n      expect(isPrincipal(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\")).toBe(\n        true\n      );\n      expect(\n        isStandardPrincipal(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\")\n      ).toBe(true);\n      expect(\n        isContractPrincipal(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\")\n      ).toBe(false);\n    });\n\n    it(\"should validate testnet principals (ST prefix)\", () => {\n      // Testnet addresses start with ST\n      expect(isPrincipal(\"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\")).toBe(\n        true\n      );\n      expect(\n        isStandardPrincipal(\"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\")\n      ).toBe(true);\n    });\n\n    it(\"should validate contract principals\", () => {\n      const contractPrincipal =\n        \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7.my-contract\";\n      expect(isPrincipal(contractPrincipal)).toBe(true);\n      expect(isStandardPrincipal(contractPrincipal)).toBe(false);\n      expect(isContractPrincipal(contractPrincipal)).toBe(true);\n    });\n\n    it(\"should validate testnet contract principals\", () => {\n      const testnetContract =\n        \"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG.test-contract\";\n      expect(isPrincipal(testnetContract)).toBe(true);\n      expect(isContractPrincipal(testnetContract)).toBe(true);\n    });\n\n    it(\"should reject invalid principals\", () => {\n      expect(isPrincipal(\"invalid\")).toBe(false);\n      expect(isPrincipal(\"SP123\")).toBe(false);\n      expect(isPrincipal(\"\")).toBe(false);\n      expect(isPrincipal(null)).toBe(false);\n    });\n\n    it(\"should reject principals with invalid checksums\", () => {\n      // Modified last character to create invalid checksum\n      expect(isPrincipal(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ8\")).toBe(\n        false\n      );\n    });\n\n    it(\"should reject contract principals with invalid contract names\", () => {\n      // Contract name must start with a letter\n      expect(\n        isContractPrincipal(\n          \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7.123invalid\"\n        )\n      ).toBe(false);\n      // Contract name can't be empty\n      expect(\n        isContractPrincipal(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7.\")\n      ).toBe(false);\n    });\n  });\n\n  describe(\"Response type guards\", () => {\n    it(\"should identify ok responses\", () => {\n      const okResponse = { ok: true };\n      const errResponse = { err: \"error\" };\n\n      expect(isOkResponse(okResponse)).toBe(true);\n      expect(isOkResponse(errResponse)).toBe(false);\n      expect(isErrResponse(okResponse)).toBe(false);\n      expect(isErrResponse(errResponse)).toBe(true);\n    });\n\n    it(\"should validate response with guards\", () => {\n      const okResponse = { ok: 123n };\n      const errResponse = { err: \"error\" };\n\n      expect(\n        isResponse(\n          okResponse,\n          isUint128,\n          (v): v is string => typeof v === \"string\"\n        )\n      ).toBe(true);\n      expect(\n        isResponse(\n          errResponse,\n          isUint128,\n          (v): v is string => typeof v === \"string\"\n        )\n      ).toBe(true);\n      expect(\n        isResponse(\n          { ok: \"invalid\" },\n          isUint128,\n          (v): v is string => typeof v === \"string\"\n        )\n      ).toBe(false);\n    });\n  });\n\n  describe(\"Array and Optional guards\", () => {\n    it(\"should validate arrays\", () => {\n      expect(isArray([1n, 2n, 3n], isUint128)).toBe(true);\n      expect(isArray([1n, -2n, 3n], isUint128)).toBe(false);\n      expect(isArray([], isUint128)).toBe(true);\n    });\n\n    it(\"should validate optionals\", () => {\n      expect(isOptional(null, isUint128)).toBe(true);\n      expect(isOptional(123n, isUint128)).toBe(true);\n      expect(isOptional(-1n, isUint128)).toBe(false);\n    });\n  });\n});\n\ndescribe(\"Value Converters\", () => {\n  describe(\"jsToClarity\", () => {\n    it(\"should validate and pass through primitives\", () => {\n      expect(jsToClarity(\"uint128\", 123n)).toBe(123n);\n      expect(jsToClarity(\"int128\", -123n)).toBe(-123n);\n      expect(jsToClarity(\"bool\", true)).toBe(true);\n      expect(\n        jsToClarity(\"principal\", \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\")\n      ).toBe(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\");\n    });\n\n    it(\"should throw on invalid primitives\", () => {\n      expect(() => jsToClarity(\"uint128\", -1n)).toThrow(ClarityConversionError);\n      expect(() => jsToClarity(\"bool\", \"true\" as any)).toThrow(\n        ClarityConversionError\n      );\n      expect(() => jsToClarity(\"principal\", \"invalid\" as any)).toThrow(\n        ClarityConversionError\n      );\n    });\n\n    it(\"should validate string lengths\", () => {\n      const shortString = { \"string-ascii\": { length: 5 } } as const;\n      expect(jsToClarity(shortString, \"hello\")).toBe(\"hello\");\n      expect(() => jsToClarity(shortString, \"too long\")).toThrow(\n        ClarityConversionError\n      );\n\n      const utf8String = { \"string-utf8\": { length: 5 } } as const;\n      expect(jsToClarity(utf8String, \"hello\")).toBe(\"hello\");\n      expect(() => jsToClarity(utf8String, \"ðŸŽ‰ðŸŽ‰ðŸŽ‰\")).toThrow(\n        ClarityConversionError\n      ); // 12 bytes\n    });\n\n    it(\"should validate buffer lengths\", () => {\n      const buff = { buff: { length: 4 } } as const;\n      const validBuffer = new Uint8Array([1, 2, 3, 4]);\n      const invalidBuffer = new Uint8Array([1, 2, 3, 4, 5]);\n\n      expect(jsToClarity(buff, validBuffer)).toBe(validBuffer);\n      expect(() => jsToClarity(buff, invalidBuffer)).toThrow(\n        ClarityConversionError\n      );\n    });\n  });\n\n  describe(\"prepareArgs\", () => {\n    const testFunction = {\n      name: \"test\",\n      access: \"public\" as const,\n      args: [\n        { name: \"id\", type: \"uint128\" as const },\n        { name: \"owner\", type: \"principal\" as const },\n      ],\n      outputs: \"bool\" as const,\n    };\n\n    it(\"should prepare valid arguments\", () => {\n      const args = {\n        id: 123n,\n        owner: \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n      };\n\n      const prepared = prepareArgs(testFunction, args);\n      expect(prepared).toEqual([\n        123n,\n        \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n      ]);\n    });\n\n    it(\"should throw on missing arguments\", () => {\n      const args = { id: 123n };\n      expect(() => prepareArgs(testFunction, args)).toThrow(\n        \"Missing argument: owner\"\n      );\n    });\n\n    it(\"should throw on invalid arguments\", () => {\n      const args = {\n        id: -1n,\n        owner: \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n      };\n      expect(() => prepareArgs(testFunction, args)).toThrow(\n        ClarityConversionError\n      );\n    });\n  });\n\n  describe(\"validateArgs\", () => {\n    const testFunction = {\n      name: \"test\",\n      access: \"public\" as const,\n      args: [{ name: \"amount\", type: \"uint128\" as const }],\n      outputs: \"bool\" as const,\n    };\n\n    it(\"should validate correct arguments\", () => {\n      expect(() => validateArgs(testFunction, { amount: 100n })).not.toThrow();\n    });\n\n    it(\"should throw on invalid arguments\", () => {\n      expect(() => validateArgs(testFunction, { amount: -100n })).toThrow(\n        ClarityConversionError\n      );\n      expect(() => validateArgs(testFunction, {})).toThrow(\n        \"Missing argument: amount\"\n      );\n    });\n  });\n\n  describe(\"Composite type conversion\", () => {\n    describe(\"List types\", () => {\n      const listType = { list: { type: \"uint128\" as const, length: 5 } };\n\n      it(\"should validate list with correct elements\", () => {\n        const result = jsToClarity(listType, [1n, 2n, 3n]);\n        expect(result).toEqual([1n, 2n, 3n]);\n      });\n\n      it(\"should validate empty list\", () => {\n        const result = jsToClarity(listType, []);\n        expect(result).toEqual([]);\n      });\n\n      it(\"should throw on list exceeding max length\", () => {\n        expect(() => jsToClarity(listType, [1n, 2n, 3n, 4n, 5n, 6n])).toThrow(\n          ClarityConversionError\n        );\n        expect(() => jsToClarity(listType, [1n, 2n, 3n, 4n, 5n, 6n])).toThrow(\n          /exceeds max/\n        );\n      });\n\n      it(\"should throw on invalid list elements\", () => {\n        expect(() => jsToClarity(listType, [1n, -1n, 3n])).toThrow(\n          ClarityConversionError\n        );\n      });\n\n      it(\"should throw when value is not an array\", () => {\n        expect(() => jsToClarity(listType, \"not an array\")).toThrow(\n          ClarityConversionError\n        );\n      });\n    });\n\n    describe(\"Tuple types\", () => {\n      const tupleType = {\n        tuple: [\n          { name: \"amount\", type: \"uint128\" as const },\n          { name: \"recipient\", type: \"principal\" as const },\n        ],\n      };\n\n      it(\"should validate tuple with correct fields\", () => {\n        const result = jsToClarity(tupleType, {\n          amount: 100n,\n          recipient: \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n        });\n        expect(result).toEqual({\n          amount: 100n,\n          recipient: \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n        });\n      });\n\n      it(\"should accept camelCase field names for kebab-case definitions\", () => {\n        const kebabTupleType = {\n          tuple: [\n            { name: \"user-id\", type: \"uint128\" as const },\n            { name: \"is-active\", type: \"bool\" as const },\n          ],\n        };\n        const result = jsToClarity(kebabTupleType, {\n          userId: 42n,\n          isActive: true,\n        });\n        expect(result).toEqual({\n          \"user-id\": 42n,\n          \"is-active\": true,\n        });\n      });\n\n      it(\"should throw on missing tuple fields\", () => {\n        expect(() => jsToClarity(tupleType, { amount: 100n })).toThrow(\n          ClarityConversionError\n        );\n        expect(() => jsToClarity(tupleType, { amount: 100n })).toThrow(\n          /Missing tuple field/\n        );\n      });\n\n      it(\"should throw on invalid tuple field values\", () => {\n        expect(() =>\n          jsToClarity(tupleType, {\n            amount: -100n,\n            recipient: \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n          })\n        ).toThrow(ClarityConversionError);\n      });\n\n      it(\"should throw when value is not an object\", () => {\n        expect(() => jsToClarity(tupleType, \"not an object\")).toThrow(\n          ClarityConversionError\n        );\n        expect(() => jsToClarity(tupleType, null)).toThrow(\n          ClarityConversionError\n        );\n      });\n    });\n\n    describe(\"Optional types\", () => {\n      const optionalType = { optional: \"uint128\" as const };\n\n      it(\"should convert null to null\", () => {\n        expect(jsToClarity(optionalType, null)).toBe(null);\n      });\n\n      it(\"should convert undefined to null\", () => {\n        expect(jsToClarity(optionalType, undefined)).toBe(null);\n      });\n\n      it(\"should validate present value\", () => {\n        expect(jsToClarity(optionalType, 100n)).toBe(100n);\n      });\n\n      it(\"should throw on invalid present value\", () => {\n        expect(() => jsToClarity(optionalType, -100n)).toThrow(\n          ClarityConversionError\n        );\n      });\n    });\n\n    describe(\"Response types\", () => {\n      const responseType = {\n        response: { ok: \"bool\" as const, error: \"uint128\" as const },\n      };\n\n      it(\"should validate ok response\", () => {\n        const result = jsToClarity(responseType, { ok: true });\n        expect(result).toEqual({ ok: true });\n      });\n\n      it(\"should validate err response\", () => {\n        const result = jsToClarity(responseType, { err: 100n });\n        expect(result).toEqual({ err: 100n });\n      });\n\n      it(\"should throw on invalid ok value\", () => {\n        expect(() => jsToClarity(responseType, { ok: \"not a bool\" })).toThrow(\n          ClarityConversionError\n        );\n      });\n\n      it(\"should throw on invalid err value\", () => {\n        expect(() => jsToClarity(responseType, { err: -100n })).toThrow(\n          ClarityConversionError\n        );\n      });\n\n      it(\"should throw when response has both ok and err\", () => {\n        expect(() =>\n          jsToClarity(responseType, { ok: true, err: 100n })\n        ).toThrow(ClarityConversionError);\n        expect(() =>\n          jsToClarity(responseType, { ok: true, err: 100n })\n        ).toThrow(/exactly 'ok' or 'err'/);\n      });\n\n      it(\"should throw when response has neither ok nor err\", () => {\n        expect(() => jsToClarity(responseType, {})).toThrow(\n          ClarityConversionError\n        );\n      });\n\n      it(\"should throw when value is not an object\", () => {\n        expect(() => jsToClarity(responseType, \"not an object\")).toThrow(\n          ClarityConversionError\n        );\n      });\n    });\n\n    describe(\"Nested composite types\", () => {\n      it(\"should validate list of tuples\", () => {\n        const listOfTuples = {\n          list: {\n            type: {\n              tuple: [\n                { name: \"id\", type: \"uint128\" as const },\n                { name: \"active\", type: \"bool\" as const },\n              ],\n            },\n            length: 10,\n          },\n        };\n\n        const result = jsToClarity(listOfTuples, [\n          { id: 1n, active: true },\n          { id: 2n, active: false },\n        ]);\n        expect(result).toEqual([\n          { id: 1n, active: true },\n          { id: 2n, active: false },\n        ]);\n      });\n\n      it(\"should validate optional list\", () => {\n        const optionalList = {\n          optional: { list: { type: \"uint128\" as const, length: 5 } },\n        };\n\n        expect(jsToClarity(optionalList, null)).toBe(null);\n        expect(jsToClarity(optionalList, [1n, 2n])).toEqual([1n, 2n]);\n      });\n\n      it(\"should validate response with tuple ok type\", () => {\n        const responseWithTuple = {\n          response: {\n            ok: {\n              tuple: [\n                { name: \"balance\", type: \"uint128\" as const },\n                { name: \"owner\", type: \"principal\" as const },\n              ],\n            },\n            error: \"uint128\" as const,\n          },\n        };\n\n        const result = jsToClarity(responseWithTuple, {\n          ok: {\n            balance: 1000n,\n            owner: \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n          },\n        });\n        expect(result).toEqual({\n          ok: {\n            balance: 1000n,\n            owner: \"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\",\n          },\n        });\n      });\n    });\n  });\n});\n\ndescribe(\"Clarity ABI Type Guards\", () => {\n  it(\"should identify list types\", () => {\n    expect(isClarityList({ list: { type: \"uint128\", length: 10 } })).toBe(true);\n    expect(isClarityList(\"uint128\")).toBe(false);\n    expect(isClarityList({ tuple: [] })).toBe(false);\n  });\n\n  it(\"should identify tuple types\", () => {\n    expect(\n      isClarityTuple({ tuple: [{ name: \"id\", type: \"uint128\" }] })\n    ).toBe(true);\n    expect(isClarityTuple(\"uint128\")).toBe(false);\n    expect(isClarityTuple({ list: { type: \"uint128\", length: 10 } })).toBe(\n      false\n    );\n  });\n\n  it(\"should identify optional types\", () => {\n    expect(isClarityOptional({ optional: \"uint128\" })).toBe(true);\n    expect(isClarityOptional(\"uint128\")).toBe(false);\n    expect(isClarityOptional({ response: { ok: \"bool\", error: \"uint128\" } })).toBe(\n      false\n    );\n  });\n\n  it(\"should identify response types\", () => {\n    expect(\n      isClarityResponse({ response: { ok: \"bool\", error: \"uint128\" } })\n    ).toBe(true);\n    expect(isClarityResponse(\"uint128\")).toBe(false);\n    expect(isClarityResponse({ optional: \"uint128\" })).toBe(false);\n  });\n\n  it(\"should identify buffer types\", () => {\n    expect(isClarityBuffer({ buff: { length: 32 } })).toBe(true);\n    expect(isClarityBuffer(\"uint128\")).toBe(false);\n    expect(isClarityBuffer({ \"string-ascii\": { length: 10 } })).toBe(false);\n  });\n\n  it(\"should identify string-ascii types\", () => {\n    expect(isClarityStringAscii({ \"string-ascii\": { length: 100 } })).toBe(true);\n    expect(isClarityStringAscii(\"uint128\")).toBe(false);\n    expect(isClarityStringAscii({ \"string-utf8\": { length: 100 } })).toBe(false);\n  });\n\n  it(\"should identify string-utf8 types\", () => {\n    expect(isClarityStringUtf8({ \"string-utf8\": { length: 100 } })).toBe(true);\n    expect(isClarityStringUtf8(\"uint128\")).toBe(false);\n    expect(isClarityStringUtf8({ \"string-ascii\": { length: 100 } })).toBe(false);\n  });\n\n  it(\"should identify trait_reference types\", () => {\n    expect(isClarityTraitReference(\"trait_reference\")).toBe(true);\n    expect(isClarityTraitReference(\"uint128\")).toBe(false);\n    expect(isClarityTraitReference(\"principal\")).toBe(false);\n  });\n});\n\ndescribe(\"isTraitReference\", () => {\n  it(\"should validate trait references (contract principals)\", () => {\n    expect(isTraitReference(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7.my-trait\")).toBe(true);\n    expect(isTraitReference(\"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG.test-trait\")).toBe(true);\n  });\n\n  it(\"should reject standard principals\", () => {\n    expect(isTraitReference(\"SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7\")).toBe(false);\n  });\n\n  it(\"should reject invalid values\", () => {\n    expect(isTraitReference(\"invalid\")).toBe(false);\n    expect(isTraitReference(null)).toBe(false);\n    expect(isTraitReference(123)).toBe(false);\n  });\n});\n\ndescribe(\"Utilities\", () => {\n  describe(\"toCamelCase\", () => {\n    it(\"should convert kebab-case to camelCase\", () => {\n      expect(toCamelCase(\"user-id\")).toBe(\"userId\");\n      expect(toCamelCase(\"is-active\")).toBe(\"isActive\");\n      expect(toCamelCase(\"token-balance\")).toBe(\"tokenBalance\");\n    });\n\n    it(\"should handle multiple hyphens\", () => {\n      expect(toCamelCase(\"get-user-by-id\")).toBe(\"getUserById\");\n    });\n\n    it(\"should not change strings without hyphens\", () => {\n      expect(toCamelCase(\"amount\")).toBe(\"amount\");\n      expect(toCamelCase(\"userBalance\")).toBe(\"userBalance\");\n    });\n\n    it(\"should handle empty strings\", () => {\n      expect(toCamelCase(\"\")).toBe(\"\");\n    });\n  });\n});",
    "packages/clarity-types/README.md": "# clarity-types\n\nTypeScript types for Clarity contract ABIs. Full type inference, zero runtime dependencies.\n\n## Install\n\n```bash\nbun add clarity-types\n```\n\n## Quick Start\n\n```typescript\nimport type { ClarityContract, ExtractFunctionArgs, ExtractFunctionOutput } from 'clarity-types'\n\nconst abi = {\n  functions: [{\n    name: 'transfer',\n    access: 'public',\n    args: [\n      { name: 'amount', type: 'uint128' },\n      { name: 'recipient', type: 'principal' },\n    ],\n    outputs: { response: { ok: 'bool', error: 'uint128' } },\n  }],\n} as const satisfies ClarityContract\n\ntype TransferArgs = ExtractFunctionArgs<typeof abi, 'transfer'>\n// { amount: bigint, recipient: string }\n\ntype TransferOutput = ExtractFunctionOutput<typeof abi, 'transfer'>\n// { ok: boolean } | { err: bigint }\n```\n\n## Type Mappings\n\n| Clarity | TypeScript |\n|---------|------------|\n| `uint128`, `int128` | `bigint` |\n| `bool` | `boolean` |\n| `principal`, `trait_reference` | `string` |\n| `(string-ascii N)`, `(string-utf8 N)` | `string` |\n| `(buff N)` | `Uint8Array` |\n| `(optional T)` | `T \\| null` |\n| `(response OK ERR)` | `{ ok: OK } \\| { err: ERR }` |\n| `(list N T)` | `T[]` |\n| `{tuple}` | typed object |\n\n## Extractors\n\n```typescript\n// functions\ntype Names = ExtractFunctionNames<Contract>\ntype Args = ExtractFunctionArgs<Contract, 'fn-name'>\ntype Output = ExtractFunctionOutput<Contract, 'fn-name'>\ntype Public = ExtractPublicFunctions<Contract>\ntype ReadOnly = ExtractReadOnlyFunctions<Contract>\ntype Private = ExtractPrivateFunctions<Contract>\n\n// maps\ntype MapNames = ExtractMapNames<Contract>\ntype Key = ExtractMapKey<Contract, 'map-name'>\ntype Value = ExtractMapValue<Contract, 'map-name'>\n\n// variables\ntype VarNames = ExtractVariableNames<Contract>\ntype VarType = ExtractVariableType<Contract, 'var-name'>\ntype Constants = ExtractConstants<Contract>\ntype DataVars = ExtractDataVars<Contract>\n\n// tokens\ntype FTs = ExtractFungibleTokenNames<Contract>\ntype NFTs = ExtractNonFungibleTokenNames<Contract>\ntype NFTAsset = ExtractNFTAssetType<Contract, 'nft-name'>\n\n// traits\ntype Defined = ExtractDefinedTraitNames<Contract>\ntype Implemented = ExtractImplementedTraits<Contract>\n```\n\n## Type Guards\n\n```typescript\nimport { isUint128, isPrincipal, isOkResponse } from 'clarity-types'\n\nif (isUint128(value)) {\n  // bigint in [0, 2^128-1]\n}\n\nif (isPrincipal(addr)) {\n  // valid Stacks principal\n}\n\nif (isOkResponse(result)) {\n  console.log(result.ok)\n} else {\n  console.log(result.err)\n}\n```\n\n## @stacks/connect Integration\n\n```typescript\nimport type { ContractCallParams, ReadOnlyCallParams } from 'clarity-types'\nimport { openContractCall, callReadOnlyFunction } from '@stacks/connect'\n\n// generated interfaces return params compatible with @stacks/connect\nawait openContractCall({\n  ...contract.transfer({ amount: 100n, recipient: \"SP...\" }),\n  onFinish: (data) => console.log(data),\n})\n```\n\n## License\n\nMIT",
    "packages/cli/src/generated/provider.tsx": "import { createContext, useContext, type ReactNode } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\n\n/**\n * SecondLayer configuration for React hooks\n */\nexport interface SecondLayerConfig {\n  network: \"mainnet\" | \"testnet\" | \"devnet\";\n  apiKey?: string;\n  apiUrl?: string;\n  senderAddress?: string;\n}\n\n/**\n * React Context for SecondLayer configuration\n */\nconst SecondLayerContext = createContext<SecondLayerConfig | null>(null);\n\ninterface SecondLayerProviderProps {\n  config: SecondLayerConfig;\n  children: ReactNode;\n}\n\n/**\n * Provider for SecondLayer configuration\n */\nexport function SecondLayerProvider({ config, children }: SecondLayerProviderProps) {\n  return (\n    <SecondLayerContext.Provider value={config}>{children}</SecondLayerContext.Provider>\n  );\n}\n\ninterface SecondLayerQueryProviderProps {\n  config: SecondLayerConfig;\n  children: ReactNode;\n  queryClient?: QueryClient;\n}\n\n/**\n * Convenience provider that includes both SecondLayer config and TanStack Query\n */\nexport function SecondLayerQueryProvider({\n  config,\n  children,\n  queryClient,\n}: SecondLayerQueryProviderProps) {\n  const client =\n    queryClient ||\n    new QueryClient({\n      defaultOptions: {\n        queries: {\n          staleTime: 5 * 60 * 1000, // 5 minutes\n          retry: 3,\n          retryDelay: (attemptIndex: number) =>\n            Math.min(1000 * 2 ** attemptIndex, 30000),\n        },\n        mutations: {\n          retry: 1,\n        },\n      },\n    });\n\n  return (\n    <QueryClientProvider client={client}>\n      <SecondLayerProvider config={config} children={children} />\n    </QueryClientProvider>\n  );\n}\n\n/**\n * Hook to access the SecondLayer configuration\n */\nexport function useSecondLayerConfig(): SecondLayerConfig {\n  const context = useContext(SecondLayerContext);\n\n  if (!context) {\n    throw new Error(\n      \"useSecondLayerConfig must be used within a SecondLayerProvider or SecondLayerQueryProvider\"\n    );\n  }\n\n  return context;\n}\n\n/**\n * Create a SecondLayer configuration\n */\nexport function createSecondLayerConfig(config: SecondLayerConfig): SecondLayerConfig {\n  return {\n    network: config.network,\n    apiKey: config.apiKey,\n    apiUrl: config.apiUrl,\n    senderAddress: config.senderAddress || \"SP000000000000000000002Q6VF78\",\n  };\n}",
    "packages/cli/src/generators/react-provider.ts": "import { formatCode } from \"../utils/format\";\n\n/**\n * Generate React provider template for user projects\n */\nexport async function generateReactProvider(): Promise<string> {\n  const code = `import React, { createContext, useContext, type ReactNode } from 'react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\n/**\n * SecondLayer configuration for React hooks\n */\nexport interface SecondLayerConfig {\n  network: 'mainnet' | 'testnet' | 'devnet'\n  apiKey?: string\n  apiUrl?: string\n  senderAddress?: string\n}\n\n/**\n * React Context for SecondLayer configuration\n */\nconst SecondLayerContext = createContext<SecondLayerConfig | null>(null)\n\ninterface SecondLayerProviderProps {\n  config: SecondLayerConfig\n  children: ReactNode\n}\n\n/**\n * Provider for SecondLayer configuration\n */\nexport function SecondLayerProvider({ config, children }: SecondLayerProviderProps) {\n  return (\n    <SecondLayerContext.Provider value={config}>\n      {children}\n    </SecondLayerContext.Provider>\n  )\n}\n\ninterface SecondLayerQueryProviderProps {\n  config: SecondLayerConfig\n  children: ReactNode\n  queryClient?: QueryClient\n}\n\n/**\n * Convenience provider that includes both SecondLayer config and TanStack Query\n */\nexport function SecondLayerQueryProvider({\n  config,\n  children,\n  queryClient\n}: SecondLayerQueryProviderProps) {\n  const client = queryClient || new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 5 * 60 * 1000, // 5 minutes\n        retry: 3,\n        retryDelay: (attemptIndex: number) => Math.min(1000 * 2 ** attemptIndex, 30000),\n      },\n      mutations: {\n        retry: 1,\n      },\n    },\n  })\n\n  return (\n    <QueryClientProvider client={client}>\n      <SecondLayerProvider config={config} children={children} />\n    </QueryClientProvider>\n  )\n}\n\n/**\n * Hook to access the SecondLayer configuration\n */\nexport function useSecondLayerConfig(): SecondLayerConfig {\n  const context = useContext(SecondLayerContext)\n\n  if (!context) {\n    throw new Error('useSecondLayerConfig must be used within a SecondLayerProvider or SecondLayerQueryProvider')\n  }\n\n  return context\n}\n\n/**\n * Create a SecondLayer configuration\n */\nexport function createSecondLayerConfig(config: SecondLayerConfig): SecondLayerConfig {\n  return {\n    network: config.network,\n    apiKey: config.apiKey,\n    apiUrl: config.apiUrl,\n    senderAddress: config.senderAddress || 'SP000000000000000000002Q6VF78'\n  }\n}`;\n\n  return formatCode(code);\n}",
    "packages/cli/src/plugins/actions/index.ts": "/**\n * Actions Plugin for @secondlayer/cli\n * Generates read and write helper functions for direct blockchain interaction\n */\n\nimport { generateActionHelpers } from \"./generators\";\nimport type {\n  PluginFactory,\n  // UserConfig,\n  GenerateContext,\n} from \"../../types/plugin\";\n\nexport interface ActionsPluginOptions {\n  /** Include only specific contracts */\n  include?: string[];\n\n  /** Exclude specific contracts */\n  exclude?: string[];\n\n  /** Include only specific functions */\n  includeFunctions?: string[];\n\n  /** Exclude specific functions */\n  excludeFunctions?: string[];\n\n  /** Enable debug output */\n  debug?: boolean;\n\n  /** Environment variable name for default sender key (default: \"STX_SENDER_KEY\") */\n  senderKeyEnv?: string;\n}\n\n/**\n * Actions plugin factory\n */\nexport const actions: PluginFactory<ActionsPluginOptions> = (options = {}) => {\n  return {\n    name: \"@secondlayer/cli/plugin-actions\",\n    version: \"1.0.0\",\n\n    async generate(context: GenerateContext): Promise<void> {\n      const { contracts } = context;\n\n      // Filter contracts based on options\n      const filteredContracts = contracts.filter((contract) => {\n        if (options.include && !options.include.includes(contract.name)) {\n          return false;\n        }\n        if (options.exclude && options.exclude.includes(contract.name)) {\n          return false;\n        }\n        return true;\n      });\n\n      if (filteredContracts.length === 0) {\n        if (options.debug) {\n          context.logger.debug(\"Actions plugin: No contracts to process\");\n        }\n        return;\n      }\n\n      if (options.debug) {\n        context.logger.debug(\n          `Actions plugin: Generating read/write helpers for ${filteredContracts.length} contracts`\n        );\n      }\n\n      // Collect all helpers for all contracts\n      const contractHelpers = new Map<string, string>();\n\n      for (const contract of filteredContracts) {\n        const actionsCode = await generateActionHelpers(contract, options);\n        if (actionsCode) {\n          contractHelpers.set(contract.name, actionsCode);\n        }\n      }\n\n      // Inject all helpers into the output\n      if (contractHelpers.size > 0) {\n        const existingOutput = context.outputs.get(\"contracts\");\n        if (existingOutput) {\n          let modifiedContent = addRequiredImports(existingOutput.content);\n\n          // Inject helpers for each contract\n          for (const [contractName, helpersCode] of contractHelpers) {\n            modifiedContent = injectHelpersIntoContract(\n              modifiedContent,\n              contractName,\n              helpersCode\n            );\n          }\n\n          context.outputs.set(\"contracts\", {\n            ...existingOutput,\n            content: modifiedContent,\n          });\n        }\n      }\n    },\n  };\n};\n\n/**\n * Add required imports for fetchCallReadOnlyFunction, makeContractCall, and PostCondition\n */\nfunction addRequiredImports(content: string): string {\n  // Find the existing @stacks/transactions import line\n  const transactionsImportRegex =\n    /import\\s+\\{([^}]+)\\}\\s+from\\s+['\"]@stacks\\/transactions['\"];/;\n  const match = content.match(transactionsImportRegex);\n\n  if (match) {\n    // Add the new imports to the existing import\n    const existingImports = match[1].trim();\n    const requiredImports = [\n      \"fetchCallReadOnlyFunction\",\n      \"makeContractCall\",\n    ];\n\n    const newImports = requiredImports\n      .filter((imp) => !existingImports.includes(imp))\n      .join(\", \");\n\n    if (newImports) {\n      const updatedImport = `import { ${existingImports}, ${newImports} } from '@stacks/transactions';`;\n      let updatedContent = content.replace(transactionsImportRegex, updatedImport);\n\n      // Add type import for PostCondition if not present\n      if (!updatedContent.includes(\"type PostCondition\")) {\n        updatedContent = updatedContent.replace(\n          updatedImport,\n          `${updatedImport}\\nimport type { PostCondition } from '@stacks/transactions';`\n        );\n      }\n\n      return updatedContent;\n    }\n\n    // Still need to add PostCondition type import even if other imports exist\n    if (!content.includes(\"type PostCondition\")) {\n      return content.replace(\n        transactionsImportRegex,\n        `${match[0]}\\nimport type { PostCondition } from '@stacks/transactions';`\n      );\n    }\n  }\n\n  return content;\n}\n\n/**\n * Inject read/write helpers into a specific contract object in the output\n */\nfunction injectHelpersIntoContract(\n  content: string,\n  contractName: string,\n  helpersCode: string\n): string {\n  // Use a more precise regex to find the entire contract object\n  const contractPattern = new RegExp(\n    `(export const ${contractName} = \\\\{[\\\\s\\\\S]*?)\\\\n\\\\} as const;`,\n    \"g\"\n  );\n\n  return content.replace(contractPattern, (_, contractBody) => {\n    // Remove any trailing comma and whitespace from the contract body\n    const cleanBody = contractBody.replace(/,\\s*$/, \"\");\n\n    // Add proper indentation to lines that start top-level properties\n    const indentedHelpersCode = helpersCode\n      .split(\"\\n\")\n      .map((line) => {\n        // Only add indentation to lines that start with a property name (like \"write:\")\n        if (line.match(/^[a-zA-Z_$][a-zA-Z0-9_$]*\\s*:/)) {\n          return `  ${line}`;\n        }\n        return line;\n      })\n      .join(\"\\n\");\n\n    // Add the helpers with proper formatting\n    return `${cleanBody},\n\n${indentedHelpersCode}\n} as const;`;\n  });\n}",
    "packages/cli/src/plugins/clarinet/index.ts": "/**\n * Clarinet Plugin for @secondlayer/cli\n * Generates type-safe contract interfaces from local Clarity contracts using Clarinet SDK\n */\n\nimport { initSimnet } from \"@hirosystems/clarinet-sdk\";\nimport { toCamelCase } from \"@secondlayer/clarity-types\";\nimport { generateContractInterface } from \"../../generators/contract\";\nimport type {\n  PluginFactory,\n  UserConfig,\n  GenerateContext,\n} from \"../../types/plugin\";\n\nexport interface ClarinetPluginOptions {\n  /** Path to Clarinet.toml file */\n  path?: string;\n\n  /** Include only specific contracts */\n  include?: string[];\n\n  /** Exclude specific contracts */\n  exclude?: string[];\n\n  /** Enable debug output */\n  debug?: boolean;\n}\n\n/**\n * Sanitize contract name to be a valid JavaScript identifier using camelCase\n */\nfunction sanitizeContractName(name: string): string {\n  return toCamelCase(name);\n}\n\n/**\n * Check if a contract is a user-defined contract (not a system contract)\n */\nasync function isUserDefinedContract(\n  contractId: string,\n  manifestPath: string\n): Promise<boolean> {\n  const [address, contractName] = contractId.split(\".\");\n\n  try {\n    // Read Clarinet.toml to get user-defined contracts\n    const { promises: fs } = await import(\"fs\");\n    const tomlContent = await fs.readFile(manifestPath, \"utf-8\");\n\n    // Simple TOML parsing to find [contracts.CONTRACT_NAME] sections\n    const contractSectionRegex = /^\\[contracts\\.([^\\]]+)\\]/gm;\n    const userContracts = new Set<string>();\n\n    let match;\n    while ((match = contractSectionRegex.exec(tomlContent)) !== null) {\n      userContracts.add(match[1]);\n    }\n\n    // If the contract is explicitly defined in Clarinet.toml, it's user-defined\n    if (userContracts.has(contractName)) {\n      return true;\n    }\n  } catch (error) {\n    // If we can't read the TOML file, fall back to pattern matching\n  }\n\n  // Fallback: System contracts typically have specific addresses or are in the boot contracts\n  // Common system contract patterns:\n  const systemContractPatterns = [\n    /^pox-\\d+$/, // pox-2, pox-3, etc.\n    /^bns$/, // Blockchain Name System\n    /^costs-\\d+$/, // costs-2, costs-3, etc.\n    /^lockup$/, // lockup contract\n  ];\n\n  // Check if it matches any system contract pattern\n  if (systemContractPatterns.some((pattern) => pattern.test(contractName))) {\n    return false;\n  }\n\n  // System contracts often use specific addresses\n  const systemAddresses = [\n    \"SP000000000000000000002Q6VF78\", // Boot contracts address\n    \"ST000000000000000000002AMW42H\", // Boot contracts address (testnet)\n  ];\n\n  if (systemAddresses.includes(address)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Clarinet plugin factory\n */\nexport const clarinet: PluginFactory<ClarinetPluginOptions> = (\n  options = {}\n) => {\n  const manifestPath = options.path || \"./Clarinet.toml\";\n  let simnet: any;\n\n  return {\n    name: \"@secondlayer/cli/plugin-clarinet\",\n    version: \"1.0.0\",\n\n    async transformConfig(config: UserConfig): Promise<UserConfig> {\n      try {\n        // Initialize simnet to extract contract ABIs\n        simnet = await initSimnet(manifestPath);\n\n        // Get contract interfaces from Clarinet\n        const contractInterfaces = simnet.getContractsInterfaces();\n        const contracts = [];\n\n        for (const [contractId, abi] of contractInterfaces) {\n          const [_, contractName] = contractId.split(\".\");\n\n          // Skip system contracts\n          if (!(await isUserDefinedContract(contractId, manifestPath))) {\n            if (options.debug) {\n              console.log(`ðŸš« Skipping system contract: ${contractId}`);\n            }\n            continue;\n          }\n\n          // Apply user filters\n          if (options.include && !options.include.includes(contractName)) {\n            continue;\n          }\n          if (options.exclude && options.exclude.includes(contractName)) {\n            continue;\n          }\n\n          // Sanitize the contract name for JavaScript export\n          const sanitizedName = sanitizeContractName(contractName);\n\n          // Don't set source field to avoid conflict with file resolution\n          // Instead, we'll track this in metadata during processing\n          contracts.push({\n            name: sanitizedName,\n            address: contractId,\n            abi: abi,\n            // Remove source field - this was causing the path resolution issue\n            _clarinetSource: true, // Internal flag for our plugin\n          });\n        }\n\n        if (options.debug) {\n          console.log(\n            `ðŸ” Clarinet plugin found ${contracts.length} user-defined contracts`\n          );\n        }\n\n        return {\n          ...config,\n          contracts: [...(config.contracts || []), ...contracts],\n        };\n      } catch (error) {\n        const err = error as Error;\n        if (options.debug) {\n          console.warn(\n            `âš ï¸  Clarinet plugin failed to load contracts: ${err.message}`\n          );\n        }\n        // If Clarinet.toml doesn't exist or fails, just return config unchanged\n        return config;\n      }\n    },\n\n    async generate(context: GenerateContext): Promise<void> {\n      // Filter contracts that came from Clarinet\n      const clarinetContracts = context.contracts.filter(\n        (contract) => contract.metadata?.source === \"clarinet\"\n      );\n\n      if (clarinetContracts.length === 0) {\n        return;\n      }\n\n      if (options.debug) {\n        context.logger.debug(\n          `Generating interfaces for ${clarinetContracts.length} Clarinet contracts`\n        );\n      }\n\n      // Generate the main contracts file using existing generator\n      const contractsCode = await generateContractInterface(clarinetContracts);\n\n      context.addOutput(\"contracts\", {\n        path: context.config.out,\n        content: contractsCode,\n        type: \"contracts\",\n      });\n\n      // Don't log success here - let the main command handle it\n    },\n  };\n};\n\n/**\n * Utility function to check if a Clarinet project exists\n */\nexport async function hasClarinetProject(\n  path = \"./Clarinet.toml\"\n): Promise<boolean> {\n  try {\n    const { promises: fs } = await import(\"fs\");\n    await fs.access(path);\n    return true;\n  } catch {\n    return false;\n  }\n}",
    "packages/cli/src/plugins/react/generators/utils.ts": "/**\n * Utility functions for React hook generation\n */\n\nimport { toCamelCase } from \"@secondlayer/clarity-types\";\nimport { clarityTypeToTS } from \"../../../utils/type-mapping\";\n\n// Re-export for use in other files\nexport { toCamelCase, clarityTypeToTS };\n\nexport function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function generateHookArgsSignature(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n\n  const argsList = args\n    .map((arg) => `${toCamelCase(arg.name)}: ${clarityTypeToTS(arg.type)}`)\n    .join(\", \");\n  return `${argsList}`;\n}\n\nexport function generateArgsType(args: readonly any[]): string {\n  if (args.length === 0) return \"void\";\n\n  const argsList = args\n    .map((arg) => `${toCamelCase(arg.name)}: ${clarityTypeToTS(arg.type)}`)\n    .join(\"; \");\n  return `{ ${argsList} }`;\n}\n\nexport function generateQueryKeyArgs(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n  return args.map((arg) => toCamelCase(arg.name)).join(\", \");\n}\n\nexport function generateFunctionCallArgs(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n  return args.map((arg) => toCamelCase(arg.name)).join(\", \");\n}\n\nexport function generateEnabledCondition(args: readonly any[]): string {\n  return args\n    .map((arg) => {\n      const camelName = toCamelCase(arg.name);\n      const type = clarityTypeToTS(arg.type);\n      if (type === \"string\") return `!!${camelName}`;\n      if (type === \"bigint\") return `${camelName} !== undefined`;\n      return `${camelName} !== undefined`;\n    })\n    .join(\" && \");\n}\n\nexport function generateObjectArgs(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n  return args.map((arg) => `${arg.name}: ${toCamelCase(arg.name)}`).join(\", \");\n}",
    "packages/cli/src/plugins/react/provider/index.ts": "/**\n * Provider generator for React plugin\n */\n\nimport { formatCode } from \"../../../utils/format\";\n\n/**\n * Generate the provider file content for user projects\n */\nexport async function generateProvider(): Promise<string> {\n  const code = `/**\n * Generated SecondLayer React Provider\n * DO NOT EDIT MANUALLY\n */\n\nimport React, { createContext, useContext } from 'react'\n\n/**\n * SecondLayer configuration interface\n */\nexport interface SecondLayerReactConfig {\n  /**\n   * Network to use for API calls\n   */\n  network: 'mainnet' | 'testnet' | 'devnet'\n\n  /**\n   * API key for Stacks API (optional)\n   */\n  apiKey?: string\n\n  /**\n   * Base URL for Stacks API (optional override)\n   */\n  apiUrl?: string\n\n  /**\n   * Default sender address for read-only calls\n   */\n  senderAddress?: string\n}\n\n/**\n * Provider component props\n */\nexport interface SecondLayerProviderProps {\n  children: React.ReactNode\n  config: SecondLayerReactConfig\n}\n\n/**\n * React context for SecondLayer configuration\n */\nconst SecondLayerContext = createContext<SecondLayerReactConfig | undefined>(undefined)\nSecondLayerContext.displayName = 'SecondLayerContext'\n\n/**\n * Create a SecondLayer React configuration with defaults\n */\nexport function createSecondLayerConfig(config: SecondLayerReactConfig): SecondLayerReactConfig {\n  return {\n    network: config.network,\n    apiKey: config.apiKey,\n    apiUrl: config.apiUrl,\n    senderAddress: config.senderAddress || 'SP000000000000000000002Q6VF78'\n  }\n}\n\n/**\n * Provider component that makes SecondLayer configuration available to hooks\n */\nexport function SecondLayerProvider({ children, config }: SecondLayerProviderProps) {\n  const resolvedConfig = createSecondLayerConfig(config)\n\n  return (\n    <SecondLayerContext.Provider value={resolvedConfig}>\n      {children}\n    </SecondLayerContext.Provider>\n  )\n}\n\n/**\n * Hook to access the SecondLayer configuration\n */\nexport function useSecondLayerConfig(): SecondLayerReactConfig {\n  const context = useContext(SecondLayerContext)\n\n  if (context === undefined) {\n    throw new Error(\n      'useSecondLayerConfig must be used within a SecondLayerProvider. ' +\n      'Make sure to wrap your app with <SecondLayerProvider config={{...}}>'\n    )\n  }\n\n  return context\n}`;\n\n  return formatCode(code);\n}",
    "packages/cli/src/plugins/index.ts": "/**\n * Plugin exports for @secondlayer/cli\n * This will be expanded as plugins are implemented\n */\n\nimport type { SecondLayerPlugin } from \"../types/plugin\";\n\n// Re-export plugin types for convenience\nexport type {\n  SecondLayerPlugin,\n  PluginFactory,\n  PluginOptions,\n  GenerateContext,\n  PluginContext,\n  Logger,\n  PluginUtils,\n} from \"../types/plugin\";\n\n// Plugin utilities\nexport { PluginManager } from \"../core/plugin-manager\";\n\n// Base plugin options interface\nexport interface BasePluginOptions {\n  /** Include only specific contracts/functions */\n  include?: string[];\n\n  /** Exclude specific contracts/functions */\n  exclude?: string[];\n\n  /** Enable debug output */\n  debug?: boolean;\n}\n\n/**\n * Utility function to filter contracts/functions based on include/exclude options\n */\nexport function filterByOptions<T extends { name: string }>(\n  items: T[],\n  options: BasePluginOptions = {}\n): T[] {\n  let filtered = items;\n\n  if (options.include && options.include.length > 0) {\n    filtered = filtered.filter((item) =>\n      options.include!.some(\n        (pattern) =>\n          item.name.includes(pattern) || item.name.match(new RegExp(pattern))\n      )\n    );\n  }\n\n  if (options.exclude && options.exclude.length > 0) {\n    filtered = filtered.filter(\n      (item) =>\n        !options.exclude!.some(\n          (pattern) =>\n            item.name.includes(pattern) || item.name.match(new RegExp(pattern))\n        )\n    );\n  }\n\n  return filtered;\n}\n\n/**\n * Utility function to create a simple plugin\n */\nexport function createPlugin(\n  name: string,\n  version: string,\n  implementation: Partial<SecondLayerPlugin>\n): SecondLayerPlugin {\n  return {\n    name,\n    version,\n    ...implementation,\n  };\n}\n\n// Plugin exports\nexport { clarinet, hasClarinetProject } from \"./clarinet/index\";\nexport type { ClarinetPluginOptions } from \"./clarinet/index\";\n\nexport { actions } from \"./actions/index\";\nexport type { ActionsPluginOptions } from \"./actions/index\";\n\nexport { react } from \"./react/index\";\nexport type { ReactPluginOptions } from \"./react/index\";\n\nexport { testing } from \"./testing/index\";\nexport type { TestingPluginOptions } from \"./testing/index\";",
    "packages/cli/src/types/config.ts": "/**\n * Configuration types for @secondlayer/cli\n */\n\nexport type NetworkName = \"mainnet\" | \"testnet\" | \"devnet\";\n\nexport interface ContractSource {\n  /**\n   * Contract identifier (address.name) for deployed contracts\n   */\n  address?: string | Partial<Record<NetworkName, string>>;\n\n  /**\n   * Path to local Clarity file\n   */\n  source?: string;\n\n  /**\n   * Optional name to use in generated code\n   */\n  name?: string;\n}\n\nexport interface SecondLayerConfig {\n  /**\n   * Contracts to generate interfaces for (optional - plugins can provide these)\n   */\n  contracts?: ContractSource[];\n\n  /**\n   * Output file path\n   */\n  out: string;\n\n  /**\n   * Plugins to use for generation\n   */\n  plugins?: any[]; // Will be properly typed when plugins are imported\n\n  /**\n   * Network to use for fetching contracts\n   */\n  network?: NetworkName;\n\n  /**\n   * API key for Stacks API (if required)\n   */\n  apiKey?: string;\n\n  /**\n   * Base URL for Stacks API (optional override)\n   */\n  apiUrl?: string;\n\n  /**\n   * Default deployer address for local contracts without explicit addresses\n   * Defaults to ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM (devnet default)\n   */\n  defaultAddress?: string;\n}\n\nexport interface ResolvedContract {\n  name: string;\n  address: string;\n  contractName: string;\n  abi: any; // Will be ClarityContract type\n  source: \"api\" | \"local\";\n}\n\n// Helper function type\nexport type ConfigDefiner = (config: SecondLayerConfig) => SecondLayerConfig;",
    "packages/cli/src/types/plugin.ts": "/**\n * Plugin system types for @secondlayer/cli\n */\n\nimport type { SecondLayerConfig, ResolvedContract, NetworkName } from \"./config\";\n\n/**\n * Core plugin interface that all plugins must implement\n */\nexport interface SecondLayerPlugin {\n  /** Plugin name (should be unique) */\n  name: string;\n\n  /** Plugin version */\n  version: string;\n\n  // Lifecycle hooks\n  /** Called after config is resolved but before generation starts */\n  configResolved?: (config: ResolvedConfig) => void | Promise<void>;\n\n  /** Called before generation starts */\n  beforeGenerate?: (context: GenerateContext) => void | Promise<void>;\n\n  /** Called during generation phase - plugins can add their own outputs */\n  generate?: (context: GenerateContext) => void | Promise<void>;\n\n  /** Called after all generation is complete */\n  afterGenerate?: (context: GenerateContext) => void | Promise<void>;\n\n  // Transform hooks\n  /** Transform user config before resolution */\n  transformConfig?: (config: UserConfig) => UserConfig | Promise<UserConfig>;\n\n  /** Transform individual contracts during processing */\n  transformContract?: (\n    contract: ContractConfig\n  ) => ContractConfig | Promise<ContractConfig>;\n\n  /** Transform generated output before writing to disk */\n  transformOutput?: (\n    output: string,\n    type: OutputType\n  ) => string | Promise<string>;\n}\n\n/**\n * User configuration (before plugin transformations)\n */\nexport type UserConfig = SecondLayerConfig;\n\n/**\n * Resolved configuration (after plugin transformations)\n */\nexport interface ResolvedConfig extends SecondLayerConfig {\n  /** Resolved plugins array */\n  plugins: SecondLayerPlugin[];\n}\n\n/**\n * Contract configuration that can be transformed by plugins\n */\nexport interface ContractConfig {\n  name?: string;\n  address?: string | Partial<Record<NetworkName, string>>;\n  source?: string;\n  abi?: any;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Contract config from Clarinet plugin\n */\nexport interface ClarinetContractConfig extends ContractConfig {\n  _clarinetSource: true;\n}\n\n/**\n * Contract config from direct file input\n */\nexport interface DirectFileContractConfig extends ContractConfig {\n  _directFile: true;\n}\n\n/**\n * Union of all contract config types\n */\nexport type PluginContractConfig =\n  | ContractConfig\n  | ClarinetContractConfig\n  | DirectFileContractConfig;\n\n/**\n * Type guard for Clarinet contracts\n */\nexport function isClarinetContract(\n  c: ContractConfig\n): c is ClarinetContractConfig {\n  return \"_clarinetSource\" in c && c._clarinetSource === true;\n}\n\n/**\n * Type guard for direct file contracts\n */\nexport function isDirectFileContract(\n  c: ContractConfig\n): c is DirectFileContractConfig {\n  return \"_directFile\" in c && c._directFile === true;\n}\n\n/**\n * Processed contract with resolved ABI and metadata\n */\nexport interface ProcessedContract extends ResolvedContract {\n  /** Additional metadata added by plugins */\n  metadata?: Record<string, any>;\n}\n\n/**\n * Generated output from plugins\n */\nexport interface GeneratedOutput {\n  /** File path where output should be written */\n  path: string;\n\n  /** Generated content */\n  content: string;\n\n  /** Output type for transformation hooks */\n  type?: OutputType;\n\n  /** Whether this output should overwrite existing files */\n  overwrite?: boolean;\n}\n\n/**\n * Types of outputs that can be generated\n */\nexport type OutputType =\n  | \"contracts\"\n  | \"hooks\"\n  | \"actions\"\n  | \"types\"\n  | \"utils\"\n  | \"config\"\n  | \"other\";\n\n/**\n * Base context available to all plugin hooks\n */\nexport interface PluginContext {\n  /** Resolved configuration */\n  config: ResolvedConfig;\n\n  /** Logger for plugin output */\n  logger: Logger;\n\n  /** Utility functions for plugins */\n  utils: PluginUtils;\n}\n\n/**\n * Context available during generation phase\n */\nexport interface GenerateContext extends PluginContext {\n  /** Processed contracts ready for generation */\n  contracts: ProcessedContract[];\n\n  /** Map of output keys to generated content */\n  outputs: Map<string, GeneratedOutput>;\n\n  /** Function to augment existing outputs */\n  augment: (outputKey: string, contractName: string, content: any) => void;\n\n  /** Function to add new outputs */\n  addOutput: (key: string, output: GeneratedOutput) => void;\n}\n\n/**\n * Logger interface for plugin output\n */\nexport interface Logger {\n  info: (message: string) => void;\n  warn: (message: string) => void;\n  error: (message: string) => void;\n  debug: (message: string) => void;\n  success: (message: string) => void;\n}\n\n/**\n * Utility functions available to plugins\n */\nexport interface PluginUtils {\n  /** Convert kebab-case to camelCase */\n  toCamelCase: (str: string) => string;\n\n  /** Convert camelCase to kebab-case */\n  toKebabCase: (str: string) => string;\n\n  /** Validate Stacks address format */\n  validateAddress: (address: string) => boolean;\n\n  /** Parse contract identifier (address.contract-name) */\n  parseContractId: (contractId: string) => {\n    address: string;\n    contractName: string;\n  };\n\n  /** Format TypeScript code using prettier */\n  formatCode: (code: string) => Promise<string>;\n\n  /** Resolve file path relative to project root */\n  resolvePath: (relativePath: string) => string;\n\n  /** Check if file exists */\n  fileExists: (path: string) => Promise<boolean>;\n\n  /** Read file content */\n  readFile: (path: string) => Promise<string>;\n\n  /** Write file content */\n  writeFile: (path: string, content: string) => Promise<void>;\n\n  /** Create directory recursively */\n  ensureDir: (path: string) => Promise<void>;\n}\n\n/**\n * Plugin factory function type for creating plugins with options\n */\nexport type PluginFactory<TOptions = any> = (\n  options?: TOptions\n) => SecondLayerPlugin;\n\n/**\n * Plugin options base interface\n */\nexport interface PluginOptions {\n  /** Include only specific contracts/functions */\n  include?: string[];\n\n  /** Exclude specific contracts/functions */\n  exclude?: string[];\n\n  /** Enable debug output */\n  debug?: boolean;\n}\n\n/**\n * Hook execution result\n */\nexport interface HookResult<T = any> {\n  /** Whether the hook was successful */\n  success: boolean;\n\n  /** Result data from the hook */\n  data?: T;\n\n  /** Error if hook failed */\n  error?: Error;\n\n  /** Plugin that executed the hook */\n  plugin: string;\n}\n\n/**\n * Plugin execution context for internal use\n */\nexport interface PluginExecutionContext {\n  /** Current plugin being executed */\n  currentPlugin?: SecondLayerPlugin;\n\n  /** Execution phase */\n  phase: \"config\" | \"generate\" | \"output\";\n\n  /** Start time for performance tracking */\n  startTime: number;\n\n  /** Plugin execution results */\n  results: Map<string, HookResult[]>;\n}",
    "packages/cli/src/utils/api.ts": "import got from \"got\";\nimport type { NetworkName } from \"../types/config\";\n\nconst gotWithRetry = got.extend({\n  timeout: { request: 30000 },\n  retry: {\n    limit: 3,\n    methods: [\"GET\", \"POST\"],\n    statusCodes: [408, 429, 500, 502, 503, 504],\n    calculateDelay: ({ attemptCount }) => attemptCount * 1000,\n  },\n});\n\n/**\n * Stacks API client for fetching contract information\n */\n\nconst API_URLS: Record<NetworkName, string> = {\n  mainnet: \"https://api.hiro.so\",\n  testnet: \"https://api.testnet.hiro.so\",\n  devnet: \"http://localhost:3999\",\n};\n\nexport interface ContractInfo {\n  functions: any[];\n  variables?: any[];\n  maps?: any[];\n  fungible_tokens?: any[];\n  non_fungible_tokens?: any[];\n  epoch?: string;\n  clarity_version?: string;\n}\n\nexport class StacksApiClient {\n  private static hasWarnedAboutApiKey = false;\n  private baseUrl: string;\n  private headers: Record<string, string>;\n\n  constructor(\n    network: NetworkName = \"mainnet\",\n    apiKey?: string,\n    apiUrl?: string\n  ) {\n    this.baseUrl = apiUrl || API_URLS[network];\n    this.headers = apiKey ? { \"x-api-key\": apiKey } : {};\n\n    if (!apiKey && !StacksApiClient.hasWarnedAboutApiKey) {\n      console.warn(\n        \"âš ï¸  No API key provided. You may be rate-limited.\\n\" +\n          \"   Set HIRO_API_KEY env var or use --api-key flag.\\n\" +\n          \"   Get a free key at: https://platform.hiro.so/\"\n      );\n      StacksApiClient.hasWarnedAboutApiKey = true;\n    }\n  }\n\n  private parseContractId(contractId: string): { address: string; contractName: string } {\n    const [address, contractName] = contractId.split(\".\");\n    if (!address || !contractName) {\n      throw new Error(\n        `Invalid contract ID format: ${contractId}. Expected format: ADDRESS.CONTRACT_NAME`\n      );\n    }\n    return { address, contractName };\n  }\n\n  private async fetchWithErrorHandling<T>(\n    url: string,\n    resourceType: string,\n    resourceId: string\n  ): Promise<T> {\n    try {\n      const response = await gotWithRetry(url, {\n        headers: this.headers,\n        responseType: \"json\",\n      });\n      return response.body as T;\n    } catch (error: any) {\n      if (error.response?.statusCode === 404) {\n        throw new Error(`${resourceType} not found: ${resourceId}`);\n      }\n      if (error.response?.statusCode === 429) {\n        throw new Error(\"Rate limited. Please provide an API key in your config.\");\n      }\n      throw new Error(`Failed to fetch ${resourceType.toLowerCase()}: ${error.message}`);\n    }\n  }\n\n  async getContractInfo(contractId: string): Promise<ContractInfo> {\n    const { address, contractName } = this.parseContractId(contractId);\n    const url = `${this.baseUrl}/v2/contracts/interface/${address}/${contractName}`;\n    return this.fetchWithErrorHandling<ContractInfo>(url, \"Contract\", contractId);\n  }\n\n  async getContractSource(contractId: string): Promise<string> {\n    const { address, contractName } = this.parseContractId(contractId);\n    const url = `${this.baseUrl}/v2/contracts/source/${address}/${contractName}`;\n    const data = await this.fetchWithErrorHandling<{ source: string }>(url, \"Contract source\", contractId);\n    return data.source;\n  }\n}",
    "packages/cli/src/utils/dependencies.ts": "import { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { detect } from \"@antfu/ni\";\nimport { execa } from \"execa\";\nimport chalk from \"chalk\";\n\n/**\n * Required dependencies for base generated contracts\n */\nexport const BASE_DEPENDENCIES = {\n  dependencies: [\"@stacks/transactions\"],\n  devDependencies: [] as string[],\n} as const;\n\n/**\n * Required dependencies for React hooks\n */\nexport const HOOKS_DEPENDENCIES = {\n  dependencies: [\n    \"react\",\n    \"@tanstack/react-query\",\n    \"@stacks/transactions\",\n    \"@stacks/connect\",\n  ],\n  devDependencies: [\"@types/react\"],\n} as const;\n\n/**\n * Get the package manager used in the project\n */\nexport async function getPackageManager(\n  targetDir: string\n): Promise<\"yarn\" | \"pnpm\" | \"bun\" | \"npm\"> {\n  const packageManager = await detect({ programmatic: true, cwd: targetDir });\n\n  if (packageManager === \"yarn@berry\") return \"yarn\";\n  if (packageManager === \"pnpm@6\") return \"pnpm\";\n  if (packageManager === \"bun\") return \"bun\";\n  if (packageManager === \"deno\") return \"npm\"; // Fallback to npm for deno\n\n  return packageManager ?? \"npm\";\n}\n\n/**\n * Check if a package.json exists in the target directory\n */\nexport async function hasPackageJson(targetDir: string): Promise<boolean> {\n  try {\n    const packageJsonPath = path.join(targetDir, \"package.json\");\n    await fs.access(packageJsonPath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Read and parse package.json\n */\nexport async function readPackageJson(targetDir: string): Promise<any> {\n  const packageJsonPath = path.join(targetDir, \"package.json\");\n  const content = await fs.readFile(packageJsonPath, \"utf-8\");\n  return JSON.parse(content);\n}\n\n/**\n * Check which dependencies are missing from a required list\n */\nexport async function getMissingDependenciesFor(\n  targetDir: string,\n  requiredDeps: { dependencies: readonly string[]; devDependencies: readonly string[] }\n): Promise<{\n  dependencies: string[];\n  devDependencies: string[];\n}> {\n  if (!(await hasPackageJson(targetDir))) {\n    // If no package.json, all dependencies are missing\n    return {\n      dependencies: [...requiredDeps.dependencies],\n      devDependencies: [...requiredDeps.devDependencies],\n    };\n  }\n\n  const packageJson = await readPackageJson(targetDir);\n  const existingDeps = {\n    ...packageJson.dependencies,\n    ...packageJson.devDependencies,\n  };\n\n  const missingDeps = requiredDeps.dependencies.filter(\n    (dep) => !existingDeps[dep]\n  );\n\n  const missingDevDeps = requiredDeps.devDependencies.filter(\n    (dep) => !existingDeps[dep]\n  );\n\n  return {\n    dependencies: missingDeps,\n    devDependencies: missingDevDeps,\n  };\n}\n\n/**\n * Check which dependencies are missing (for hooks - backwards compatible)\n */\nexport async function getMissingDependencies(targetDir: string): Promise<{\n  dependencies: string[];\n  devDependencies: string[];\n}> {\n  return getMissingDependenciesFor(targetDir, HOOKS_DEPENDENCIES);\n}\n\n/**\n * Check if @stacks/transactions is installed and warn if not\n */\nexport async function checkBaseDependencies(targetDir: string): Promise<void> {\n  const missing = await getMissingDependenciesFor(targetDir, BASE_DEPENDENCIES);\n\n  if (missing.dependencies.length > 0) {\n    console.log(chalk.yellow(\"\\nâš  Required peer dependency not found: @stacks/transactions\"));\n    console.log(chalk.gray(\"  The generated code requires @stacks/transactions to work.\"));\n    console.log(chalk.gray(\"  Install it with:\"));\n\n    const packageManager = await getPackageManager(targetDir);\n    const installCmd = packageManager === \"npm\" ? \"install\" : \"add\";\n    console.log(chalk.cyan(`    ${packageManager} ${installCmd} @stacks/transactions\\n`));\n  }\n}\n\n/**\n * Install missing dependencies\n */\nexport async function installDependencies(\n  targetDir: string,\n  dependencies: string[],\n  devDependencies: string[] = []\n): Promise<void> {\n  const packageManager = await getPackageManager(targetDir);\n\n  // Install regular dependencies\n  if (dependencies.length > 0) {\n    console.log(chalk.gray(`  Installing dependencies: ${dependencies.join(\", \")}`));\n\n    try {\n      const installCmd = packageManager === \"npm\" ? \"install\" : \"add\";\n      await execa(packageManager, [installCmd, ...dependencies], {\n        cwd: targetDir,\n      });\n      console.log(chalk.green(`âœ“ Installed dependencies: ${dependencies.join(\", \")}`));\n    } catch (error) {\n      console.error(chalk.red(\"âœ— Failed to install dependencies\"));\n      throw error;\n    }\n  }\n\n  // Install dev dependencies\n  if (devDependencies.length > 0) {\n    console.log(chalk.gray(`  Installing dev dependencies: ${devDependencies.join(\", \")}`));\n\n    try {\n      let installCmd: string[];\n      switch (packageManager) {\n        case \"npm\":\n          installCmd = [\"install\", \"--save-dev\"];\n          break;\n        case \"yarn\":\n          installCmd = [\"add\", \"--dev\"];\n          break;\n        case \"pnpm\":\n          installCmd = [\"add\", \"--save-dev\"];\n          break;\n        case \"bun\":\n          installCmd = [\"add\", \"--dev\"];\n          break;\n        default:\n          installCmd = [\"install\", \"--save-dev\"];\n      }\n\n      await execa(packageManager, [...installCmd, ...devDependencies], {\n        cwd: targetDir,\n      });\n      console.log(chalk.green(`âœ“ Installed dev dependencies: ${devDependencies.join(\", \")}`));\n    } catch (error) {\n      console.error(chalk.red(\"âœ— Failed to install dev dependencies\"));\n      throw error;\n    }\n  }\n}\n\n/**\n * Check and install missing dependencies for hooks\n */\nexport async function ensureHooksDependencies(\n  targetDir: string\n): Promise<void> {\n  const missing = await getMissingDependencies(targetDir);\n\n  if (\n    missing.dependencies.length === 0 &&\n    missing.devDependencies.length === 0\n  ) {\n    console.log(\n      chalk.green(\"âœ“ All required dependencies are already installed\")\n    );\n    return;\n  }\n\n  console.log(\n    chalk.yellow(\"\\nðŸ“¦ Installing missing dependencies for React hooks...\")\n  );\n\n  if (missing.dependencies.length > 0) {\n    console.log(\n      chalk.gray(`Missing dependencies: ${missing.dependencies.join(\", \")}`)\n    );\n  }\n\n  if (missing.devDependencies.length > 0) {\n    console.log(\n      chalk.gray(\n        `Missing dev dependencies: ${missing.devDependencies.join(\", \")}`\n      )\n    );\n  }\n\n  await installDependencies(\n    targetDir,\n    missing.dependencies,\n    missing.devDependencies\n  );\n}",
    "packages/cli/src/utils/type-mapping.ts": "/**\n * Shared type mapping utility for Clarity types to TypeScript types\n *\n * This module provides a single, consistent implementation for mapping\n * Clarity types to their TypeScript equivalents, used across all generators.\n */\n\nimport {\n  toCamelCase,\n  isClarityList,\n  isClarityTuple,\n  isClarityOptional,\n  isClarityResponse,\n  isClarityBuffer,\n  isClarityStringAscii,\n  isClarityStringUtf8,\n  type ClarityType,\n} from \"@secondlayer/clarity-types\";\n\n/**\n * Map a Clarity type to its TypeScript type string representation\n *\n * @param type - The Clarity type definition from an ABI\n * @returns The TypeScript type string (e.g., \"bigint\", \"string\", \"{ field: bigint }\")\n */\nexport function clarityTypeToTS(type: ClarityType): string {\n  // Handle string primitive types\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"uint128\":\n      case \"int128\":\n        return \"bigint\";\n      case \"bool\":\n        return \"boolean\";\n      case \"principal\":\n      case \"trait_reference\":\n        return \"string\";\n      default: {\n        // Handle shorthand string formats (e.g., \"string-ascii\", \"string-utf8\", \"buff\")\n        // Cast to string since TypeScript narrows to never in exhaustive switches\n        const typeStr = type as string;\n        // Handle \"none\" type (commonly used in response types)\n        if (typeStr === \"none\") {\n          return \"null\";\n        }\n        if (typeStr.includes(\"string\") || typeStr.includes(\"ascii\") || typeStr.includes(\"utf8\")) {\n          return \"string\";\n        }\n        if (typeStr.includes(\"buff\")) {\n          return \"Uint8Array | string | { type: 'ascii' | 'utf8' | 'hex'; value: string }\";\n        }\n        if (typeStr.includes(\"uint\") || typeStr.includes(\"int\")) {\n          return \"bigint\";\n        }\n        return \"any\";\n      }\n    }\n  }\n\n  // Handle buffer types - support flexible input\n  if (isClarityBuffer(type)) {\n    return \"Uint8Array | string | { type: 'ascii' | 'utf8' | 'hex'; value: string }\";\n  }\n\n  // Handle string types\n  if (isClarityStringAscii(type) || isClarityStringUtf8(type)) {\n    return \"string\";\n  }\n\n  // Handle optional types\n  if (isClarityOptional(type)) {\n    const innerType = clarityTypeToTS(type.optional);\n    // Wrap union types in parentheses for correct precedence\n    if (innerType.includes(\" | \") && !innerType.startsWith(\"(\")) {\n      return `(${innerType}) | null`;\n    }\n    return `${innerType} | null`;\n  }\n\n  // Handle list types\n  if (isClarityList(type)) {\n    const innerType = clarityTypeToTS(type.list.type);\n    // Wrap union types in parentheses for correct precedence\n    if (innerType.includes(\" | \") && !innerType.startsWith(\"(\")) {\n      return `(${innerType})[]`;\n    }\n    return `${innerType}[]`;\n  }\n\n  // Handle tuple types\n  if (isClarityTuple(type)) {\n    const fields = type.tuple\n      .map((field) => `${toCamelCase(field.name)}: ${clarityTypeToTS(field.type)}`)\n      .join(\"; \");\n    return `{ ${fields} }`;\n  }\n\n  // Handle response types\n  if (isClarityResponse(type)) {\n    const okType = clarityTypeToTS(type.response.ok);\n    const errType = clarityTypeToTS(type.response.error);\n    return `{ ok: ${okType} } | { err: ${errType} }`;\n  }\n\n  // Fallback for unknown types\n  return \"any\";\n}\n\n/**\n * Map a Clarity argument definition to its TypeScript type\n * This is a convenience wrapper that extracts the type from an argument object\n *\n * @param arg - An argument object with a `type` property\n * @returns The TypeScript type string\n */\nexport function getTypeForArg(arg: { type: ClarityType }): string {\n  return clarityTypeToTS(arg.type);\n}\n\n/**\n * Generate a TypeScript type signature for function arguments\n *\n * @param args - Array of argument definitions with name and type\n * @returns TypeScript type string like \"{ arg1: bigint; arg2: string }\"\n */\nexport function generateArgsTypeSignature(\n  args: readonly { name: string; type: ClarityType }[]\n): string {\n  if (args.length === 0) return \"void\";\n\n  const argsList = args\n    .map((arg) => `${toCamelCase(arg.name)}: ${clarityTypeToTS(arg.type)}`)\n    .join(\"; \");\n  return `{ ${argsList} }`;\n}",
    "packages/clarity-docs/package.json": "{\n  \"name\": \"@secondlayer/clarity-docs\",\n  \"version\": \"0.2.1\",\n  \"description\": \"ClarityDoc - Documentation comment standard and tooling for Clarity smart contracts\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    }\n  },\n  \"files\": [\n    \"dist\",\n    \"src\"\n  ],\n  \"scripts\": {\n    \"build\": \"bunup\",\n    \"dev\": \"bunup --watch\",\n    \"test\": \"vitest\",\n    \"test:ui\": \"vitest --ui\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"prepublishOnly\": \"bun run build\"\n  },\n  \"keywords\": [\n    \"stacks\",\n    \"clarity\",\n    \"documentation\",\n    \"claritydoc\",\n    \"smart-contracts\",\n    \"typescript\"\n  ],\n  \"author\": \"Ryan Waits\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@secondlayer/clarity-types\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@vitest/ui\": \"^1.2.1\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  }\n}",
    "packages/clarity-types/src/index.ts": "/**\n * clarity-types\n * TypeScript type definitions and utilities for Clarity smart contract ABIs\n */\n\n// Primitive and composite types\nexport * from \"./types/primitives\";\nexport * from \"./types/composites\";\nexport * from \"./types/mappings\";\n\n// ABI function types and extractors\nexport * from \"./abi/functions\";\nexport * from \"./abi/extractors\";\n\n// Runtime validation guards\nexport * from \"./validation/guards\";\n\n// Value converters\nexport * from \"./converters\";\n\n// Integration types for @stacks/connect\nexport * from \"./integration/connect\";\n\n// Shared utilities\nexport * from \"./utils\";\n\n// Re-export key types for convenience\nexport type { ClarityType } from \"./types/composites\";\n\nexport type { ClarityToTS } from \"./types/mappings\";\n\nexport type {\n  ClarityContract,\n  ClarityFunction,\n  ClarityMap,\n  ClarityVariable,\n  VariableAccess,\n  ClarityFungibleToken,\n  ClarityNonFungibleToken,\n  ClarityTraitFunction,\n  ClarityTraitDefinition,\n} from \"./abi/functions\";\n\nexport type {\n  ExtractFunctionNames,\n  ExtractFunctionArgs,\n  ExtractFunctionOutput,\n  ExtractPrivateFunctions,\n  ExtractMapNames,\n  ExtractMap,\n  ExtractMapKey,\n  ExtractMapValue,\n  ExtractVariableNames,\n  ExtractVariable,\n  ExtractVariableType,\n  ExtractConstants,\n  ExtractDataVars,\n  ExtractFungibleTokenNames,\n  ExtractNonFungibleTokenNames,\n  ExtractNFTAssetType,\n  ExtractDefinedTraitNames,\n  ExtractImplementedTraits,\n} from \"./abi/extractors\";\n\nexport type {\n  ContractCallParams,\n  ReadOnlyCallParams,\n  ContractInterface,\n  ContractInterfaceWithMeta,\n} from \"./integration/connect\";\n\nexport type { ToCamelCase } from \"./utils\";",
    "packages/cli/src/commands/init.ts": "import { promises as fs } from \"fs\";\nimport path from \"path\";\nimport chalk from \"chalk\";\n\n/**\n * Init command - creates a default config file\n */\n\nexport async function init() {\n  const configPath = path.join(process.cwd(), \"secondlayer.config.ts\");\n\n  // Check if config already exists\n  try {\n    await fs.access(configPath);\n    console.log(chalk.yellow(\"âš  secondlayer.config.ts already exists\"));\n    return;\n  } catch {\n    // File doesn't exist, continue\n  }\n\n  // Check for Clarinet project\n  const hasClarinetProject = await fileExists(\"./Clarinet.toml\");\n\n  let config: string;\n\n  if (hasClarinetProject) {\n    // Generate plugin-based config for Clarinet projects\n    config = `import { defineConfig } from '@secondlayer/cli';\nimport { clarinet } from '@secondlayer/cli/plugins';\n\nexport default defineConfig({\n  out: './src/generated/contracts.ts',\n  plugins: [\n    clarinet() // Found Clarinet.toml in current directory\n  ]\n});`;\n  } else {\n    // Generate basic config for non-Clarinet projects\n    config = `import { defineConfig } from '@secondlayer/cli';\n\nexport default defineConfig({\n  out: './src/generated/contracts.ts',\n  plugins: [],\n});`;\n  }\n\n  // Write config file\n  await fs.writeFile(configPath, config);\n\n  console.log(chalk.green(\"âœ“ Created `secondlayer.config.ts`\"));\n\n  console.log(\n    \"\\nRun `secondlayer generate` to generate type-safe interfaces, functions, and hooks!\"\n  );\n}\n\nasync function fileExists(filePath: string): Promise<boolean> {\n  try {\n    await fs.access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}",
    "packages/cli/src/parsers/clarity.ts": "import { promises as fs } from \"fs\";\nimport type {\n  ClarityContract,\n  ClarityFunction,\n  ClarityType,\n} from \"@secondlayer/clarity-types\";\nimport { normalizeAbi } from \"../utils/abi-compat\";\n\n/**\n * Basic Clarity contract parser\n * This is a simplified regex-based parser for basic contracts.\n * For complex contracts, use the contract address to fetch ABI from the API.\n */\n\nexport async function parseClarityFile(\n  filePath: string\n): Promise<ClarityContract> {\n  try {\n    const content = await fs.readFile(filePath, \"utf-8\");\n    const result = parseClarityContent(content);\n\n    if (result.functions.length === 0) {\n      console.warn(\n        `âš ï¸  No functions found in ${filePath}. ` +\n          `For complex contracts, deploy first and use the contract address instead.`\n      );\n    }\n\n    return result;\n  } catch (error) {\n    throw new Error(\n      `Unable to parse ${filePath}. ` +\n        `For complex contracts, deploy first and use the contract address instead.\\n` +\n        `Original error: ${error}`\n    );\n  }\n}\n\nexport function parseClarityContent(content: string): ClarityContract {\n  const functions: ClarityFunction[] = [];\n\n  const functionRegex =\n    /\\(define-(public|read-only|private)\\s+\\(([^)]+)\\)([\\s\\S]*?)\\)\\s*$/gm;\n\n  let match;\n  while ((match = functionRegex.exec(content)) !== null) {\n    const [, access, signature, body] = match;\n    const func = parseFunctionSignature(signature, access as any, body);\n    if (func) {\n      functions.push(func);\n    }\n  }\n\n  return { functions };\n}\n\nfunction parseFunctionSignature(\n  signature: string,\n  access: \"public\" | \"read-only\" | \"private\",\n  body: string\n): ClarityFunction | null {\n  // Parse function name and arguments\n  const parts = signature.trim().split(/\\s+/);\n  const name = parts[0];\n\n  const args: Array<{ name: string; type: ClarityType }> = [];\n\n  // Parse arguments (simplified)\n  for (let i = 1; i < parts.length; i += 2) {\n    if (parts[i] && parts[i + 1]) {\n      const argName = parts[i].replace(/[()]/g, \"\");\n      const argType = parseType(parts[i + 1]);\n      if (argType) {\n        args.push({ name: argName, type: argType });\n      }\n    }\n  }\n\n  // Infer return type from body (simplified)\n  const outputs = inferReturnType(body);\n\n  return {\n    name,\n    access,\n    args,\n    outputs,\n  };\n}\n\nfunction parseType(typeStr: string): ClarityType | null {\n  typeStr = typeStr.replace(/[()]/g, \"\").trim();\n\n  // Basic type mappings\n  switch (typeStr) {\n    case \"uint\":\n    case \"uint128\":\n      return \"uint128\";\n    case \"int\":\n    case \"int128\":\n      return \"int128\";\n    case \"bool\":\n      return \"bool\";\n    case \"principal\":\n      return \"principal\";\n    case \"trait_reference\":\n      return \"principal\";\n    default:\n      // Handle complex types (simplified)\n      if (typeStr.startsWith(\"string-ascii\")) {\n        return { \"string-ascii\": { length: 256 } };\n      }\n      if (typeStr.startsWith(\"string-utf8\")) {\n        return { \"string-utf8\": { length: 256 } };\n      }\n      if (typeStr.startsWith(\"buff\")) {\n        return { buff: { length: 32 } };\n      }\n      // Default to uint128 for unknown types\n      return \"uint128\";\n  }\n}\n\nfunction inferReturnType(body: string): ClarityType {\n  // Simplified return type inference\n  if (body.includes(\"(ok\")) {\n    if (body.includes(\"(err\")) {\n      return {\n        response: {\n          ok: \"bool\",\n          error: \"uint128\",\n        },\n      };\n    }\n  }\n\n  if (body.includes(\"true\") || body.includes(\"false\")) {\n    return \"bool\";\n  }\n\n  return \"bool\";\n}\n\n/**\n * Parse ABI from API response\n * Uses the abi-compat normalization layer for consistent handling of different ABI formats\n */\nexport function parseApiResponse(apiResponse: any): ClarityContract {\n  try {\n    return normalizeAbi(apiResponse);\n  } catch (error) {\n    throw new Error(`Failed to parse API response: ${error}`);\n  }\n}",
    "packages/cli/src/plugins/react/generators/generic.ts": "/**\n * Generic Stacks hooks generator for React plugin\n */\n\nimport { formatCode } from \"../../../utils/format\";\n\nconst GENERIC_HOOKS = [\n  \"useAccount\",\n  \"useConnect\",\n  \"useDisconnect\",\n  \"useNetwork\",\n  \"useContract\",\n  \"useOpenSTXTransfer\",\n  \"useSignMessage\",\n  \"useDeployContract\",\n  \"useReadContract\",\n  \"useTransaction\",\n  \"useBlock\",\n  \"useAccountTransactions\",\n  \"useWaitForTransaction\",\n] as const;\n\nexport async function generateGenericHooks(\n  excludeList: string[] = []\n): Promise<string> {\n  // Filter out excluded hooks\n  const hooksToGenerate = GENERIC_HOOKS.filter(\n    (hookName) => !excludeList.includes(hookName)\n  );\n\n  const imports = `import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { useState, useCallback } from 'react'\nimport { useSecondLayerConfig } from './provider'\nimport { connect, disconnect, isConnected, request, openContractCall as stacksOpenContractCall, openSTXTransfer, openSignatureRequestPopup, openContractDeploy } from '@stacks/connect'\nimport { Cl, validateStacksAddress } from '@stacks/transactions'\nimport type { PostCondition } from '@stacks/transactions'\nimport type { ExtractFunctionArgs, ExtractFunctionNames, ClarityContract } from '@secondlayer/clarity-types'\n\nconst API_URLS: Record<string, string> = {\n  mainnet: 'https://api.hiro.so',\n  testnet: 'https://api.testnet.hiro.so',\n  devnet: 'http://localhost:3999'\n}\n\nasync function fetchTransaction({ txId, network, apiUrl }: { txId: string; network?: string; apiUrl?: string }): Promise<any> {\n  const baseUrl = apiUrl || API_URLS[network || 'mainnet']\n  const response = await fetch(\\`\\${baseUrl}/extended/v1/tx/\\${txId}\\`)\n  if (!response.ok) throw new Error(\\`Failed to fetch transaction: \\${response.statusText}\\`)\n  return response.json()\n}\n\nasync function fetchBlock({ height, network, apiUrl }: { height: number; network?: string; apiUrl?: string }): Promise<any> {\n  const baseUrl = apiUrl || API_URLS[network || 'mainnet']\n  const response = await fetch(\\`\\${baseUrl}/extended/v1/block/by_height/\\${height}\\`)\n  if (!response.ok) throw new Error(\\`Failed to fetch block: \\${response.statusText}\\`)\n  return response.json()\n}\n\nasync function fetchAccountTransactions({ address, network, apiUrl }: { address: string; network?: string; apiUrl?: string }): Promise<any> {\n  const baseUrl = apiUrl || API_URLS[network || 'mainnet']\n  const response = await fetch(\\`\\${baseUrl}/extended/v1/address/\\${address}/transactions\\`)\n  if (!response.ok) throw new Error(\\`Failed to fetch transactions: \\${response.statusText}\\`)\n  return response.json()\n}`;\n\n  const header = `/**\n * Generated generic Stacks React hooks\n * DO NOT EDIT MANUALLY\n */`;\n\n  const hooksCode = hooksToGenerate\n    .map((hookName) => generateGenericHook(hookName))\n    .filter(Boolean)\n    .join(\"\\n\\n\");\n\n  const code = `${imports}\\n\\n${header}\\n\\n${hooksCode}`;\n\n  return formatCode(code);\n}\n\nfunction generateGenericHook(hookName: string): string {\n  switch (hookName) {\n    case \"useAccount\":\n      return `export function useAccount() {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['stacks-account', config.network],\n    queryFn: async () => {\n      try {\n        // Check if already connected using @stacks/connect v8\n        const connected = isConnected()\n        \n        if (!connected) {\n          return {\n            address: undefined,\n            addresses: undefined,\n            isConnected: false,\n            isConnecting: false,\n            isDisconnected: true,\n            status: 'disconnected' as const\n          }\n        }\n\n        // Get addresses using @stacks/connect v8 request method (SIP-030)\n        const result = await request('stx_getAddresses')\n        \n        if (!result || !result.addresses || result.addresses.length === 0) {\n          return {\n            address: undefined,\n            addresses: undefined,\n            isConnected: false,\n            isConnecting: false,\n            isDisconnected: true,\n            status: 'disconnected' as const\n          }\n        }\n\n        // Extract STX addresses from the response\n        const stxAddresses = result.addresses\n          .filter((addr: any) => addr.address.startsWith('SP') || addr.address.startsWith('ST'))\n          .map((addr: any) => addr.address)\n\n        return {\n          address: stxAddresses[0] || undefined,\n          addresses: stxAddresses,\n          isConnected: true,\n          isConnecting: false,\n          isDisconnected: false,\n          status: 'connected' as const\n        }\n      } catch (error) {\n        // Handle case where wallet is not available or user rejected\n        return {\n          address: undefined,\n          addresses: undefined,\n          isConnected: false,\n          isConnecting: false,\n          isDisconnected: true,\n          status: 'disconnected' as const\n        }\n      }\n    },\n    refetchOnWindowFocus: false,\n    retry: false,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchInterval: 1000 * 30, // Refetch every 30 seconds to detect wallet changes\n  })\n}`;\n\n    case \"useConnect\":\n      return `export function useConnect() {\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (options: { forceWalletSelect?: boolean } = {}) => {\n      // Use @stacks/connect v8 connect method\n      return await connect(options)\n    },\n    onSuccess: () => {\n      // Invalidate account queries to refetch connection state\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('Connection failed:', error)\n    }\n  })\n\n  return {\n    // Custom connect function that works without arguments\n    connect: (options?: { forceWalletSelect?: boolean }) => {\n      return mutation.mutate(options || {})\n    },\n    connectAsync: async (options?: { forceWalletSelect?: boolean }) => {\n      return mutation.mutateAsync(options || {})\n    },\n    // Expose all the mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset,\n    // Keep the original mutate/mutateAsync for advanced users\n    mutate: mutation.mutate,\n    mutateAsync: mutation.mutateAsync\n  }\n}`;\n\n    case \"useDisconnect\":\n      return `export function useDisconnect() {\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async () => {\n      // Use @stacks/connect v8 disconnect method\n      return await disconnect()\n    },\n    onSuccess: () => {\n      // Clear all cached data on disconnect\n      queryClient.clear()\n    },\n    onError: (error) => {\n      console.error('Disconnect failed:', error)\n    }\n  })\n\n  return {\n    // Custom disconnect function\n    disconnect: () => {\n      return mutation.mutate()\n    },\n    disconnectAsync: async () => {\n      return mutation.mutateAsync()\n    },\n    // Expose all the mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset,\n    // Keep the original mutate/mutateAsync for advanced users\n    mutate: mutation.mutate,\n    mutateAsync: mutation.mutateAsync\n  }\n}`;\n\n    case \"useNetwork\":\n      return `export function useNetwork() {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['stacks-network', config.network],\n    queryFn: async () => {\n      // Currently read-only from config\n      // Future: Use request('stx_getNetworks') when wallet support improves\n      const network = config.network\n      \n      return {\n        network,\n        isMainnet: network === 'mainnet',\n        isTestnet: network === 'testnet', \n        isDevnet: network === 'devnet',\n        // Future: Add switchNetwork when wallets support stx_networkChange\n        // switchNetwork: async (newNetwork: string) => {\n        //   return await request('wallet_changeNetwork', { network: newNetwork })\n        // }\n      }\n    },\n    staleTime: Infinity, // Network config rarely changes\n    refetchOnWindowFocus: false,\n    retry: false\n  })\n}`;\n\n    case \"useContract\":\n      return `export function useContract() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  const [isRequestPending, setIsRequestPending] = useState(false)\n  \n  // Helper function to convert JS values to Clarity values based on ABI\n  const convertArgsWithAbi = (args: any, abiArgs: any[]): any[] => {\n    if (!abiArgs || abiArgs.length === 0) return []\n    \n    return abiArgs.map((abiArg, index) => {\n      const argValue = Array.isArray(args) \n        ? args[index] \n        : args[abiArg.name] || args[abiArg.name.replace(/-/g, '').replace(/_/g, '')]\n      return convertJSValueToClarityValue(argValue, abiArg.type)\n    })\n  }\n\n  // Helper function to convert buffer values with auto-detection\n  const convertBufferValue = (value: any): any => {\n    // Direct Uint8Array\n    if (value instanceof Uint8Array) {\n      return Cl.buffer(value)\n    }\n    \n    // Object notation with explicit type\n    if (typeof value === 'object' && value !== null && value.type && value.value) {\n      switch (value.type) {\n        case 'ascii':\n          return Cl.bufferFromAscii(value.value)\n        case 'utf8':\n          return Cl.bufferFromUtf8(value.value)\n        case 'hex':\n          return Cl.bufferFromHex(value.value)\n        default:\n          throw new Error(\\`Unsupported buffer type: \\${value.type}\\`)\n      }\n    }\n    \n    // Auto-detect string type\n    if (typeof value === 'string') {\n      // 1. Check for hex (0x prefix or pure hex pattern)\n      if (value.startsWith('0x') || /^[0-9a-fA-F]+$/.test(value)) {\n        return Cl.bufferFromHex(value)\n      }\n      \n      // 2. Check for non-ASCII characters (UTF-8)\n      if (!/^[\\\\x00-\\\\x7F]*$/.test(value)) {\n        return Cl.bufferFromUtf8(value)\n      }\n      \n      // 3. Default to ASCII for simple ASCII strings\n      return Cl.bufferFromAscii(value)\n    }\n    \n    throw new Error(\\`Invalid buffer value: \\${value}\\`)\n  }\n\n  // Helper function to convert a single JS value to ClarityValue\n  const convertJSValueToClarityValue = (value: any, type: any): any => {\n    if (typeof type === 'string') {\n      switch (type) {\n        case 'uint128':\n          return Cl.uint(value)\n        case 'int128':\n          return Cl.int(value)\n        case 'bool':\n          return Cl.bool(value)\n        case 'principal':\n          if (!validateStacksAddress(value.split('.')[0])) {\n            throw new Error('Invalid Stacks address format')\n          }\n          if (value.includes('.')) {\n            const [address, contractName] = value.split('.')\n            return Cl.contractPrincipal(address, contractName)\n          } else {\n            return Cl.standardPrincipal(value)\n          }\n        default:\n          return value\n      }\n    }\n\n    if (type['string-ascii']) {\n      return Cl.stringAscii(value)\n    }\n\n    if (type['string-utf8']) {\n      return Cl.stringUtf8(value)\n    }\n\n    if (type.buff) {\n      return convertBufferValue(value)\n    }\n\n    if (type.optional) {\n      return value !== null ? Cl.some(convertJSValueToClarityValue(value, type.optional)) : Cl.none()\n    }\n\n    if (type.list) {\n      return Cl.list(value.map((item: any) => convertJSValueToClarityValue(item, type.list.type)))\n    }\n\n    if (type.tuple) {\n      const tupleData = type.tuple.reduce((acc: any, field: any) => {\n        acc[field.name] = convertJSValueToClarityValue(value[field.name], field.type)\n        return acc\n      }, {})\n      return Cl.tuple(tupleData)\n    }\n\n    if (type.response) {\n      return 'ok' in value \n        ? Cl.ok(convertJSValueToClarityValue(value.ok, type.response.ok))\n        : Cl.error(convertJSValueToClarityValue(value.err, type.response.error))\n    }\n\n    return value\n  }\n\n  // Helper function to find a function in an ABI by name\n  const findFunctionInAbi = (abi: any, functionName: string): any => {\n    if (!abi || !abi.functions) return null\n    return abi.functions.find((func: any) => func.name === functionName)\n  }\n  \n  // Legacy function - unchanged, backward compatible\n  const legacyOpenContractCall = useCallback(async (params: {\n    contractAddress: string;\n    contractName: string;\n    functionName: string;\n    functionArgs: any[]; // Pre-converted Clarity values\n    network?: string;\n    postConditions?: PostCondition[];\n    attachment?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    setIsRequestPending(true)\n    \n    try {\n      const { contractAddress, contractName, functionName, functionArgs, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      const contract = \\`\\${contractAddress}.\\${contractName}\\`\n      \n      // Try @stacks/connect v8 stx_callContract first (SIP-030)\n      try {\n        const result = await request('stx_callContract', {\n          contract,\n          functionName,\n          functionArgs,\n          network,\n          ...options\n        })\n        \n        // Invalidate relevant queries on success\n        queryClient.invalidateQueries({ \n          queryKey: ['stacks-account'] \n        })\n        \n        onFinish?.(result)\n        return result\n      } catch (connectError) {\n        // Fallback to openContractCall for broader wallet compatibility\n        console.warn('stx_callContract not supported, falling back to openContractCall:', connectError)\n        \n        return new Promise((resolve, reject) => {\n          stacksOpenContractCall({\n            contractAddress,\n            contractName,\n            functionName,\n            functionArgs,\n            network,\n            ...options,\n            onFinish: (data: any) => {\n              // Invalidate relevant queries on success\n              queryClient.invalidateQueries({ \n                queryKey: ['stacks-account'] \n              })\n              \n              onFinish?.(data)\n              resolve(data)\n            },\n            onCancel: () => {\n              onCancel?.()\n              reject(new Error('User cancelled transaction'))\n            }\n          })\n        })\n      }\n    } catch (error) {\n      console.error('Contract call failed:', error)\n      throw error instanceof Error ? error : new Error('Contract call failed')\n    } finally {\n      setIsRequestPending(false)\n    }\n  }, [config.network, queryClient])\n\n  // Enhanced function - requires ABI, auto-converts JS values\n  const openContractCall = useCallback(async <\n    T extends ClarityContract,\n    FN extends ExtractFunctionNames<T>\n  >(params: {\n    contractAddress: string;\n    contractName: string;\n    functionName: FN;\n    abi: T;\n    functionArgs: ExtractFunctionArgs<T, FN>;\n    network?: string;\n    postConditions?: PostCondition[];\n    attachment?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    setIsRequestPending(true)\n    \n    try {\n      const { contractAddress, contractName, functionName, functionArgs, abi, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      const contract = \\`\\${contractAddress}.\\${contractName}\\`\n      \n      // Find the function in the ABI and convert args\n      const abiFunction = findFunctionInAbi(abi, functionName)\n      if (!abiFunction) {\n        throw new Error(\\`Function '\\${functionName}' not found in ABI\\`)\n      }\n      \n      const processedArgs = convertArgsWithAbi(functionArgs, abiFunction.args || [])\n      \n      // Try @stacks/connect v8 stx_callContract first (SIP-030)\n      try {\n        const result = await request('stx_callContract', {\n          contract,\n          functionName,\n          functionArgs: processedArgs,\n          network,\n          ...options\n        })\n        \n        // Invalidate relevant queries on success\n        queryClient.invalidateQueries({ \n          queryKey: ['stacks-account'] \n        })\n        \n        onFinish?.(result)\n        return result\n      } catch (connectError) {\n        // Fallback to openContractCall for broader wallet compatibility\n        console.warn('stx_callContract not supported, falling back to openContractCall:', connectError)\n        \n        return new Promise((resolve, reject) => {\n          stacksOpenContractCall({\n            contractAddress,\n            contractName,\n            functionName,\n            functionArgs: processedArgs,\n            network,\n            ...options,\n            onFinish: (data: any) => {\n              // Invalidate relevant queries on success\n              queryClient.invalidateQueries({ \n                queryKey: ['stacks-account'] \n              })\n              \n              onFinish?.(data)\n              resolve(data)\n            },\n            onCancel: () => {\n              onCancel?.()\n              reject(new Error('User cancelled transaction'))\n            }\n          })\n        })\n      }\n    } catch (error) {\n      console.error('Contract call failed:', error)\n      throw error instanceof Error ? error : new Error('Contract call failed')\n    } finally {\n      setIsRequestPending(false)\n    }\n  }, [config.network, queryClient])\n\n  return {\n    legacyOpenContractCall,\n    openContractCall,\n    isRequestPending\n  }\n}`;\n\n    case \"useReadContract\":\n      return `export function useReadContract<TArgs = any, TResult = any>(params: {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  args?: TArgs;\n  network?: 'mainnet' | 'testnet' | 'devnet';\n  enabled?: boolean;\n}) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery<TResult>({\n    queryKey: ['read-contract', params.contractAddress, params.contractName, params.functionName, params.args, params.network || config.network],\n    queryFn: async () => {\n      const { fetchCallReadOnlyFunction } = await import('@stacks/transactions')\n      \n      // For now, we'll need to handle the args conversion here\n      // In the future, we could integrate with the contract interface for automatic conversion\n      let functionArgs: any[] = []\n      \n      if (params.args) {\n        // This is a simplified conversion - in practice, we'd need the ABI to do proper conversion\n        // For now, we'll assume the args are already in the correct format or simple types\n        if (Array.isArray(params.args)) {\n          functionArgs = params.args\n        } else if (typeof params.args === 'object') {\n          // Convert object args to array (this is a basic implementation)\n          functionArgs = Object.values(params.args)\n        } else {\n          functionArgs = [params.args]\n        }\n      }\n      \n      return await fetchCallReadOnlyFunction({\n        contractAddress: params.contractAddress,\n        contractName: params.contractName,\n        functionName: params.functionName,\n        functionArgs,\n        network: params.network || config.network || 'mainnet',\n        senderAddress: config.senderAddress || 'SP000000000000000000002Q6VF78'\n      }) as TResult\n    },\n    enabled: params.enabled ?? true\n  })\n}`;\n\n    case \"useTransaction\":\n      return `export function useTransaction(txId?: string) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['transaction', txId, config.network],\n    queryFn: () => fetchTransaction({\n      txId: txId!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: !!txId\n  })\n}`;\n\n    case \"useBlock\":\n      return `export function useBlock(height?: number) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['block', height, config.network],\n    queryFn: () => fetchBlock({\n      height: height!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: typeof height === 'number'\n  })\n}`;\n\n    case \"useAccountTransactions\":\n      return `export function useAccountTransactions(address?: string) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['account-transactions', address, config.network],\n    queryFn: () => fetchAccountTransactions({\n      address: address!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: !!address\n  })\n}`;\n\n    case \"useWaitForTransaction\":\n      return `export function useWaitForTransaction(txId?: string) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['wait-for-transaction', txId, config.network],\n    queryFn: () => fetchTransaction({\n      txId: txId!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: !!txId,\n    refetchInterval: (data) => {\n      // Stop polling when transaction is complete\n      if (data?.tx_status === 'success' || \n          data?.tx_status === 'abort_by_response' || \n          data?.tx_status === 'abort_by_post_condition') {\n        return false\n      }\n      return 2000 // Poll every 2 seconds\n    },\n    staleTime: 0 // Always refetch\n  })\n}`;\n\n    case \"useOpenSTXTransfer\":\n      return `export function useOpenSTXTransfer() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      recipient: string;\n      amount: string | number;\n      memo?: string;\n      network?: string;\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }) => {\n      const { recipient, amount, memo, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      \n      return new Promise((resolve, reject) => {\n        openSTXTransfer({\n          recipient,\n          amount: amount.toString(),\n          memo,\n          network,\n          ...options,\n          onFinish: (data: any) => {\n            onFinish?.(data)\n            resolve(data)\n          },\n          onCancel: () => {\n            onCancel?.()\n            reject(new Error('User cancelled transaction'))\n          }\n        })\n      })\n    },\n    onSuccess: () => {\n      // Invalidate relevant queries on success\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('STX transfer failed:', error)\n    }\n  })\n\n  const openSTXTransfer = useCallback(async (params: {\n    recipient: string;\n    amount: string | number;\n    memo?: string;\n    network?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    return mutation.mutateAsync(params)\n  }, [mutation])\n\n  return {\n    openSTXTransfer,\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n\n    case \"useSignMessage\":\n      return `export function useSignMessage() {\n  const config = useSecondLayerConfig()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      message: string;\n      network?: string;\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }) => {\n      const { message, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      \n      return new Promise((resolve, reject) => {\n        openSignatureRequestPopup({\n          message,\n          network,\n          ...options,\n          onFinish: (data: any) => {\n            onFinish?.(data)\n            resolve(data)\n          },\n          onCancel: () => {\n            onCancel?.()\n            reject(new Error('User cancelled message signing'))\n          }\n        })\n      })\n    },\n    onError: (error) => {\n      console.error('Message signing failed:', error)\n    }\n  })\n\n  const signMessage = useCallback(async (params: {\n    message: string;\n    network?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    return mutation.mutateAsync(params)\n  }, [mutation])\n\n  return {\n    signMessage,\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n\n    case \"useDeployContract\":\n      return `export function useDeployContract() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      contractName: string;\n      codeBody: string;\n      network?: string;\n      postConditions?: PostCondition[];\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }) => {\n      const { contractName, codeBody, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      \n      return new Promise((resolve, reject) => {\n        openContractDeploy({\n          contractName,\n          codeBody,\n          network,\n          ...options,\n          onFinish: (data: any) => {\n            onFinish?.(data)\n            resolve(data)\n          },\n          onCancel: () => {\n            onCancel?.()\n            reject(new Error('User cancelled contract deployment'))\n          }\n        })\n      })\n    },\n    onSuccess: () => {\n      // Invalidate relevant queries on success\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('Contract deployment failed:', error)\n    }\n  })\n\n  const deployContract = useCallback(async (params: {\n    contractName: string;\n    codeBody: string;\n    network?: string;\n    postConditions?: PostCondition[];\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    return mutation.mutateAsync(params)\n  }, [mutation])\n\n  return {\n    deployContract,\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n\n    default:\n      return \"\";\n  }\n}",
    "packages/cli/src/utils/config.ts": "import { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { pathToFileURL } from \"url\";\nimport { createRequire } from \"module\";\nimport type { SecondLayerConfig, ConfigDefiner } from \"../types/config\";\nimport type { ResolvedConfig } from \"../types/plugin\";\nimport { PluginManager } from \"../core/plugin-manager\";\n\n/**\n * Config file utilities\n */\n\nconst CONFIG_FILE_NAMES = [\n  \"secondlayer.config.ts\",\n  \"secondlayer.config\",\n  \"secondlayer.config.mjs\",\n];\n\nexport async function findConfigFile(cwd: string): Promise<string | null> {\n  for (const fileName of CONFIG_FILE_NAMES) {\n    const filePath = path.join(cwd, fileName);\n    try {\n      await fs.access(filePath);\n      return filePath;\n    } catch {\n      // File doesn't exist, continue\n    }\n  }\n  return null;\n}\n\nexport async function loadConfig(configPath?: string): Promise<ResolvedConfig> {\n  const cwd = process.cwd();\n\n  const resolvedPath = configPath\n    ? path.resolve(cwd, configPath)\n    : await findConfigFile(cwd);\n\n  if (!resolvedPath) {\n    throw new Error(\n      \"No config file found. Create a secondlayer.config.ts file or specify a path with --config\"\n    );\n  }\n\n  let config: any;\n\n  if (resolvedPath.endsWith(\".ts\")) {\n    const code = await fs.readFile(resolvedPath, \"utf-8\");\n\n    // Transform TypeScript to JavaScript, replacing the @secondlayer/cli import\n    // For development/linked packages, we need to resolve to the actual package location\n    // This will work both for published packages and local development\n    let replacementPath: string;\n\n    try {\n      // Try to resolve @secondlayer/cli as if it were a normal package\n      const require = createRequire(import.meta.url);\n      const packagePath = require.resolve(\"@secondlayer/cli\");\n      replacementPath = pathToFileURL(packagePath).href;\n    } catch {\n      // Fallback: resolve relative to current module (for development)\n      const currentModuleDir = path.dirname(new URL(import.meta.url).pathname);\n      const indexPath = path.resolve(currentModuleDir, \"../index\");\n      replacementPath = pathToFileURL(indexPath).href;\n    }\n\n    const transformedCode = code.replace(\n      /from\\s+[\"']@secondlayer\\/cli[\"']/g,\n      `from '${replacementPath}'`\n    );\n\n    const { transformSync } = await import(\"esbuild\");\n    const result = transformSync(transformedCode, {\n      format: \"esm\",\n      target: \"node18\",\n      loader: \"ts\",\n    });\n\n    const tempPath = resolvedPath.replace(/\\.ts$/, \".mjs\");\n    await fs.writeFile(tempPath, result.code);\n\n    try {\n      const fileUrl = pathToFileURL(tempPath).href;\n      const module = await import(fileUrl);\n      config = module.default;\n    } finally {\n      await fs.unlink(tempPath).catch(() => {});\n    }\n  } else {\n    const fileUrl = pathToFileURL(resolvedPath).href;\n    const module = await import(fileUrl);\n    config = module.default;\n  }\n\n  if (!config) {\n    throw new Error(\"Config file must export a default configuration\");\n  }\n\n  if (typeof config === \"function\") {\n    config = config({} as SecondLayerConfig);\n  }\n\n  validateConfig(config);\n\n  // Process plugins if they exist\n  const pluginManager = new PluginManager();\n\n  if (config.plugins && Array.isArray(config.plugins)) {\n    for (const plugin of config.plugins) {\n      pluginManager.register(plugin);\n    }\n  }\n\n  // Transform config through plugins\n  const resolvedConfig = await pluginManager.transformConfig(config);\n\n  return resolvedConfig;\n}\n\nexport function validateConfig(\n  config: unknown\n): asserts config is SecondLayerConfig {\n  if (!config || typeof config !== \"object\") {\n    throw new Error(\"Config must be an object\");\n  }\n\n  const c = config as any;\n\n  // Contracts are optional now since plugins can provide them\n  if (c.contracts && !Array.isArray(c.contracts)) {\n    throw new Error(\"Config contracts must be an array\");\n  }\n\n  if (!c.out || typeof c.out !== \"string\") {\n    throw new Error(\"Config out must be a string path\");\n  }\n\n  // Validate contracts if they exist\n  if (c.contracts) {\n    for (const contract of c.contracts) {\n      if (!contract.address && !contract.source) {\n        throw new Error(\"Each contract must have either an address or source\");\n      }\n    }\n  }\n\n  // Validate plugins if they exist\n  if (c.plugins && !Array.isArray(c.plugins)) {\n    throw new Error(\"Config plugins must be an array\");\n  }\n}\n\nexport function defineConfig(config: SecondLayerConfig): SecondLayerConfig;\nexport function defineConfig(definer: ConfigDefiner): ConfigDefiner;\nexport function defineConfig(configOrDefiner: SecondLayerConfig | ConfigDefiner) {\n  return configOrDefiner;\n}",
    "packages/cli/src/cli.ts": "#!/usr/bin/env node\nimport { program } from \"commander\";\nimport pkg from \"../package.json\" with { type: \"json\" };\n\nconst { version } = pkg;\n\n/**\n * CLI entry point\n */\n\nprogram\n  .name(\"secondlayer\")\n  .description(\"CLI tool for generating type-safe Stacks contract interfaces\")\n  .version(version);\n\nprogram\n  .command(\"generate [files...]\")\n  .alias(\"gen\")\n  .description(\"Generate TypeScript interfaces from Clarity contracts\")\n  .option(\"-c, --config <path>\", \"Path to config file\")\n  .option(\"-o, --out <path>\", \"Output file path (required when using direct files)\")\n  .option(\"-k, --api-key <key>\", \"Hiro API key (or set HIRO_API_KEY env var)\")\n  .option(\"-w, --watch\", \"Watch for changes\")\n  .action(async (files, options) => {\n    const { generate } = await import(\"./commands/generate\");\n    await generate(files, options);\n  });\n\nprogram\n  .command(\"init\")\n  .description(\"Initialize a new secondlayer.config.ts file\")\n  .action(async () => {\n    const { init } = await import(\"./commands/init\");\n    await init();\n  });\n\nprogram.parse();",
    "packages/cli/bunup.config.ts": "import { defineConfig } from \"bunup\";\n\nconst sharedConfig = {\n  splitting: false,\n  sourcemap: \"linked\",\n  minify: false,\n  external: [\"esbuild\", \"@biomejs/js-api\", \"@biomejs/wasm-nodejs\", \"@hirosystems/clarinet-sdk\", \"@secondlayer/clarity-types\"],\n  noExternal: [\"chalk\", \"commander\", \"fast-glob\", \"got\", \"execa\"],\n  shims: true,\n  target: \"node\",\n} as const;\n\nexport default defineConfig([\n  {\n    name: \"main\",\n    entry: [\"src/index.ts\"],\n    format: [\"esm\"],\n    dts: true,\n    ...sharedConfig,\n  },\n  {\n    name: \"cli\",\n    entry: [\"src/cli.ts\"],\n    format: [\"esm\"],\n    dts: false,\n    ...sharedConfig,\n  },\n  {\n    name: \"plugins\",\n    entry: [\"src/plugins/index.ts\"],\n    format: [\"esm\"],\n    dts: true,\n    ...sharedConfig,\n  },\n  {\n    name: \"plugin-manager\",\n    entry: [\"src/core/plugin-manager.ts\"],\n    format: [\"esm\"],\n    dts: true,\n    ...sharedConfig,\n  },\n]);",
    "packages/cli/src/core/plugin-manager.ts": "/**\n * Plugin Manager for @secondlayer/cli\n * Handles plugin registration, lifecycle execution, and output management\n */\n\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { validateStacksAddress } from \"@stacks/transactions\";\nimport type {\n  SecondLayerPlugin,\n  UserConfig,\n  ResolvedConfig,\n  GenerateContext,\n  Logger,\n  PluginUtils,\n  GeneratedOutput,\n  ProcessedContract,\n  ContractConfig,\n  HookResult,\n  PluginExecutionContext,\n} from \"../types/plugin\";\nimport { isClarinetContract, isDirectFileContract } from \"../types/plugin\";\n\n/**\n * Core plugin manager that orchestrates plugin execution\n */\nexport class PluginManager {\n  private plugins: SecondLayerPlugin[] = [];\n  private logger: Logger;\n  private utils: PluginUtils;\n  private executionContext: PluginExecutionContext;\n\n  constructor() {\n    this.logger = this.createLogger();\n    this.utils = this.createUtils();\n    this.executionContext = {\n      phase: \"config\",\n      startTime: Date.now(),\n      results: new Map(),\n    };\n  }\n\n  /**\n   * Register a plugin\n   */\n  register(plugin: SecondLayerPlugin): void {\n    // Validate plugin\n    if (!plugin.name || !plugin.version) {\n      throw new Error(\"Plugin must have a name and version\");\n    }\n\n    // Check for duplicate plugin names\n    const existing = this.plugins.find((p) => p.name === plugin.name);\n    if (existing) {\n      throw new Error(\n        `Plugin \"${plugin.name}\" is already registered (version ${existing.version})`\n      );\n    }\n\n    this.plugins.push(plugin);\n    this.logger.debug(`Registered plugin: ${plugin.name}@${plugin.version}`);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getPlugins(): SecondLayerPlugin[] {\n    return [...this.plugins];\n  }\n\n  /**\n   * Transform user config through all plugins\n   */\n  async transformConfig(config: UserConfig): Promise<ResolvedConfig> {\n    this.executionContext.phase = \"config\";\n    let transformedConfig = { ...config };\n\n    for (const plugin of this.plugins) {\n      if (plugin.transformConfig) {\n        this.executionContext.currentPlugin = plugin;\n        try {\n          const result = await plugin.transformConfig(transformedConfig);\n          transformedConfig = result;\n          this.recordHookResult(plugin.name, \"transformConfig\", {\n            success: true,\n          });\n        } catch (error) {\n          const err = error as Error;\n          this.recordHookResult(plugin.name, \"transformConfig\", {\n            success: false,\n            error: err,\n          });\n          throw new Error(\n            `Plugin \"${plugin.name}\" failed during config transformation: ${err.message}`\n          );\n        }\n      }\n    }\n\n    // Add plugins array to resolved config\n    const resolvedConfig: ResolvedConfig = {\n      ...transformedConfig,\n      plugins: this.plugins,\n    };\n\n    return resolvedConfig;\n  }\n\n  /**\n   * Transform contracts through all plugins\n   */\n  async transformContracts(\n    contracts: ContractConfig[],\n    _config: ResolvedConfig\n  ): Promise<ProcessedContract[]> {\n    const processedContracts: ProcessedContract[] = [];\n\n    for (let contract of contracts) {\n      // Handle special case for Clarinet plugin contracts\n      if (isClarinetContract(contract) && contract.abi) {\n        // Convert Clarinet contracts directly to ProcessedContract format\n        const address =\n          typeof contract.address === \"string\" ? contract.address : \"\";\n        const [contractAddress, contractName] = address.split(\".\");\n        const processed: ProcessedContract = {\n          name: contract.name || contractName,\n          address: contractAddress,\n          contractName: contractName,\n          abi: contract.abi,\n          source: \"local\" as const,\n          metadata: { source: \"clarinet\" },\n        };\n        processedContracts.push(processed);\n        continue;\n      }\n\n      // Handle direct file mode contracts (already have ABIs parsed)\n      if (isDirectFileContract(contract) && contract.abi) {\n        const address =\n          typeof contract.address === \"string\" ? contract.address : \"\";\n        const [contractAddress, contractName] = address.split(\".\");\n        const processed: ProcessedContract = {\n          name: contract.name || contractName,\n          address: contractAddress,\n          contractName: contractName,\n          abi: contract.abi,\n          source: \"local\" as const,\n          metadata: { source: \"direct\" },\n        };\n        processedContracts.push(processed);\n        continue;\n      }\n\n      // Transform through each plugin\n      for (const plugin of this.plugins) {\n        if (plugin.transformContract) {\n          this.executionContext.currentPlugin = plugin;\n          try {\n            contract = await plugin.transformContract(contract);\n            this.recordHookResult(plugin.name, \"transformContract\", {\n              success: true,\n            });\n          } catch (error) {\n            const err = error as Error;\n            this.recordHookResult(plugin.name, \"transformContract\", {\n              success: false,\n              error: err,\n            });\n            this.logger.warn(\n              `Plugin \"${plugin.name}\" failed to transform contract: ${err.message}`\n            );\n          }\n        }\n      }\n\n      // Convert to ProcessedContract\n      if (contract.abi) {\n        const addressStr = typeof contract.address === \"string\" ? contract.address : \"\";\n        const [contractAddress, originalContractName] = addressStr.split(\".\");\n        const processed: ProcessedContract = {\n          name: contract.name || originalContractName || \"unknown\",\n          address: contractAddress || \"unknown\",\n          contractName: originalContractName || contract.name || \"unknown\",\n          abi: contract.abi,\n          source: \"api\" as const, // Use \"api\" as default for plugin-processed contracts\n          metadata: contract.metadata,\n        };\n        processedContracts.push(processed);\n      }\n    }\n\n    return processedContracts;\n  }\n\n  /**\n   * Execute lifecycle hooks\n   */\n  async executeHook(\n    hookName: keyof SecondLayerPlugin,\n    context: any\n  ): Promise<void> {\n    for (const plugin of this.plugins) {\n      const hook = plugin[hookName];\n      if (typeof hook === \"function\") {\n        this.executionContext.currentPlugin = plugin;\n        try {\n          await (hook as any).call(plugin, context);\n          this.recordHookResult(plugin.name, hookName as string, {\n            success: true,\n          });\n        } catch (error) {\n          const err = error as Error;\n          this.recordHookResult(plugin.name, hookName as string, {\n            success: false,\n            error: err,\n          });\n          this.logger.error(\n            `Plugin \"${plugin.name}\" failed during ${hookName as string}: ${err.message}`\n          );\n          // Don't throw - allow other plugins to continue\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute generation phase with full context\n   */\n  async executeGeneration(\n    contracts: ProcessedContract[],\n    config: ResolvedConfig\n  ): Promise<Map<string, GeneratedOutput>> {\n    this.executionContext.phase = \"generate\";\n    const outputs = new Map<string, GeneratedOutput>();\n\n    // Create generation context\n    const context: GenerateContext = {\n      config,\n      logger: this.logger,\n      utils: this.utils,\n      contracts,\n      outputs,\n      augment: (outputKey: string, contractName: string, content: any) => {\n        this.augmentOutput(outputs, outputKey, contractName, content);\n      },\n      addOutput: (key: string, output: GeneratedOutput) => {\n        outputs.set(key, output);\n      },\n    };\n\n    // Execute beforeGenerate hooks\n    await this.executeHook(\"beforeGenerate\", context);\n\n    // Execute generate hooks\n    await this.executeHook(\"generate\", context);\n\n    // Execute afterGenerate hooks\n    await this.executeHook(\"afterGenerate\", context);\n\n    return outputs;\n  }\n\n  /**\n   * Transform outputs through plugins\n   */\n  async transformOutputs(\n    outputs: Map<string, GeneratedOutput>\n  ): Promise<Map<string, GeneratedOutput>> {\n    this.executionContext.phase = \"output\";\n    const transformedOutputs = new Map<string, GeneratedOutput>();\n\n    for (const [key, output] of outputs) {\n      let transformedContent = output.content;\n\n      for (const plugin of this.plugins) {\n        if (plugin.transformOutput) {\n          this.executionContext.currentPlugin = plugin;\n          try {\n            transformedContent = await plugin.transformOutput(\n              transformedContent,\n              output.type || \"other\"\n            );\n            this.recordHookResult(plugin.name, \"transformOutput\", {\n              success: true,\n            });\n          } catch (error) {\n            const err = error as Error;\n            this.recordHookResult(plugin.name, \"transformOutput\", {\n              success: false,\n              error: err,\n            });\n            this.logger.warn(\n              `Plugin \"${plugin.name}\" failed to transform output: ${err.message}`\n            );\n          }\n        }\n      }\n\n      transformedOutputs.set(key, {\n        ...output,\n        content: transformedContent,\n      });\n    }\n\n    return transformedOutputs;\n  }\n\n  /**\n   * Write outputs to disk\n   */\n  async writeOutputs(outputs: Map<string, GeneratedOutput>): Promise<void> {\n    for (const [, output] of outputs) {\n      try {\n        const resolvedPath = path.resolve(process.cwd(), output.path);\n        await this.utils.ensureDir(path.dirname(resolvedPath));\n        await this.utils.writeFile(resolvedPath, output.content);\n        // Don't log here - let the main command handle success messaging\n      } catch (error) {\n        const err = error as Error;\n        this.logger.error(`Failed to write ${output.path}: ${err.message}`);\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Get execution results for debugging\n   */\n  getExecutionResults(): Map<string, HookResult[]> {\n    return new Map(this.executionContext.results);\n  }\n\n  /**\n   * Augment existing output with additional content\n   */\n  private augmentOutput(\n    outputs: Map<string, GeneratedOutput>,\n    outputKey: string,\n    contractName: string,\n    content: any\n  ): void {\n    const existing = outputs.get(outputKey);\n    if (!existing) {\n      this.logger.warn(`Cannot augment non-existent output: ${outputKey}`);\n      return;\n    }\n\n    // Simple augmentation - append content\n    // In a real implementation, this would be more sophisticated\n    const augmentedContent = `${existing.content}\\n\\n// Augmented by plugin for ${contractName}\\n${JSON.stringify(content, null, 2)}`;\n\n    outputs.set(outputKey, {\n      ...existing,\n      content: augmentedContent,\n    });\n  }\n\n  /**\n   * Record hook execution result\n   */\n  private recordHookResult(\n    pluginName: string,\n    hookName: string,\n    result: Omit<HookResult, \"plugin\">\n  ): void {\n    const key = `${pluginName}:${hookName}`;\n    const existing = this.executionContext.results.get(key) || [];\n    existing.push({ ...result, plugin: pluginName });\n    this.executionContext.results.set(key, existing);\n  }\n\n  /**\n   * Create logger instance\n   */\n  private createLogger(): Logger {\n    return {\n      info: (message: string) => console.log(`â„¹ï¸  ${message}`),\n      warn: (message: string) => console.warn(`âš ï¸  ${message}`),\n      error: (message: string) => console.error(`âŒ ${message}`),\n      debug: (message: string) => {\n        if (process.env.DEBUG) {\n          console.log(`ðŸ› ${message}`);\n        }\n      },\n      success: (message: string) => console.log(`âœ… ${message}`),\n    };\n  }\n\n  /**\n   * Create utils instance\n   */\n  private createUtils(): PluginUtils {\n    return {\n      toCamelCase: (str: string) => {\n        return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n      },\n\n      toKebabCase: (str: string) => {\n        return str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);\n      },\n\n      validateAddress: (address: string) => {\n        return validateStacksAddress(address.split(\".\")[0]);\n      },\n\n      parseContractId: (contractId: string) => {\n        const [address, contractName] = contractId.split(\".\");\n        return { address, contractName };\n      },\n\n      formatCode: async (code: string) => {\n        const { formatCode } = await import(\"../utils/format\");\n        return formatCode(code);\n      },\n\n      resolvePath: (relativePath: string) => {\n        return path.resolve(process.cwd(), relativePath);\n      },\n\n      fileExists: async (filePath: string) => {\n        try {\n          await fs.access(filePath);\n          return true;\n        } catch {\n          return false;\n        }\n      },\n\n      readFile: async (filePath: string) => {\n        return fs.readFile(filePath, \"utf-8\");\n      },\n\n      writeFile: async (filePath: string, content: string) => {\n        await fs.writeFile(filePath, content, \"utf-8\");\n      },\n\n      ensureDir: async (dirPath: string) => {\n        await fs.mkdir(dirPath, { recursive: true });\n      },\n    };\n  }\n}",
    "packages/cli/src/generators/hooks.ts": "import type { ResolvedContract } from \"../types/config\";\nimport { toCamelCase, type ClarityFunction } from \"@secondlayer/clarity-types\";\nimport { clarityTypeToTS } from \"../utils/type-mapping\";\nimport { formatCode } from \"../utils/format\";\n\n/**\n * React hooks generator for contract interfaces and generic Stacks functionality\n */\n\nconst GENERIC_HOOKS = [\n  \"useAccount\",\n  \"useConnect\",\n  \"useDisconnect\",\n  \"useNetwork\",\n  \"useContract\",\n  \"useOpenSTXTransfer\",\n  \"useSignMessage\",\n  \"useDeployContract\",\n  \"useReadContract\",\n  \"useTransaction\",\n  \"useBlock\",\n  \"useAccountTransactions\",\n  \"useWaitForTransaction\",\n] as const;\n\nexport async function generateContractHooks(\n  contracts: ResolvedContract[]\n): Promise<string> {\n  const imports = `import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { useCallback } from 'react'\nimport { useSecondLayerConfig } from './provider'\nimport { request, openContractCall as stacksOpenContractCall } from '@stacks/connect'\nimport type { PostCondition } from '@stacks/transactions'\nimport { ${contracts.map((c) => c.name).join(\", \")} } from './contracts'`;\n\n  const header = `/**\n * Generated contract-specific React hooks\n * DO NOT EDIT MANUALLY\n */`;\n\n  const hooksCode = contracts\n    .map((contract) => generateContractHookMethods(contract))\n    .join(\"\\n\\n\");\n\n  const code = `${imports}\\n\\n${header}\\n\\n${hooksCode}`;\n\n  return formatCode(code);\n}\n\nexport async function generateGenericHooks(\n  includeHooks?: string[]\n): Promise<string> {\n  const hooksToGenerate = includeHooks || [...GENERIC_HOOKS];\n\n  const imports = `import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { useState, useCallback } from 'react'\nimport { useSecondLayerConfig } from './provider'\nimport { connect, disconnect, isConnected, request, openContractCall as stacksOpenContractCall } from '@stacks/connect'\nimport { Cl, validateStacksAddress } from '@stacks/transactions'\nimport type { ExtractFunctionArgs, ExtractFunctionNames, ClarityContract } from '@secondlayer/clarity-types'`;\n\n  const header = `/**\n * Generated generic Stacks React hooks\n * DO NOT EDIT MANUALLY\n */`;\n\n  const hooksCode = hooksToGenerate\n    .map((hookName) => generateGenericHook(hookName))\n    .filter(Boolean)\n    .join(\"\\n\\n\");\n\n  const code = `${imports}\\n\\n${header}\\n\\n${hooksCode}`;\n\n  return formatCode(code);\n}\n\nfunction generateContractHookMethods(contract: ResolvedContract): string {\n  const { abi, name } = contract;\n  const functions = abi.functions || [];\n\n  const readOnlyFunctions = functions.filter(\n    (f: ClarityFunction) => f.access === \"read-only\"\n  );\n  const publicFunctions = functions.filter(\n    (f: ClarityFunction) => f.access === \"public\"\n  );\n\n  const readHooks = readOnlyFunctions.map((func: ClarityFunction) =>\n    generateReadHook(func, name)\n  );\n\n  const writeHooks = publicFunctions.map((func: ClarityFunction) =>\n    generateWriteHook(func, name)\n  );\n\n  return [...readHooks, ...writeHooks].join(\"\\n\\n\");\n}\n\nfunction generateReadHook(func: ClarityFunction, contractName: string): string {\n  const hookName = `use${capitalize(contractName)}${capitalize(toCamelCase(func.name))}`;\n  const argsSignature = generateHookArgsSignature(func.args);\n  const enabledParam =\n    func.args.length > 0\n      ? \", options?: { enabled?: boolean }\"\n      : \"options?: { enabled?: boolean }\";\n\n  return `export function ${hookName}(${argsSignature}${enabledParam}) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['${func.name}', ${contractName}.address, ${generateQueryKeyArgs(func.args)}],\n    queryFn: () => ${contractName}.read.${toCamelCase(func.name)}(${generateFunctionCallArgs(func.args) ? `{ ${generateObjectArgs(func.args)} }, ` : \"\"}{ \n      network: config.network,\n      senderAddress: config.senderAddress || 'SP000000000000000000002Q6VF78'\n    }),\n    ${func.args.length > 0 ? `enabled: ${generateEnabledCondition(func.args)} && (options?.enabled ?? true),` : \"\"}\n    ...options\n  })\n}`;\n}\n\nfunction generateWriteHook(\n  func: ClarityFunction,\n  contractName: string\n): string {\n  const hookName = `use${capitalize(contractName)}${capitalize(toCamelCase(func.name))}`;\n  const argsType = generateArgsType(func.args);\n\n  return `export function ${hookName}() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      args: ${argsType};\n      options?: {\n        postConditions?: PostCondition[];\n        attachment?: string;\n        onFinish?: (data: any) => void;\n        onCancel?: () => void;\n      };\n    }) => {\n      const { args, options = {} } = params\n      const contractCallData = ${contractName}.${toCamelCase(func.name)}(args)\n      const { contractAddress, contractName: name, functionName, functionArgs } = contractCallData\n      const network = config.network || 'mainnet'\n      const contract = \\`\\${contractAddress}.\\${name}\\`\n      \n      // Try @stacks/connect v8 stx_callContract first (SIP-030)\n      try {\n        const result = await request('stx_callContract', {\n          contract,\n          functionName,\n          functionArgs,\n          network,\n          ...options\n        })\n        \n        options.onFinish?.(result)\n        return result\n      } catch (connectError) {\n        // Fallback to openContractCall for broader wallet compatibility\n        console.warn('stx_callContract not supported, falling back to openContractCall:', connectError)\n        \n        return new Promise((resolve, reject) => {\n          stacksOpenContractCall({\n            contractAddress,\n            contractName: name,\n            functionName,\n            functionArgs,\n            network,\n            ...options,\n            onFinish: (data: any) => {\n              options.onFinish?.(data)\n              resolve(data)\n            },\n            onCancel: () => {\n              options.onCancel?.()\n              reject(new Error('User cancelled transaction'))\n            }\n          })\n        })\n      }\n    },\n    onSuccess: () => {\n      // Invalidate relevant queries on success\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('Contract call failed:', error)\n    }\n  })\n\n  const ${toCamelCase(func.name)} = useCallback(async (\n    args: ${argsType}, \n    options?: {\n      postConditions?: PostCondition[];\n      attachment?: string;\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }\n  ) => {\n    return mutation.mutateAsync({ args, options })\n  }, [mutation])\n\n  return {\n    ${toCamelCase(func.name)},\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n}\n\nfunction generateGenericHook(hookName: string): string {\n  switch (hookName) {\n    case \"useAccount\":\n      return `export function useAccount() {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['stacks-account', config.network],\n    queryFn: async () => {\n      try {\n        // Check if already connected using @stacks/connect v8\n        const connected = isConnected()\n        \n        if (!connected) {\n          return {\n            address: undefined,\n            addresses: undefined,\n            isConnected: false,\n            isConnecting: false,\n            isDisconnected: true,\n            status: 'disconnected' as const\n          }\n        }\n\n        // Get addresses using @stacks/connect v8 request method (SIP-030)\n        const result = await request('stx_getAddresses')\n        \n        if (!result || !result.addresses || result.addresses.length === 0) {\n          return {\n            address: undefined,\n            addresses: undefined,\n            isConnected: false,\n            isConnecting: false,\n            isDisconnected: true,\n            status: 'disconnected' as const\n          }\n        }\n\n        // Extract STX addresses from the response\n        const stxAddresses = result.addresses\n          .filter((addr: any) => addr.address.startsWith('SP') || addr.address.startsWith('ST'))\n          .map((addr: any) => addr.address)\n\n        return {\n          address: stxAddresses[0] || undefined,\n          addresses: stxAddresses,\n          isConnected: true,\n          isConnecting: false,\n          isDisconnected: false,\n          status: 'connected' as const\n        }\n      } catch (error) {\n        // Handle case where wallet is not available or user rejected\n        return {\n          address: undefined,\n          addresses: undefined,\n          isConnected: false,\n          isConnecting: false,\n          isDisconnected: true,\n          status: 'disconnected' as const\n        }\n      }\n    },\n    refetchOnWindowFocus: false,\n    retry: false,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchInterval: 1000 * 30, // Refetch every 30 seconds to detect wallet changes\n  })\n}`;\n\n    case \"useConnect\":\n      return `export function useConnect() {\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (options: { forceWalletSelect?: boolean } = {}) => {\n      // Use @stacks/connect v8 connect method\n      return await connect(options)\n    },\n    onSuccess: () => {\n      // Invalidate account queries to refetch connection state\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('Connection failed:', error)\n    }\n  })\n\n  return {\n    // Custom connect function that works without arguments\n    connect: (options?: { forceWalletSelect?: boolean }) => {\n      return mutation.mutate(options || {})\n    },\n    connectAsync: async (options?: { forceWalletSelect?: boolean }) => {\n      return mutation.mutateAsync(options || {})\n    },\n    // Expose all the mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset,\n    // Keep the original mutate/mutateAsync for advanced users\n    mutate: mutation.mutate,\n    mutateAsync: mutation.mutateAsync\n  }\n}`;\n\n    case \"useDisconnect\":\n      return `export function useDisconnect() {\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async () => {\n      // Use @stacks/connect v8 disconnect method\n      return await disconnect()\n    },\n    onSuccess: () => {\n      // Clear all cached data on disconnect\n      queryClient.clear()\n    },\n    onError: (error) => {\n      console.error('Disconnect failed:', error)\n    }\n  })\n\n  return {\n    // Custom disconnect function\n    disconnect: () => {\n      return mutation.mutate()\n    },\n    disconnectAsync: async () => {\n      return mutation.mutateAsync()\n    },\n    // Expose all the mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset,\n    // Keep the original mutate/mutateAsync for advanced users\n    mutate: mutation.mutate,\n    mutateAsync: mutation.mutateAsync\n  }\n}`;\n\n    case \"useNetwork\":\n      return `export function useNetwork() {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['stacks-network', config.network],\n    queryFn: async () => {\n      // Currently read-only from config\n      // Future: Use request('stx_getNetworks') when wallet support improves\n      const network = config.network\n      \n      return {\n        network,\n        isMainnet: network === 'mainnet',\n        isTestnet: network === 'testnet', \n        isDevnet: network === 'devnet',\n        // Future: Add switchNetwork when wallets support stx_networkChange\n        // switchNetwork: async (newNetwork: string) => {\n        //   return await request('wallet_changeNetwork', { network: newNetwork })\n        // }\n      }\n    },\n    staleTime: Infinity, // Network config rarely changes\n    refetchOnWindowFocus: false,\n    retry: false\n  })\n}`;\n\n    case \"useContract\":\n      return `export function useContract() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  const [isRequestPending, setIsRequestPending] = useState(false)\n  \n  // Helper function to convert JS values to Clarity values based on ABI\n  const convertArgsWithAbi = (args: any, abiArgs: any[]): any[] => {\n    if (!abiArgs || abiArgs.length === 0) return []\n    \n    return abiArgs.map((abiArg, index) => {\n      const argValue = Array.isArray(args) \n        ? args[index] \n        : args[abiArg.name] || args[abiArg.name.replace(/-/g, '').replace(/_/g, '')]\n      return convertJSValueToClarityValue(argValue, abiArg.type)\n    })\n  }\n\n  // Helper function to convert buffer values with auto-detection\n  const convertBufferValue = (value: any): any => {\n    // Direct Uint8Array\n    if (value instanceof Uint8Array) {\n      return Cl.buffer(value)\n    }\n    \n    // Object notation with explicit type\n    if (typeof value === 'object' && value !== null && value.type && value.value) {\n      switch (value.type) {\n        case 'ascii':\n          return Cl.bufferFromAscii(value.value)\n        case 'utf8':\n          return Cl.bufferFromUtf8(value.value)\n        case 'hex':\n          return Cl.bufferFromHex(value.value)\n        default:\n          throw new Error(\\`Unsupported buffer type: \\${value.type}\\`)\n      }\n    }\n    \n    // Auto-detect string type\n    if (typeof value === 'string') {\n      // 1. Check for hex (0x prefix or pure hex pattern)\n      if (value.startsWith('0x') || /^[0-9a-fA-F]+$/.test(value)) {\n        return Cl.bufferFromHex(value)\n      }\n      \n      // 2. Check for non-ASCII characters (UTF-8)\n      if (!/^[\\\\x00-\\\\x7F]*$/.test(value)) {\n        return Cl.bufferFromUtf8(value)\n      }\n      \n      // 3. Default to ASCII for simple ASCII strings\n      return Cl.bufferFromAscii(value)\n    }\n    \n    throw new Error(\\`Invalid buffer value: \\${value}\\`)\n  }\n\n  // Helper function to convert a single JS value to ClarityValue\n  const convertJSValueToClarityValue = (value: any, type: any): any => {\n    if (typeof type === 'string') {\n      switch (type) {\n        case 'uint128':\n          return Cl.uint(value)\n        case 'int128':\n          return Cl.int(value)\n        case 'bool':\n          return Cl.bool(value)\n        case 'principal':\n          if (!validateStacksAddress(value.split('.')[0])) {\n            throw new Error('Invalid Stacks address format')\n          }\n          if (value.includes('.')) {\n            const [address, contractName] = value.split('.')\n            return Cl.contractPrincipal(address, contractName)\n          } else {\n            return Cl.standardPrincipal(value)\n          }\n        default:\n          return value\n      }\n    }\n\n    if (type['string-ascii']) {\n      return Cl.stringAscii(value)\n    }\n\n    if (type['string-utf8']) {\n      return Cl.stringUtf8(value)\n    }\n\n    if (type.buff) {\n      return convertBufferValue(value)\n    }\n\n    if (type.optional) {\n      return value !== null ? Cl.some(convertJSValueToClarityValue(value, type.optional)) : Cl.none()\n    }\n\n    if (type.list) {\n      return Cl.list(value.map((item: any) => convertJSValueToClarityValue(item, type.list.type)))\n    }\n\n    if (type.tuple) {\n      const tupleData = type.tuple.reduce((acc: any, field: any) => {\n        acc[field.name] = convertJSValueToClarityValue(value[field.name], field.type)\n        return acc\n      }, {})\n      return Cl.tuple(tupleData)\n    }\n\n    if (type.response) {\n      return 'ok' in value \n        ? Cl.ok(convertJSValueToClarityValue(value.ok, type.response.ok))\n        : Cl.error(convertJSValueToClarityValue(value.err, type.response.error))\n    }\n\n    return value\n  }\n\n  // Helper function to find a function in an ABI by name\n  const findFunctionInAbi = (abi: any, functionName: string): any => {\n    if (!abi || !abi.functions) return null\n    return abi.functions.find((func: any) => func.name === functionName)\n  }\n  \n  // Legacy function - unchanged, backward compatible\n  const legacyOpenContractCall = useCallback(async (params: {\n    contractAddress: string;\n    contractName: string;\n    functionName: string;\n    functionArgs: any[]; // Pre-converted Clarity values\n    network?: string;\n    postConditions?: PostCondition[];\n    attachment?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    setIsRequestPending(true)\n    \n    try {\n      const { contractAddress, contractName, functionName, functionArgs, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      const contract = \\`\\${contractAddress}.\\${contractName}\\`\n      \n      // Try @stacks/connect v8 stx_callContract first (SIP-030)\n      try {\n        const result = await request('stx_callContract', {\n          contract,\n          functionName,\n          functionArgs,\n          network,\n          ...options\n        })\n        \n        // Invalidate relevant queries on success\n        queryClient.invalidateQueries({ \n          queryKey: ['stacks-account'] \n        })\n        \n        onFinish?.(result)\n        return result\n      } catch (connectError) {\n        // Fallback to openContractCall for broader wallet compatibility\n        console.warn('stx_callContract not supported, falling back to openContractCall:', connectError)\n        \n        return new Promise((resolve, reject) => {\n          stacksOpenContractCall({\n            contractAddress,\n            contractName,\n            functionName,\n            functionArgs,\n            network,\n            ...options,\n            onFinish: (data: any) => {\n              // Invalidate relevant queries on success\n              queryClient.invalidateQueries({ \n                queryKey: ['stacks-account'] \n              })\n              \n              onFinish?.(data)\n              resolve(data)\n            },\n            onCancel: () => {\n              onCancel?.()\n              reject(new Error('User cancelled transaction'))\n            }\n          })\n        })\n      }\n    } catch (error) {\n      console.error('Contract call failed:', error)\n      throw error instanceof Error ? error : new Error('Contract call failed')\n    } finally {\n      setIsRequestPending(false)\n    }\n  }, [config.network, queryClient])\n\n  // Enhanced function - requires ABI, auto-converts JS values\n  const openContractCall = useCallback(async <\n    T extends ClarityContract,\n    FN extends ExtractFunctionNames<T>\n  >(params: {\n    contractAddress: string;\n    contractName: string;\n    functionName: FN;\n    abi: T;\n    functionArgs: ExtractFunctionArgs<T, FN>;\n    network?: string;\n    postConditions?: PostCondition[];\n    attachment?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    setIsRequestPending(true)\n    \n    try {\n      const { contractAddress, contractName, functionName, functionArgs, abi, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      const contract = \\`\\${contractAddress}.\\${contractName}\\`\n      \n      // Find the function in the ABI and convert args\n      const abiFunction = findFunctionInAbi(abi, functionName)\n      if (!abiFunction) {\n        throw new Error(\\`Function '\\${functionName}' not found in ABI\\`)\n      }\n      \n      const processedArgs = convertArgsWithAbi(functionArgs, abiFunction.args || [])\n      \n      // Try @stacks/connect v8 stx_callContract first (SIP-030)\n      try {\n        const result = await request('stx_callContract', {\n          contract,\n          functionName,\n          functionArgs: processedArgs,\n          network,\n          ...options\n        })\n        \n        // Invalidate relevant queries on success\n        queryClient.invalidateQueries({ \n          queryKey: ['stacks-account'] \n        })\n        \n        onFinish?.(result)\n        return result\n      } catch (connectError) {\n        // Fallback to openContractCall for broader wallet compatibility\n        console.warn('stx_callContract not supported, falling back to openContractCall:', connectError)\n        \n        return new Promise((resolve, reject) => {\n          stacksOpenContractCall({\n            contractAddress,\n            contractName,\n            functionName,\n            functionArgs: processedArgs,\n            network,\n            ...options,\n            onFinish: (data: any) => {\n              // Invalidate relevant queries on success\n              queryClient.invalidateQueries({ \n                queryKey: ['stacks-account'] \n              })\n              \n              onFinish?.(data)\n              resolve(data)\n            },\n            onCancel: () => {\n              onCancel?.()\n              reject(new Error('User cancelled transaction'))\n            }\n          })\n        })\n      }\n    } catch (error) {\n      console.error('Contract call failed:', error)\n      throw error instanceof Error ? error : new Error('Contract call failed')\n    } finally {\n      setIsRequestPending(false)\n    }\n  }, [config.network, queryClient])\n\n  return {\n    legacyOpenContractCall,\n    openContractCall,\n    isRequestPending\n  }\n}`;\n\n    case \"useReadContract\":\n      return `export function useReadContract<TArgs = any, TResult = any>(params: {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  args?: TArgs;\n  network?: 'mainnet' | 'testnet' | 'devnet';\n  enabled?: boolean;\n}) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery<TResult>({\n    queryKey: ['read-contract', params.contractAddress, params.contractName, params.functionName, params.args, params.network || config.network],\n    queryFn: async () => {\n      const { fetchCallReadOnlyFunction } = await import('@stacks/transactions')\n      \n      // For now, we'll need to handle the args conversion here\n      // In the future, we could integrate with the contract interface for automatic conversion\n      let functionArgs: any[] = []\n      \n      if (params.args) {\n        // This is a simplified conversion - in practice, we'd need the ABI to do proper conversion\n        // For now, we'll assume the args are already in the correct format or simple types\n        if (Array.isArray(params.args)) {\n          functionArgs = params.args\n        } else if (typeof params.args === 'object') {\n          // Convert object args to array (this is a basic implementation)\n          functionArgs = Object.values(params.args)\n        } else {\n          functionArgs = [params.args]\n        }\n      }\n      \n      return await fetchCallReadOnlyFunction({\n        contractAddress: params.contractAddress,\n        contractName: params.contractName,\n        functionName: params.functionName,\n        functionArgs,\n        network: params.network || config.network || 'mainnet',\n        senderAddress: config.senderAddress || 'SP000000000000000000002Q6VF78'\n      }) as TResult\n    },\n    enabled: params.enabled ?? true\n  })\n}`;\n\n    case \"useTransaction\":\n      return `export function useTransaction(txId?: string) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['transaction', txId, config.network],\n    queryFn: () => fetchTransaction({\n      txId: txId!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: !!txId\n  })\n}`;\n\n    case \"useBlock\":\n      return `export function useBlock(height?: number) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['block', height, config.network],\n    queryFn: () => fetchBlock({\n      height: height!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: typeof height === 'number'\n  })\n}`;\n\n    case \"useAccountTransactions\":\n      return `export function useAccountTransactions(address?: string) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['account-transactions', address, config.network],\n    queryFn: () => fetchAccountTransactions({\n      address: address!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: !!address\n  })\n}`;\n\n    case \"useWaitForTransaction\":\n      return `export function useWaitForTransaction(txId?: string) {\n  const config = useSecondLayerConfig()\n  \n  return useQuery({\n    queryKey: ['wait-for-transaction', txId, config.network],\n    queryFn: () => fetchTransaction({\n      txId: txId!,\n      network: config.network,\n      apiUrl: config.apiUrl\n    }),\n    enabled: !!txId,\n    refetchInterval: (data) => {\n      // Stop polling when transaction is complete\n      if (data?.tx_status === 'success' || \n          data?.tx_status === 'abort_by_response' || \n          data?.tx_status === 'abort_by_post_condition') {\n        return false\n      }\n      return 2000 // Poll every 2 seconds\n    },\n    staleTime: 0 // Always refetch\n  })\n}`;\n\n    case \"useOpenSTXTransfer\":\n      return `export function useOpenSTXTransfer() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      recipient: string;\n      amount: string | number;\n      memo?: string;\n      network?: string;\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }) => {\n      const { recipient, amount, memo, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      \n      return new Promise((resolve, reject) => {\n        openSTXTransfer({\n          recipient,\n          amount: amount.toString(),\n          memo,\n          network,\n          ...options,\n          onFinish: (data: any) => {\n            onFinish?.(data)\n            resolve(data)\n          },\n          onCancel: () => {\n            onCancel?.()\n            reject(new Error('User cancelled transaction'))\n          }\n        })\n      })\n    },\n    onSuccess: () => {\n      // Invalidate relevant queries on success\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('STX transfer failed:', error)\n    }\n  })\n\n  const openSTXTransfer = useCallback(async (params: {\n    recipient: string;\n    amount: string | number;\n    memo?: string;\n    network?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    return mutation.mutateAsync(params)\n  }, [mutation])\n\n  return {\n    openSTXTransfer,\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n\n    case \"useSignMessage\":\n      return `export function useSignMessage() {\n  const config = useSecondLayerConfig()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      message: string;\n      network?: string;\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }) => {\n      const { message, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      \n      return new Promise((resolve, reject) => {\n        openSignatureRequestPopup({\n          message,\n          network,\n          ...options,\n          onFinish: (data: any) => {\n            onFinish?.(data)\n            resolve(data)\n          },\n          onCancel: () => {\n            onCancel?.()\n            reject(new Error('User cancelled message signing'))\n          }\n        })\n      })\n    },\n    onError: (error) => {\n      console.error('Message signing failed:', error)\n    }\n  })\n\n  const signMessage = useCallback(async (params: {\n    message: string;\n    network?: string;\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    return mutation.mutateAsync(params)\n  }, [mutation])\n\n  return {\n    signMessage,\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n\n    case \"useDeployContract\":\n      return `export function useDeployContract() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      contractName: string;\n      codeBody: string;\n      network?: string;\n      postConditions?: PostCondition[];\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }) => {\n      const { contractName, codeBody, onFinish, onCancel, ...options } = params\n      const network = params.network || config.network || 'mainnet'\n      \n      return new Promise((resolve, reject) => {\n        openContractDeploy({\n          contractName,\n          codeBody,\n          network,\n          ...options,\n          onFinish: (data: any) => {\n            onFinish?.(data)\n            resolve(data)\n          },\n          onCancel: () => {\n            onCancel?.()\n            reject(new Error('User cancelled contract deployment'))\n          }\n        })\n      })\n    },\n    onSuccess: () => {\n      // Invalidate relevant queries on success\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('Contract deployment failed:', error)\n    }\n  })\n\n  const deployContract = useCallback(async (params: {\n    contractName: string;\n    codeBody: string;\n    network?: string;\n    postConditions?: PostCondition[];\n    onFinish?: (data: any) => void;\n    onCancel?: () => void;\n  }) => {\n    return mutation.mutateAsync(params)\n  }, [mutation])\n\n  return {\n    deployContract,\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n\n    default:\n      return \"\";\n  }\n}\n\n// Helper functions\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction generateHookArgsSignature(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n\n  const argsList = args\n    .map((arg) => `${toCamelCase(arg.name)}: ${clarityTypeToTS(arg.type)}`)\n    .join(\", \");\n  return `${argsList}`;\n}\n\nfunction generateArgsType(args: readonly any[]): string {\n  if (args.length === 0) return \"void\";\n\n  const argsList = args\n    .map((arg) => `${toCamelCase(arg.name)}: ${clarityTypeToTS(arg.type)}`)\n    .join(\"; \");\n  return `{ ${argsList} }`;\n}\n\nfunction generateQueryKeyArgs(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n  return args.map((arg) => toCamelCase(arg.name)).join(\", \");\n}\n\nfunction generateFunctionCallArgs(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n  return args.map((arg) => toCamelCase(arg.name)).join(\", \");\n}\n\nfunction generateEnabledCondition(args: readonly any[]): string {\n  return args\n    .map((arg) => {\n      const camelName = toCamelCase(arg.name);\n      const type = clarityTypeToTS(arg.type);\n      if (type === \"string\") return `!!${camelName}`;\n      if (type === \"bigint\") return `${camelName} !== undefined`;\n      return `${camelName} !== undefined`;\n    })\n    .join(\" && \");\n}\n\nfunction generateObjectArgs(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n  return args.map((arg) => `${arg.name}: ${toCamelCase(arg.name)}`).join(\", \");\n}",
    "packages/cli/src/plugins/react/generators/contract.ts": "/**\n * Contract-specific hooks generator for React plugin\n */\n\nimport type { ProcessedContract } from \"../../../types/plugin\";\nimport { formatCode } from \"../../../utils/format\";\nimport type { ClarityFunction } from \"@secondlayer/clarity-types\";\nimport {\n  toCamelCase,\n  capitalize,\n  generateHookArgsSignature,\n  generateArgsType,\n  generateQueryKeyArgs,\n  generateFunctionCallArgs,\n  generateEnabledCondition,\n  generateObjectArgs,\n  clarityTypeToTS,\n} from \"./utils\";\nimport type { ClarityMap, ClarityVariable } from \"@secondlayer/clarity-types\";\n\nexport async function generateContractHooks(\n  contracts: ProcessedContract[],\n  excludeList: string[] = []\n): Promise<string> {\n  const imports = `import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { useCallback } from 'react'\nimport { useSecondLayerConfig } from './provider'\nimport { request, openContractCall as stacksOpenContractCall } from '@stacks/connect'\nimport type { PostCondition } from '@stacks/transactions'\nimport { ${contracts.map((c) => c.name).join(\", \")} } from './contracts'`;\n\n  const header = `/**\n * Generated contract-specific React hooks\n * DO NOT EDIT MANUALLY\n */`;\n\n  const hooksCode = contracts\n    .map((contract) => generateContractHookMethods(contract, excludeList))\n    .filter(Boolean)\n    .join(\"\\n\\n\");\n\n  const code = `${imports}\\n\\n${header}\\n\\n${hooksCode}`;\n\n  return formatCode(code);\n}\n\nfunction generateContractHookMethods(\n  contract: ProcessedContract,\n  excludeList: string[]\n): string {\n  const { abi, name, address, contractName } = contract;\n  const functions = abi.functions || [];\n  const maps = (abi.maps || []) as ClarityMap[];\n  const variables = (abi.variables || []) as ClarityVariable[];\n\n  const readOnlyFunctions = functions.filter(\n    (f: ClarityFunction) =>\n      (f.access as any) === \"read_only\" || f.access === \"read-only\"\n  );\n  const publicFunctions = functions.filter(\n    (f: ClarityFunction) => f.access === \"public\"\n  );\n\n  const readHooks = readOnlyFunctions\n    .map((func: ClarityFunction) => {\n      const hookName = `use${capitalize(name)}${capitalize(toCamelCase(func.name))}`;\n      // Check if this specific hook is excluded\n      if (excludeList.includes(hookName)) {\n        return null;\n      }\n      return generateReadHook(func, name);\n    })\n    .filter(Boolean);\n\n  const writeHooks = publicFunctions\n    .map((func: ClarityFunction) => {\n      const hookName = `use${capitalize(name)}${capitalize(toCamelCase(func.name))}`;\n      // Check if this specific hook is excluded\n      if (excludeList.includes(hookName)) {\n        return null;\n      }\n      return generateWriteHook(func, name);\n    })\n    .filter(Boolean);\n\n  // Generate hooks for maps\n  const mapHooks = maps\n    .map((map: ClarityMap) => {\n      const hookName = `use${capitalize(name)}${capitalize(toCamelCase(map.name))}`;\n      if (excludeList.includes(hookName)) {\n        return null;\n      }\n      return generateMapHook(map, name, address, contractName);\n    })\n    .filter(Boolean);\n\n  // Generate hooks for data variables\n  const dataVars = variables.filter((v) => v.access === \"variable\");\n  const varHooks = dataVars\n    .map((variable: ClarityVariable) => {\n      const hookName = `use${capitalize(name)}${capitalize(toCamelCase(variable.name))}`;\n      if (excludeList.includes(hookName)) {\n        return null;\n      }\n      return generateVarHook(variable, name, address, contractName);\n    })\n    .filter(Boolean);\n\n  // Generate hooks for constants\n  const constants = variables.filter((v) => v.access === \"constant\");\n  const constantHooks = constants\n    .map((constant: ClarityVariable) => {\n      const hookName = `use${capitalize(name)}${capitalize(toCamelCase(constant.name))}`;\n      if (excludeList.includes(hookName)) {\n        return null;\n      }\n      return generateConstantHook(constant, name, address, contractName);\n    })\n    .filter(Boolean);\n\n  const allHooks = [...readHooks, ...writeHooks, ...mapHooks, ...varHooks, ...constantHooks];\n\n  // If all hooks for this contract are excluded, return empty string\n  if (allHooks.length === 0) {\n    return \"\";\n  }\n\n  return allHooks.join(\"\\n\\n\");\n}\n\nfunction generateReadHook(func: ClarityFunction, contractName: string): string {\n  const hookName = `use${capitalize(contractName)}${capitalize(toCamelCase(func.name))}`;\n  const argsSignature = generateHookArgsSignature(func.args);\n  const enabledParam =\n    func.args.length > 0\n      ? \", options?: { enabled?: boolean }\"\n      : \"options?: { enabled?: boolean }\";\n\n  // Generate proper return type from function outputs\n  const returnType = clarityTypeToTS(func.outputs);\n\n  return `export function ${hookName}(${argsSignature}${enabledParam}) {\n  const config = useSecondLayerConfig()\n\n  return useQuery<${returnType}>({\n    queryKey: ['${func.name}', ${contractName}.address, ${generateQueryKeyArgs(func.args)}],\n    queryFn: () => ${contractName}.read.${toCamelCase(func.name)}(${generateFunctionCallArgs(func.args) ? `{ ${generateObjectArgs(func.args)} }, ` : \"\"}{\n      network: config.network,\n      senderAddress: config.senderAddress || 'SP000000000000000000002Q6VF78'\n    }),\n    ${func.args.length > 0 ? `enabled: ${generateEnabledCondition(func.args)} && (options?.enabled ?? true),` : \"\"}\n    ...options\n  })\n}`;\n}\n\nfunction generateWriteHook(\n  func: ClarityFunction,\n  contractName: string\n): string {\n  const hookName = `use${capitalize(contractName)}${capitalize(toCamelCase(func.name))}`;\n  const argsType = generateArgsType(func.args);\n\n  return `export function ${hookName}() {\n  const config = useSecondLayerConfig()\n  const queryClient = useQueryClient()\n  \n  const mutation = useMutation({\n    mutationFn: async (params: {\n      args: ${argsType};\n      options?: {\n        postConditions?: PostCondition[];\n        attachment?: string;\n        onFinish?: (data: any) => void;\n        onCancel?: () => void;\n      };\n    }) => {\n      const { args, options = {} } = params\n      const contractCallData = ${contractName}.${toCamelCase(func.name)}(args)\n      const { contractAddress, contractName: name, functionName, functionArgs } = contractCallData\n      const network = config.network || 'mainnet'\n      const contract = \\`\\${contractAddress}.\\${name}\\`\n      \n      // Try @stacks/connect v8 stx_callContract first (SIP-030)\n      try {\n        const result = await request('stx_callContract', {\n          contract,\n          functionName,\n          functionArgs,\n          network,\n          ...options\n        })\n        \n        options.onFinish?.(result)\n        return result\n      } catch (connectError) {\n        // Fallback to openContractCall for broader wallet compatibility\n        console.warn('stx_callContract not supported, falling back to openContractCall:', connectError)\n        \n        return new Promise((resolve, reject) => {\n          stacksOpenContractCall({\n            contractAddress,\n            contractName: name,\n            functionName,\n            functionArgs,\n            network,\n            ...options,\n            onFinish: (data: any) => {\n              options.onFinish?.(data)\n              resolve(data)\n            },\n            onCancel: () => {\n              options.onCancel?.()\n              reject(new Error('User cancelled transaction'))\n            }\n          })\n        })\n      }\n    },\n    onSuccess: () => {\n      // Invalidate relevant queries on success\n      queryClient.invalidateQueries({ queryKey: ['stacks-account'] })\n    },\n    onError: (error) => {\n      console.error('Contract call failed:', error)\n    }\n  })\n\n  const ${toCamelCase(func.name)} = useCallback(async (\n    args: ${argsType},\n    options?: {\n      postConditions?: PostCondition[];\n      attachment?: string;\n      onFinish?: (data: any) => void;\n      onCancel?: () => void;\n    }\n  ) => {\n    return mutation.mutateAsync({ args, options })\n  }, [mutation])\n\n  return {\n    ${toCamelCase(func.name)},\n    // Expose mutation state\n    isPending: mutation.isPending,\n    isError: mutation.isError,\n    isSuccess: mutation.isSuccess,\n    error: mutation.error,\n    data: mutation.data,\n    reset: mutation.reset\n  }\n}`;\n}\n\n/**\n * Generate a hook for reading a map entry\n */\nfunction generateMapHook(\n  map: ClarityMap,\n  contractVarName: string,\n  _address: string,\n  _contractName: string\n): string {\n  const hookName = `use${capitalize(contractVarName)}${capitalize(toCamelCase(map.name))}`;\n  const keyType = clarityTypeToTS(map.key);\n  const valueType = clarityTypeToTS(map.value);\n\n  return `export function ${hookName}(key: ${keyType}, options?: { enabled?: boolean }) {\n  const config = useSecondLayerConfig()\n\n  return useQuery<${valueType} | null>({\n    queryKey: ['${contractVarName}', '${map.name}', 'map', key, config.network],\n    queryFn: async () => {\n      return ${contractVarName}.maps.${toCamelCase(map.name)}.get(key, { network: config.network })\n    },\n    enabled: options?.enabled ?? true\n  })\n}`;\n}\n\n/**\n * Generate a hook for reading a data variable\n */\nfunction generateVarHook(\n  variable: ClarityVariable,\n  contractVarName: string,\n  _address: string,\n  _contractName: string\n): string {\n  const hookName = `use${capitalize(contractVarName)}${capitalize(toCamelCase(variable.name))}`;\n  const valueType = clarityTypeToTS(variable.type);\n\n  return `export function ${hookName}(options?: { enabled?: boolean }) {\n  const config = useSecondLayerConfig()\n\n  return useQuery<${valueType}>({\n    queryKey: ['${contractVarName}', '${variable.name}', 'var', config.network],\n    queryFn: async () => {\n      return ${contractVarName}.vars.${toCamelCase(variable.name)}.get({ network: config.network })\n    },\n    enabled: options?.enabled ?? true\n  })\n}`;\n}\n\n/**\n * Generate a hook for reading a constant\n */\nfunction generateConstantHook(\n  constant: ClarityVariable,\n  contractVarName: string,\n  _address: string,\n  _contractName: string\n): string {\n  const hookName = `use${capitalize(contractVarName)}${capitalize(toCamelCase(constant.name))}`;\n  const valueType = clarityTypeToTS(constant.type);\n\n  return `export function ${hookName}(options?: { enabled?: boolean }) {\n  const config = useSecondLayerConfig()\n\n  return useQuery<${valueType}>({\n    queryKey: ['${contractVarName}', '${constant.name}', 'constant', config.network],\n    queryFn: async () => {\n      return ${contractVarName}.constants.${toCamelCase(constant.name)}.get({ network: config.network })\n    },\n    enabled: options?.enabled ?? true,\n    staleTime: Infinity // Constants never change\n  })\n}`;\n}",
    "packages/cli/src/generators/contract.ts": "import type { ResolvedContract } from \"../types/config\";\nimport { formatCode } from \"../utils/format\";\nimport {\n  toCamelCase,\n  type ClarityFunction,\n  type ClarityMap,\n  type ClarityVariable,\n} from \"@secondlayer/clarity-types\";\nimport { getTypeForArg } from \"../utils/type-mapping\";\n\n/**\n * Code generator for contract interfaces\n */\n\n/**\n * Generate shared network utilities for the generated code\n */\nfunction generateNetworkUtils(): string {\n  return `/**\n * API URLs for different networks\n */\nconst API_URLS: Record<'mainnet' | 'testnet' | 'devnet', string> = {\n  mainnet: 'https://api.hiro.so',\n  testnet: 'https://api.testnet.hiro.so',\n  devnet: 'http://localhost:3999'\n};\n\n/**\n * Infer network from Stacks address prefix\n * SP/SM = mainnet, ST/SN = testnet\n */\nfunction inferNetworkFromAddress(address: string): 'mainnet' | 'testnet' | undefined {\n  if (address.startsWith('SP') || address.startsWith('SM')) return 'mainnet';\n  if (address.startsWith('ST') || address.startsWith('SN')) return 'testnet';\n  return undefined;\n}\n\n/**\n * Get API URL, inferring network from contract address if not specified\n */\nfunction getApiUrl(\n  contractAddress: string,\n  explicitNetwork?: 'mainnet' | 'testnet' | 'devnet'\n): string {\n  const network = explicitNetwork ?? inferNetworkFromAddress(contractAddress) ?? 'mainnet';\n  return API_URLS[network];\n}`;\n}\n\n/**\n * Generate validation utilities that are inlined in generated code\n * This avoids requiring external dependencies beyond @stacks/transactions\n */\nfunction generateValidationUtils(): string {\n  return `/**\n * Contract name validation regex\n * Must start with letter, contain only letters, numbers, and hyphens, max 128 chars\n */\nconst CONTRACT_NAME_REGEX = /^[a-zA-Z][a-zA-Z0-9\\\\-]{0,127}$/;`;\n}\n\nexport async function generateContractInterface(\n  contracts: ResolvedContract[]\n): Promise<string> {\n  const imports = `import { Cl, validateStacksAddress } from '@stacks/transactions'`;\n\n  const header = `/**\n * Generated by @secondlayer/cli\n * DO NOT EDIT MANUALLY\n *\n * @requires @stacks/transactions - Install with: npm install @stacks/transactions\n */`;\n\n  const validationUtils = generateValidationUtils();\n  const networkUtils = generateNetworkUtils();\n\n  const contractsCode = contracts\n    .map((contract) => generateContract(contract))\n    .join(\"\\n\\n\");\n\n  const code = `${imports}\\n\\n${header}\\n\\n${validationUtils}\\n\\n${networkUtils}\\n\\n${contractsCode}`;\n\n  return formatCode(code);\n}\n\nfunction generateContract(contract: ResolvedContract): string {\n  const { name, address, contractName, abi } = contract;\n\n  const abiCode = generateAbiConstant(name, abi);\n\n  const methods = abi.functions\n    .filter((func: ClarityFunction) => func.access !== \"private\")\n    .map((func: ClarityFunction) => generateMethod(func, address, contractName))\n    .join(\",\\n\\n  \");\n\n  // Generate maps object if contract has maps\n  const mapsObject = generateMapsObject(abi.maps || [], address, contractName);\n\n  // Generate vars object if contract has variables (only data vars, not constants)\n  const varsObject = generateVarsObject(abi.variables || [], address, contractName);\n\n  // Generate constants object if contract has constants\n  const constantsObject = generateConstantsObject(abi.variables || [], address, contractName);\n\n  // Combine all members\n  const allMembers = [methods, mapsObject, varsObject, constantsObject].filter(Boolean);\n\n  const contractCode = `export const ${name} = {\n  address: '${address}',\n  contractAddress: '${address}',\n  contractName: '${contractName}',\n\n  ${allMembers.join(\",\\n\\n  \")}\n} as const`;\n\n  return `${abiCode}\\n\\n${contractCode}`;\n}\n\nfunction generateAbiConstant(name: string, abi: any): string {\n  const abiJson = JSON.stringify(abi, null, 2)\n    .replace(/\"([a-zA-Z_$][a-zA-Z0-9_$]*)\":/g, \"$1:\") // Only remove quotes from valid JS identifiers\n    .replace(/\"/g, \"'\"); // Use single quotes\n\n  return `export const ${name}Abi = ${abiJson} as const`;\n}\n\nfunction generateMethod(\n  func: ClarityFunction,\n  address: string,\n  contractName: string\n): string {\n  const methodName = toCamelCase(func.name);\n\n  if (func.args.length === 0) {\n    return `${methodName}() {\n    return {\n      contractAddress: '${address}',\n      contractName: '${contractName}',\n      functionName: '${func.name}',\n      functionArgs: []\n    }\n  }`;\n  }\n\n  if (func.args.length === 1) {\n    const originalArgName = func.args[0].name;\n    const argName = toCamelCase(originalArgName);\n    const argType = getTypeForArg(func.args[0]);\n    const clarityConversion = generateClarityConversion(argName, func.args[0]);\n\n    return `${methodName}(...args: [{ ${argName}: ${argType} }] | [${argType}]) {\n    const ${argName} = args.length === 1 && typeof args[0] === 'object' && args[0] !== null && '${argName}' in args[0]\n      ? args[0].${argName}\n      : args[0] as ${argType}\n    \n    return {\n      contractAddress: '${address}',\n      contractName: '${contractName}',\n      functionName: '${func.name}',\n      functionArgs: [${clarityConversion}]\n    }\n  }`;\n  }\n\n  const argsList = func.args.map((arg) => toCamelCase(arg.name)).join(\", \");\n  const argsTypes = func.args\n    .map((arg) => {\n      const camelName = toCamelCase(arg.name);\n      return `${camelName}: ${getTypeForArg(arg)}`;\n    })\n    .join(\"; \");\n  const argsArray = func.args\n    .map((arg) => {\n      const argName = toCamelCase(arg.name);\n      return generateClarityConversion(argName, arg);\n    })\n    .join(\", \");\n  const objectAccess = func.args\n    .map((arg) => {\n      const camelName = toCamelCase(arg.name);\n      return `args[0].${camelName}`;\n    })\n    .join(\", \");\n  const positionTypes = func.args.map((arg) => getTypeForArg(arg)).join(\", \");\n\n  return `${methodName}(...args: [{ ${argsTypes} }] | [${positionTypes}]) {\n    const [${argsList}] = args.length === 1 && typeof args[0] === 'object' && args[0] !== null\n      ? [${objectAccess}]\n      : args as [${positionTypes}]\n    \n    return {\n      contractAddress: '${address}',\n      contractName: '${contractName}',\n      functionName: '${func.name}',\n      functionArgs: [${argsArray}]\n    }\n  }`;\n}\n\n\n/**\n * Convert TypeScript value to ClarityValue based on the argument type\n */\nfunction generateClarityConversion(argName: string, argType: any): string {\n  const type = argType.type;\n\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"uint128\":\n        return `Cl.uint(${argName})`;\n      case \"int128\":\n        return `Cl.int(${argName})`;\n      case \"bool\":\n        return `Cl.bool(${argName})`;\n      case \"principal\":\n      case \"trait_reference\":\n        return `(() => {\n          const [address, contractName] = ${argName}.split(\".\") as [string, string | undefined];\n          if (!validateStacksAddress(address)) {\n            throw new Error(\"Invalid Stacks address format\");\n          }\n          if (contractName !== undefined) {\n            if (!CONTRACT_NAME_REGEX.test(contractName)) {\n              throw new Error(\"Invalid contract name format: must start with letter and contain only letters, numbers, and hyphens\");\n            }\n            return Cl.contractPrincipal(address, contractName);\n          }\n          return Cl.standardPrincipal(${argName});\n        })()`;\n      default:\n        return `${argName}`; // fallback for unknown types\n    }\n  }\n\n  if (type[\"string-ascii\"]) {\n    return `Cl.stringAscii(${argName})`;\n  }\n\n  if (type[\"string-utf8\"]) {\n    return `Cl.stringUtf8(${argName})`;\n  }\n\n  if (type.buff) {\n    // Generate flexible buffer conversion code that matches the hooks implementation\n    return `(() => {\n      const value = ${argName};\n      // Direct Uint8Array\n      if (value instanceof Uint8Array) {\n        return Cl.buffer(value);\n      }\n      // Object notation with explicit type\n      if (typeof value === 'object' && value !== null && value.type && value.value) {\n        switch (value.type) {\n          case 'ascii':\n            return Cl.bufferFromAscii(value.value);\n          case 'utf8':\n            return Cl.bufferFromUtf8(value.value);\n          case 'hex':\n            return Cl.bufferFromHex(value.value);\n          default:\n            throw new Error(\\`Unsupported buffer type: \\${value.type}\\`);\n        }\n      }\n      // Auto-detect string type\n      if (typeof value === 'string') {\n        // Check for hex (0x prefix or pure hex pattern)\n        if (value.startsWith('0x') || /^[0-9a-fA-F]+$/.test(value)) {\n          return Cl.bufferFromHex(value);\n        }\n        // Check for non-ASCII characters (UTF-8) using char code comparison\n        const hasNonAscii = value.split('').some(char => char.charCodeAt(0) > 127);\n        if (hasNonAscii) {\n          return Cl.bufferFromUtf8(value);\n        }\n        // Default to ASCII for simple ASCII strings\n        return Cl.bufferFromAscii(value);\n      }\n      throw new Error(\\`Invalid buffer value: \\${value}\\`);\n    })()`;\n  }\n\n  if (type.optional) {\n    const innerConversion = generateClarityConversion(argName, {\n      type: type.optional,\n    });\n    return `${argName} !== null ? Cl.some(${innerConversion.replace(argName, `${argName}`)}) : Cl.none()`;\n  }\n\n  if (type.list) {\n    const innerConversion = generateClarityConversion(\"item\", {\n      type: type.list.type,\n    });\n    const maxLength = type.list.length || 100;\n    return `(() => {\n      const listValue = ${argName};\n      if (listValue.length > ${maxLength}) {\n        throw new Error(\\`List length \\${listValue.length} exceeds max ${maxLength}\\`);\n      }\n      return Cl.list(listValue.map(item => ${innerConversion}));\n    })()`;\n  }\n\n  if (type.tuple) {\n    const requiredFields = type.tuple.map((f: any) => f.name);\n    const fieldNames = JSON.stringify(requiredFields);\n    const fields = type.tuple\n      .map((field: any) => {\n        const camelFieldName = toCamelCase(field.name);\n        const fieldConversion = generateClarityConversion(\n          `tupleValue.${camelFieldName}`,\n          { type: field.type }\n        );\n        return `\"${field.name}\": ${fieldConversion}`;\n      })\n      .join(\", \");\n    return `(() => {\n      const tupleValue = ${argName};\n      const requiredFields = ${fieldNames};\n      for (const fieldName of requiredFields) {\n        const camelName = fieldName.replace(/-([a-z])/g, (_: string, l: string) => l.toUpperCase());\n        if (!(fieldName in tupleValue) && !(camelName in tupleValue)) {\n          throw new Error(\\`Missing tuple field: \\${fieldName}\\`);\n        }\n      }\n      return Cl.tuple({ ${fields} });\n    })()`;\n  }\n\n  if (type.response) {\n    // For response types, we expect the user to pass { ok: value } or { err: value }\n    const okConversion = generateClarityConversion(`responseValue.ok`, {\n      type: type.response.ok,\n    });\n    const errConversion = generateClarityConversion(`responseValue.err`, {\n      type: type.response.error,\n    });\n    return `(() => {\n      const responseValue = ${argName};\n      const hasOk = 'ok' in responseValue;\n      const hasErr = 'err' in responseValue;\n      if (hasOk && !hasErr) {\n        return Cl.ok(${okConversion});\n      }\n      if (hasErr && !hasOk) {\n        return Cl.error(${errConversion});\n      }\n      throw new Error(\"Response must have exactly 'ok' or 'err' property\");\n    })()`;\n  }\n\n  // Default fallback\n  return `${argName}`;\n}\n\n/**\n * Generate maps object with type-safe accessors for contract data maps\n */\nfunction generateMapsObject(\n  maps: readonly ClarityMap[],\n  address: string,\n  contractName: string\n): string {\n  if (!maps || maps.length === 0) {\n    return \"\";\n  }\n\n  const mapMethods = maps.map((map) => {\n    const methodName = toCamelCase(map.name);\n    const keyType = getTypeForArg({ type: map.key });\n    const valueType = getTypeForArg({ type: map.value });\n    const keyConversion = generateMapKeyConversion(map.key);\n\n    return `${methodName}: {\n      async get(key: ${keyType}, options?: { network?: 'mainnet' | 'testnet' | 'devnet' }): Promise<${valueType} | null> {\n        try {\n          const { cvToJSON, serializeCV } = await import('@stacks/transactions');\n          const baseUrl = getApiUrl('${address}', options?.network);\n          const mapKey = ${keyConversion};\n          const keyHex = serializeCV(mapKey).toString('hex');\n\n          const response = await fetch(\n            \\`\\${baseUrl}/v2/map_entry/${address}/${contractName}/${map.name}\\`,\n            {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(keyHex)\n            }\n          );\n\n          if (!response.ok) {\n            throw new Error(\\`HTTP \\${response.status}: \\${response.statusText}\\`);\n          }\n\n          const result = await response.json();\n          if (!result.data || result.data === '0x09') {\n            return null; // none value\n          }\n\n          const { deserializeCV } = await import('@stacks/transactions');\n          const cv = deserializeCV(result.data);\n          const parsed = cvToJSON(cv);\n          // Unwrap the (some ...) wrapper\n          return parsed.value?.value ?? parsed.value ?? null;\n        } catch (error) {\n          if (error instanceof Error) {\n            throw new Error(\\`Map access failed for '${map.name}': \\${error.message}\\`);\n          }\n          throw error;\n        }\n      },\n      keyType: ${JSON.stringify(map.key)} as const,\n      valueType: ${JSON.stringify(map.value)} as const\n    }`;\n  });\n\n  return `maps: {\n    ${mapMethods.join(\",\\n\\n    \")}\n  }`;\n}\n\n/**\n * Generate vars object with type-safe accessors for contract data variables\n */\nfunction generateVarsObject(\n  variables: readonly ClarityVariable[],\n  address: string,\n  contractName: string\n): string {\n  if (!variables || variables.length === 0) {\n    return \"\";\n  }\n\n  // Filter to only include mutable data variables (not constants)\n  const dataVars = variables.filter((v) => v.access === \"variable\");\n\n  if (dataVars.length === 0) {\n    return \"\";\n  }\n\n  const varMethods = dataVars.map((variable) => {\n    const methodName = toCamelCase(variable.name);\n    const valueType = getTypeForArg({ type: variable.type });\n\n    return `${methodName}: {\n      async get(options?: { network?: 'mainnet' | 'testnet' | 'devnet' }): Promise<${valueType}> {\n        try {\n          const { cvToJSON, deserializeCV } = await import('@stacks/transactions');\n          const baseUrl = getApiUrl('${address}', options?.network);\n\n          const response = await fetch(\n            \\`\\${baseUrl}/v2/data_var/${address}/${contractName}/${variable.name}?proof=0\\`\n          );\n\n          if (!response.ok) {\n            throw new Error(\\`HTTP \\${response.status}: \\${response.statusText}\\`);\n          }\n\n          const result = await response.json();\n          const cv = deserializeCV(result.data);\n          const parsed = cvToJSON(cv);\n          return parsed.value ?? parsed;\n        } catch (error) {\n          if (error instanceof Error) {\n            throw new Error(\\`Variable access failed for '${variable.name}': \\${error.message}\\`);\n          }\n          throw error;\n        }\n      },\n      type: ${JSON.stringify(variable.type)} as const\n    }`;\n  });\n\n  return `vars: {\n    ${varMethods.join(\",\\n\\n    \")}\n  }`;\n}\n\n/**\n * Generate constants object with type-safe accessors for contract constants\n */\nfunction generateConstantsObject(\n  variables: readonly ClarityVariable[],\n  address: string,\n  contractName: string\n): string {\n  if (!variables || variables.length === 0) {\n    return \"\";\n  }\n\n  // Filter to only include constants\n  const constants = variables.filter((v) => v.access === \"constant\");\n\n  if (constants.length === 0) {\n    return \"\";\n  }\n\n  const constMethods = constants.map((constant) => {\n    const methodName = toCamelCase(constant.name);\n    const valueType = getTypeForArg({ type: constant.type });\n\n    return `${methodName}: {\n      async get(options?: { network?: 'mainnet' | 'testnet' | 'devnet' }): Promise<${valueType}> {\n        try {\n          const { cvToJSON, deserializeCV } = await import('@stacks/transactions');\n          const baseUrl = getApiUrl('${address}', options?.network);\n\n          const response = await fetch(\n            \\`\\${baseUrl}/v2/constant_val/${address}/${contractName}/${constant.name}?proof=0\\`\n          );\n\n          if (!response.ok) {\n            throw new Error(\\`HTTP \\${response.status}: \\${response.statusText}\\`);\n          }\n\n          const result = await response.json();\n          const cv = deserializeCV(result.data);\n          const parsed = cvToJSON(cv);\n          return parsed.value ?? parsed;\n        } catch (error) {\n          if (error instanceof Error) {\n            throw new Error(\\`Constant access failed for '${constant.name}': \\${error.message}\\`);\n          }\n          throw error;\n        }\n      },\n      type: ${JSON.stringify(constant.type)} as const\n    }`;\n  });\n\n  return `constants: {\n    ${constMethods.join(\",\\n\\n    \")}\n  }`;\n}\n\n/**\n * Generate Clarity conversion for map key\n */\nfunction generateMapKeyConversion(keyType: any): string {\n  // Map keys are typically tuples or simple types\n  if (keyType.tuple) {\n    const fields = keyType.tuple\n      .map((field: any) => {\n        const camelFieldName = toCamelCase(field.name);\n        const fieldConversion = generateClarityConversion(\n          `key.${camelFieldName}`,\n          { type: field.type }\n        );\n        return `\"${field.name}\": ${fieldConversion}`;\n      })\n      .join(\", \");\n    return `Cl.tuple({ ${fields} })`;\n  }\n\n  // Single-value keys\n  return generateClarityConversion(\"key\", { type: keyType });\n}",
    "packages/clarity-types/CHANGELOG.md": "# @secondlayer/clarity-types\n\n## 0.5.0\n\n### Minor Changes\n\n- Add complete ABI types: fungible/non-fungible tokens, trait definitions, and extractors for maps, variables, and tokens\n\n## 0.4.2\n\n### Patch Changes\n\n- fix: consolidated audit fixes - config regex, missing imports, type validation, error handling, code deduplication\n\n## 0.4.1\n\n### Patch Changes\n\n- Add composite type validation and consolidate shared utilities\n  - Add validation for lists (max length), tuples (required fields), and responses (ok/err shape)\n  - Add contract name format validation for principals\n  - Create ABI normalization layer for buffer/buff and read_only/read-only compatibility\n  - Consolidate toCamelCase implementations into clarity-types\n  - Consolidate type mapping utilities into shared module\n\n## 0.4.0\n\n### Minor Changes\n\n- Hardened clarity-types package with upstream validation and complete composite type support:\n  - Replace custom principal regex validation with `@stacks/transactions` `validateStacksAddress` for proper checksum validation across all network types (mainnet, testnet, devnet)\n  - Add full recursive validation for composite types (list, tuple, optional, response) in `jsToClarity()`\n  - Add type guards: `isClarityList`, `isClarityTuple`, `isClarityOptional`, `isClarityResponse`, `isClarityBuffer`, `isClarityStringAscii`, `isClarityStringUtf8`\n  - Add shared utilities: `ToCamelCase` type and `toCamelCase` function\n  - Remove stub `createContractInterface` function (actual implementations generated by CLI)\n\n## 0.3.0\n\n### Minor Changes\n\n- Add support for contract state (maps, variables, and constants)\n  - Generate typed `maps` object with `get()` methods for reading map entries via Hiro API\n  - Generate typed `vars` object with `get()` methods for reading data variables\n  - Generate typed `constants` object with `get()` methods for reading contract constants\n  - Add React hooks for maps (`useContractMapName`), variables (`useContractVarName`), and constants (`useContractConstantName`)\n  - Constants hooks use `staleTime: Infinity` since values never change\n  - Parse maps and variables from Hiro API contract interface responses\n\n## 0.2.2\n\n### Patch Changes\n\n- Fix issue with CommonJS bundling\n\n## 0.2.1\n\n### Patch Changes\n\n- Clean up eager imports and heavy deps\n\n## 0.2.0\n\n### Minor Changes\n\n- Initial monorepo release. The CLI now includes a new testing plugin for Clarinet SDK integration, and type inference is powered by the new @secondlayer/clarity-types package with runtime validation guards and value converters.",
    "packages/cli/src/plugins/actions/generators.ts": "/**\n * Action generators for read and write helper functions\n */\n\nimport type { ProcessedContract } from \"../../types/plugin\";\nimport { toCamelCase, type ClarityFunction } from \"@secondlayer/clarity-types\";\nimport type { ActionsPluginOptions } from \"./index\";\nimport { getTypeForArg } from \"../../utils/type-mapping\";\n\n/**\n * Generate arguments signature for helper functions\n */\nfunction generateArgsSignature(args: readonly any[]): string {\n  if (args.length === 0) return \"\";\n\n  const argsTypes = args\n    .map((arg) => {\n      const camelName = toCamelCase(arg.name);\n      return `${camelName}: ${getTypeForArg(arg)}`;\n    })\n    .join(\"; \");\n\n  return `args: { ${argsTypes} }, `;\n}\n\n/**\n * Generate Clarity arguments for function calls\n */\nfunction generateClarityArgs(\n  args: readonly any[],\n  _contractName: string\n): string {\n  if (args.length === 0) return \"\";\n\n  return args\n    .map((arg) => {\n      const argName = `args.${toCamelCase(arg.name)}`;\n      return generateClarityConversion(argName, arg);\n    })\n    .join(\", \");\n}\n\n/**\n * Convert TypeScript value to ClarityValue based on the argument type (from old generator)\n */\nfunction generateClarityConversion(argName: string, argType: any): string {\n  const type = argType.type;\n\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"uint128\":\n        return `Cl.uint(${argName})`;\n      case \"int128\":\n        return `Cl.int(${argName})`;\n      case \"bool\":\n        return `Cl.bool(${argName})`;\n      case \"principal\":\n      case \"trait_reference\":\n        return `(() => {\n          const [address, contractName] = ${argName}.split(\".\") as [string, string | undefined];\n          if (!validateStacksAddress(address)) {\n            throw new Error(\"Invalid Stacks address format\");\n          }\n          if (contractName !== undefined) {\n            if (!CONTRACT_NAME_REGEX.test(contractName)) {\n              throw new Error(\"Invalid contract name format: must start with letter and contain only letters, numbers, and hyphens\");\n            }\n            return Cl.contractPrincipal(address, contractName);\n          }\n          return Cl.standardPrincipal(${argName});\n        })()`;\n      default:\n        return `${argName}`;\n    }\n  }\n\n  if (type[\"string-ascii\"]) {\n    return `Cl.stringAscii(${argName})`;\n  }\n\n  if (type[\"string-utf8\"]) {\n    return `Cl.stringUtf8(${argName})`;\n  }\n\n  if (type.buff) {\n    return `(() => {\n      const value = ${argName};\n      if (value instanceof Uint8Array) {\n        return Cl.buffer(value);\n      }\n      if (typeof value === 'object' && value !== null && value.type && value.value) {\n        switch (value.type) {\n          case 'ascii':\n            return Cl.bufferFromAscii(value.value);\n          case 'utf8':\n            return Cl.bufferFromUtf8(value.value);\n          case 'hex':\n            return Cl.bufferFromHex(value.value);\n          default:\n            throw new Error(\\`Unsupported buffer type: \\${value.type}\\`);\n        }\n      }\n      if (typeof value === 'string') {\n        if (value.startsWith('0x') || /^[0-9a-fA-F]+$/.test(value)) {\n          return Cl.bufferFromHex(value);\n        }\n        const hasNonAscii = value.split('').some(char => char.charCodeAt(0) > 127);\n        if (hasNonAscii) {\n          return Cl.bufferFromUtf8(value);\n        }\n        return Cl.bufferFromAscii(value);\n      }\n      throw new Error(\\`Invalid buffer value: \\${value}\\`);\n    })()`;\n  }\n\n  if (type.optional) {\n    const innerConversion = generateClarityConversion(argName, {\n      type: type.optional,\n    });\n    return `${argName} !== null ? Cl.some(${innerConversion.replace(argName, `${argName}`)}) : Cl.none()`;\n  }\n\n  if (type.list) {\n    const innerConversion = generateClarityConversion(\"item\", {\n      type: type.list.type,\n    });\n    const maxLength = type.list.length || 100;\n    return `(() => {\n      const listValue = ${argName};\n      if (listValue.length > ${maxLength}) {\n        throw new Error(\\`List length \\${listValue.length} exceeds max ${maxLength}\\`);\n      }\n      return Cl.list(listValue.map(item => ${innerConversion}));\n    })()`;\n  }\n\n  if (type.tuple) {\n    const requiredFields = type.tuple.map((f: any) => f.name);\n    const fieldNames = JSON.stringify(requiredFields);\n    const fields = type.tuple\n      .map((field: any) => {\n        const camelFieldName = toCamelCase(field.name);\n        const fieldConversion = generateClarityConversion(\n          `tupleValue.${camelFieldName}`,\n          { type: field.type }\n        );\n        return `\"${field.name}\": ${fieldConversion}`;\n      })\n      .join(\", \");\n    return `(() => {\n      const tupleValue = ${argName};\n      const requiredFields = ${fieldNames};\n      for (const fieldName of requiredFields) {\n        const camelName = fieldName.replace(/-([a-z])/g, (_: string, l: string) => l.toUpperCase());\n        if (!(fieldName in tupleValue) && !(camelName in tupleValue)) {\n          throw new Error(\\`Missing tuple field: \\${fieldName}\\`);\n        }\n      }\n      return Cl.tuple({ ${fields} });\n    })()`;\n  }\n\n  if (type.response) {\n    const okConversion = generateClarityConversion(`responseValue.ok`, {\n      type: type.response.ok,\n    });\n    const errConversion = generateClarityConversion(`responseValue.err`, {\n      type: type.response.error,\n    });\n    return `(() => {\n      const responseValue = ${argName};\n      const hasOk = 'ok' in responseValue;\n      const hasErr = 'err' in responseValue;\n      if (hasOk && !hasErr) {\n        return Cl.ok(${okConversion});\n      }\n      if (hasErr && !hasOk) {\n        return Cl.error(${errConversion});\n      }\n      throw new Error(\"Response must have exactly 'ok' or 'err' property\");\n    })()`;\n  }\n\n  return `${argName}`;\n}\n\n/**\n * Generate read helper functions for a contract (fixed version)\n */\nfunction generateReadHelpers(\n  contract: ProcessedContract,\n  options: ActionsPluginOptions\n): string {\n  const { abi, name } = contract;\n  const functions = abi.functions || [];\n\n  const readOnlyFunctions = functions.filter(\n    (f: ClarityFunction) =>\n      (f.access as any) === \"read_only\" || f.access === \"read-only\"\n  );\n\n  if (readOnlyFunctions.length === 0) {\n    return \"\";\n  }\n\n  // Apply function filters\n  const filteredFunctions = readOnlyFunctions.filter(\n    (func: ClarityFunction) => {\n      if (\n        options.includeFunctions &&\n        !options.includeFunctions.includes(func.name)\n      ) {\n        return false;\n      }\n      if (\n        options.excludeFunctions &&\n        options.excludeFunctions.includes(func.name)\n      ) {\n        return false;\n      }\n      return true;\n    }\n  );\n\n  if (filteredFunctions.length === 0) {\n    return \"\";\n  }\n\n  const helpers = filteredFunctions.map((func: ClarityFunction) => {\n    const methodName = toCamelCase(func.name);\n    const argsSignature = generateArgsSignature(func.args);\n    const clarityArgs = generateClarityArgs(func.args, name);\n\n    return `async ${methodName}(${argsSignature}options?: {\n      network?: 'mainnet' | 'testnet' | 'devnet';\n      senderAddress?: string;\n    }) {\n      return await fetchCallReadOnlyFunction({\n        contractAddress: '${contract.address}',\n        contractName: '${contract.contractName}',\n        functionName: '${func.name}',\n        functionArgs: [${clarityArgs}],\n        network: options?.network ?? inferNetworkFromAddress('${contract.address}') ?? 'mainnet',\n        senderAddress: options?.senderAddress || 'SP000000000000000000002Q6VF78'\n      });\n    }`;\n  });\n\n  return `read: {\n    ${helpers.join(\",\\n\\n    \")}\n  }`;\n}\n\n/**\n * Generate write helper functions for a contract (fixed version)\n */\nfunction generateWriteHelpers(\n  contract: ProcessedContract,\n  options: ActionsPluginOptions\n): string {\n  const { abi, name } = contract;\n  const functions = abi.functions || [];\n  const envVarName = options.senderKeyEnv ?? \"STX_SENDER_KEY\";\n\n  const publicFunctions = functions.filter(\n    (f: ClarityFunction) => f.access === \"public\"\n  );\n\n  if (publicFunctions.length === 0) {\n    return \"\";\n  }\n\n  // Apply function filters\n  const filteredFunctions = publicFunctions.filter((func: ClarityFunction) => {\n    if (\n      options.includeFunctions &&\n      !options.includeFunctions.includes(func.name)\n    ) {\n      return false;\n    }\n    if (\n      options.excludeFunctions &&\n      options.excludeFunctions.includes(func.name)\n    ) {\n      return false;\n    }\n    return true;\n  });\n\n  if (filteredFunctions.length === 0) {\n    return \"\";\n  }\n\n  const helpers = filteredFunctions.map((func: ClarityFunction) => {\n    const methodName = toCamelCase(func.name);\n    const argsSignature = generateArgsSignature(func.args);\n    const clarityArgs = generateClarityArgs(func.args, name);\n\n    return `async ${methodName}(${argsSignature}senderKey?: string, options?: {\n      network?: 'mainnet' | 'testnet' | 'devnet';\n      fee?: string | number | undefined;\n      nonce?: bigint;\n      anchorMode?: 1 | 2 | 3; // AnchorMode: OnChainOnly = 1, OffChainOnly = 2, Any = 3\n      postConditions?: PostCondition[];\n      validateWithAbi?: boolean;\n    }) {\n      const resolvedSenderKey = senderKey ?? process.env.${envVarName};\n      if (!resolvedSenderKey) {\n        throw new Error('senderKey required: pass as argument or set ${envVarName} env var');\n      }\n      const { network = 'mainnet', ...txOptions } = options ?? {};\n\n      return await makeContractCall({\n        contractAddress: '${contract.address}',\n        contractName: '${contract.contractName}',\n        functionName: '${func.name}',\n        functionArgs: [${clarityArgs}],\n        senderKey: resolvedSenderKey,\n        network,\n        validateWithAbi: true,\n        ...txOptions\n      });\n    }`;\n  });\n\n  return `write: {\n    ${helpers.join(\",\\n\\n    \")}\n  }`;\n}\n\n/**\n * Generate action helpers (read and write functions) for a contract\n */\nexport async function generateActionHelpers(\n  contract: ProcessedContract,\n  options: ActionsPluginOptions\n): Promise<string> {\n  const readHelpers = generateReadHelpers(contract, options);\n  const writeHelpers = generateWriteHelpers(contract, options);\n\n  if (!readHelpers && !writeHelpers) {\n    return \"\";\n  }\n\n  const helpers = [readHelpers, writeHelpers].filter(Boolean);\n  return helpers.join(\",\\n\\n\");\n}",
    "packages/cli/src/commands/generate.ts": "import path from \"path\";\nimport chalk from \"chalk\";\nimport fg from \"fast-glob\";\nimport { toCamelCase } from \"@secondlayer/clarity-types\";\nimport { loadConfig } from \"../utils/config\";\nimport { StacksApiClient } from \"../utils/api\";\nimport { parseClarityFile, parseApiResponse } from \"../parsers/clarity\";\nimport { generateContractInterface } from \"../generators/contract\";\nimport { PluginManager } from \"../core/plugin-manager\";\nimport { checkBaseDependencies } from \"../utils/dependencies\";\nimport type {\n  ResolvedContract,\n  NetworkName,\n  ContractSource,\n  SecondLayerConfig,\n} from \"../types/config\";\nimport type { ContractConfig, ResolvedConfig } from \"../types/plugin\";\n\n/**\n * Generate command implementation\n */\n\nexport interface GenerateOptions {\n  config?: string;\n  out?: string;\n  apiKey?: string;\n  watch?: boolean;\n}\n\n/**\n * Check if a string looks like a deployed contract address (ADDRESS.contract-name)\n */\nfunction isContractAddress(input: string): boolean {\n  // Contract addresses are in format: SP/ST/SM/SN...ADDRESS.contract-name\n  // SP = mainnet standard, ST = testnet standard\n  // SM = mainnet multisig, SN = testnet multisig\n  const contractIdPattern = /^(SP|ST|SM|SN)[A-Z0-9]{38,}\\.[a-zA-Z][a-zA-Z0-9-]*$/;\n  return contractIdPattern.test(input);\n}\n\n/**\n * Infer network from contract address prefix\n */\nfunction inferNetwork(address: string): NetworkName {\n  // SP = mainnet standard, SM = mainnet multisig\n  if (address.startsWith(\"SP\") || address.startsWith(\"SM\")) {\n    return \"mainnet\";\n  }\n  // ST = testnet standard, SN = testnet multisig\n  return \"testnet\";\n}\n\n/**\n * Parse inputs and separate into local files and deployed contract addresses\n */\ninterface ParsedInputs {\n  files: string[];\n  contractIds: string[];\n}\n\nasync function parseInputs(inputs: string[]): Promise<ParsedInputs> {\n  const files: string[] = [];\n  const contractIds: string[] = [];\n\n  for (const input of inputs) {\n    // Check if it's a deployed contract address\n    if (isContractAddress(input)) {\n      contractIds.push(input);\n      continue;\n    }\n\n    // Check if it's a glob pattern\n    if (input.includes(\"*\") || input.includes(\"?\")) {\n      const matches = await fg(input, { cwd: process.cwd(), absolute: true });\n      for (const file of matches) {\n        if (file.endsWith(\".clar\")) {\n          files.push(file);\n        }\n      }\n      continue;\n    }\n\n    // Direct file path\n    if (input.endsWith(\".clar\")) {\n      const absolutePath = path.resolve(process.cwd(), input);\n      files.push(absolutePath);\n    }\n  }\n\n  return {\n    files: [...new Set(files)],\n    contractIds: [...new Set(contractIds)],\n  };\n}\n\n/**\n * Convert filename to camelCase contract name\n */\nfunction deriveContractName(filePath: string): string {\n  const basename = path.basename(filePath, \".clar\");\n  // Convert kebab-case or snake_case to camelCase\n  return basename\n    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())\n    .replace(/^(.)/, (_, char) => char.toLowerCase())\n    .replace(/^\\d/, \"_$&\"); // Prefix with underscore if starts with digit\n}\n\nconst DEFAULT_DEVNET_ADDRESS = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\";\n\n/**\n * Build config from direct inputs (local files and/or deployed contract addresses)\n */\nasync function buildConfigFromInputs(\n  parsedInputs: ParsedInputs,\n  outPath: string,\n  apiKey: string | undefined,\n  defaultAddress?: string\n): Promise<SecondLayerConfig> {\n  const contracts = [];\n  const deployer = defaultAddress || DEFAULT_DEVNET_ADDRESS;\n\n  // Warn about placeholder address for local files\n  if (parsedInputs.files.length > 0 && !defaultAddress) {\n    console.warn(\n      chalk.yellow(\n        `âš ï¸  Using placeholder address (${deployer}) for local contracts.\\n` +\n          `   Generated contract addresses won't match deployed addresses.\\n` +\n          `   Set defaultAddress in config or use deployed contract addresses.`\n      )\n    );\n  }\n\n  // Process local .clar files\n  for (const file of parsedInputs.files) {\n    const abi = await parseClarityFile(file);\n    const name = deriveContractName(file);\n\n    contracts.push({\n      name,\n      address: `${deployer}.${name}`,\n      abi,\n      _directFile: true,\n    });\n  }\n\n  // Process deployed contract addresses (fetch from API)\n  for (const contractId of parsedInputs.contractIds) {\n    const [address, contractName] = contractId.split(\".\");\n    const network = inferNetwork(address);\n\n    try {\n      const apiClient = new StacksApiClient(network, apiKey);\n      const contractInfo = await apiClient.getContractInfo(contractId);\n      const abi = parseApiResponse(contractInfo);\n      const name = toCamelCase(contractName);\n\n      contracts.push({\n        name,\n        address: contractId,\n        abi,\n        _directFile: true,\n      });\n    } catch (error: any) {\n      throw new Error(`Failed to fetch contract ${contractId}: ${error.message}`);\n    }\n  }\n\n  return {\n    out: outPath,\n    contracts,\n    plugins: [],\n  };\n}\n\nexport async function generate(files: string[], options: GenerateOptions) {\n  try {\n    let config: SecondLayerConfig;\n\n    // Check if direct inputs were provided (files or contract addresses)\n    if (files && files.length > 0) {\n      // Require -o/--out when using direct inputs\n      if (!options.out) {\n        console.error(chalk.red(\"âœ— Output path required\"));\n        console.error(\n          chalk.red(\"\\nWhen using direct inputs, you must specify an output path with -o/--out\")\n        );\n        console.log(chalk.gray(\"\\nExamples:\"));\n        console.log(chalk.gray(\"  secondlayer generate ./contracts/*.clar -o ./src/generated.ts\"));\n        console.log(chalk.gray(\"  secondlayer generate SP2C2YFP12AJZB1M6DY7SF9A3PRHWKGYGVWQKW3.my-token -o ./src/generated.ts\"));\n        process.exit(1);\n      }\n\n      // Parse inputs to separate files from contract addresses\n      const parsedInputs = await parseInputs(files);\n      const totalInputs = parsedInputs.files.length + parsedInputs.contractIds.length;\n\n      if (totalInputs === 0) {\n        console.error(chalk.red(\"âœ— No valid inputs found\"));\n        console.error(chalk.red(\"\\nNo .clar files or contract addresses matched the provided inputs\"));\n        process.exit(1);\n      }\n\n      // Get API key from option or environment variable\n      const apiKey = options.apiKey || process.env.HIRO_API_KEY;\n\n      config = await buildConfigFromInputs(parsedInputs, options.out, apiKey);\n    } else {\n      // Use config file (existing behavior)\n      config = await loadConfig(options.config);\n    }\n\n    // Get plugin manager from config loading\n    const pluginManager = new PluginManager();\n\n    // Register plugins from config\n    if (config.plugins) {\n      for (const plugin of config.plugins) {\n        pluginManager.register(plugin);\n      }\n    }\n\n    // Create resolved config with typed plugins\n    const resolvedConfig: ResolvedConfig = {\n      ...config,\n      plugins: pluginManager.getPlugins(),\n    };\n\n    // Execute configResolved hooks\n    await pluginManager.executeHook(\"configResolved\", resolvedConfig);\n\n    // Convert existing contracts to ContractConfig format (if any)\n    // Use the resolved config which includes contracts added by plugins\n    const contractConfigs: ContractConfig[] = (config.contracts || []).map(\n      (contract) => ({\n        name: contract.name,\n        address: contract.address,\n        source: contract.source,\n        abi: (contract as any).abi, // Include ABI if it exists (from plugins)\n        _clarinetSource: (contract as any)._clarinetSource, // Include plugin flags\n        _directFile: (contract as any)._directFile, // Include direct file flag\n      })\n    );\n\n    // Transform contracts through plugins (plugins can add more contracts)\n    const processedContracts = await pluginManager.transformContracts(\n      contractConfigs,\n      resolvedConfig\n    );\n\n    if (processedContracts.length === 0) {\n      console.log(chalk.yellow(\"âš  No contracts found to generate\"));\n      console.log(\"\\nTo get started:\");\n      console.log(\"  â€¢ Add contracts to your config file, or\");\n      console.log(\"  â€¢ Use plugins like clarinet() for local contracts\");\n      return;\n    }\n\n    // Execute generation through plugin system\n    const outputs = await pluginManager.executeGeneration(\n      processedContracts,\n      resolvedConfig\n    );\n\n    // If no plugins generated the main contracts output, generate it using the existing generator\n    if (!outputs.has(\"contracts\") && processedContracts.length > 0) {\n      const contractsCode = await generateContractInterface(processedContracts);\n      outputs.set(\"contracts\", {\n        path: config.out,\n        content: contractsCode,\n        type: \"contracts\",\n      });\n    }\n\n    // Transform outputs through plugins\n    const transformedOutputs = await pluginManager.transformOutputs(outputs);\n\n    // Write all outputs to disk\n    await pluginManager.writeOutputs(transformedOutputs);\n\n    // Check if @stacks/transactions is installed and warn if not\n    await checkBaseDependencies(process.cwd());\n\n    const contractCount = processedContracts.length;\n    const contractWord = contractCount === 1 ? \"contract\" : \"contracts\";\n    console.log(chalk.green(`âœ“ Generated \\`${config.out}\\` for ${contractCount} ${contractWord}`));\n  } catch (error: any) {\n    console.error(chalk.red(\"âœ— Generation failed\"));\n    console.error(chalk.red(`\\n${error.message}`));\n    if (process.env.DEBUG) {\n      console.error(error.stack);\n    }\n    process.exit(1);\n  }\n}\n\n// Keep existing contract resolution functions for backward compatibility and plugin use\nexport async function resolveContract(\n  source: ContractSource,\n  network: NetworkName,\n  apiKey?: string,\n  apiUrl?: string\n): Promise<ResolvedContract> {\n  // Handle local source files\n  if (source.source) {\n    const filePath = path.resolve(process.cwd(), source.source);\n    const abi = await parseClarityFile(filePath);\n\n    const name =\n      source.name ||\n      path\n        .basename(source.source, \".clar\")\n        .replace(/-/g, \"_\")\n        .replace(/^\\d/, \"_$&\");\n\n    // For local files, we need to construct the address\n    const address =\n      typeof source.address === \"string\"\n        ? source.address\n        : source.address?.[network] || DEFAULT_DEVNET_ADDRESS;\n\n    const [contractAddress, contractName] = address.includes(\".\")\n      ? address.split(\".\")\n      : [address, name];\n\n    return {\n      name,\n      address: contractAddress,\n      contractName: contractName || name,\n      abi,\n      source: \"local\",\n    };\n  }\n\n  // Handle deployed contracts\n  if (source.address) {\n    const contractId =\n      typeof source.address === \"string\"\n        ? source.address\n        : source.address[network];\n\n    if (!contractId) {\n      throw new Error(`No contract address for network ${network}`);\n    }\n\n    const contractInfo = await new StacksApiClient(\n      network,\n      apiKey,\n      apiUrl\n    ).getContractInfo(contractId);\n    const abi = parseApiResponse(contractInfo);\n\n    const [contractAddress, contractName] = contractId.split(\".\");\n    const name =\n      source.name || contractName.replace(/-/g, \"_\").replace(/^\\d/, \"_$&\");\n\n    return {\n      name,\n      address: contractAddress,\n      contractName,\n      abi,\n      source: \"api\",\n    };\n  }\n\n  throw new Error(\"Contract must have either address or source\");\n}\n\nexport async function resolveContracts(\n  source: ContractSource,\n  defaultNetwork: NetworkName | undefined,\n  apiKey?: string,\n  apiUrl?: string\n): Promise<ResolvedContract[]> {\n  // Handle single network contracts (existing behavior)\n  if (typeof source.address === \"string\" || source.source) {\n    const resolved = await resolveContract(\n      source,\n      defaultNetwork || \"testnet\", // Use testnet as fallback for single contracts\n      apiKey,\n      apiUrl\n    );\n    return [resolved];\n  }\n\n  // Handle multi-network contracts\n  if (source.address && typeof source.address === \"object\") {\n    const resolvedContracts: ResolvedContract[] = [];\n\n    // If defaultNetwork is specified, only generate that network\n    // If no network specified, generate all networks defined in the address object\n    const networksToGenerate = defaultNetwork\n      ? [defaultNetwork].filter(\n          (net) => (source.address as Partial<Record<NetworkName, string>>)[net]\n        ) // Only if address exists for that network\n      : (Object.keys(source.address) as NetworkName[]);\n\n    for (const network of networksToGenerate) {\n      const contractId = source.address[network];\n      if (!contractId) continue;\n\n      try {\n        const networkApiClient = new StacksApiClient(network, apiKey, apiUrl);\n\n        const contractInfo = await networkApiClient.getContractInfo(contractId);\n        const abi = parseApiResponse(contractInfo);\n\n        const [contractAddress, contractName] = contractId.split(\".\");\n        const baseName =\n          source.name || contractName.replace(/-/g, \"_\").replace(/^\\d/, \"_$&\");\n\n        // Generate network-specific names\n        const name =\n          network === \"mainnet\"\n            ? baseName\n            : `${network}${baseName.charAt(0).toUpperCase() + baseName.slice(1)}`;\n\n        resolvedContracts.push({\n          name,\n          address: contractAddress,\n          contractName,\n          abi,\n          source: \"api\",\n        });\n      } catch (error: any) {\n        console.warn(\n          `Warning: Failed to resolve contract for ${network}: ${error.message}`\n        );\n      }\n    }\n\n    return resolvedContracts;\n  }\n\n  throw new Error(\"Contract must have either address or source\");\n}",
    "packages/clarity-types/package.json": "{\n  \"name\": \"@secondlayer/clarity-types\",\n  \"version\": \"0.5.0\",\n  \"description\": \"TypeScript type definitions and utilities for Clarity smart contract ABIs\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    }\n  },\n  \"files\": [\n    \"dist\",\n    \"src\"\n  ],\n  \"scripts\": {\n    \"build\": \"bunup\",\n    \"dev\": \"bunup --watch\",\n    \"test\": \"vitest\",\n    \"test:ui\": \"vitest --ui\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"prepublishOnly\": \"bun run build\"\n  },\n  \"keywords\": [\n    \"stacks\",\n    \"clarity\",\n    \"blockchain\",\n    \"smart-contracts\",\n    \"typescript\",\n    \"types\"\n  ],\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@stacks/transactions\": \"^7.0.0\"\n  },\n  \"devDependencies\": {\n    \"@vitest/ui\": \"^1.2.1\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  }\n}",
    "package.json": "{\n  \"name\": \"secondlayer\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"workspaces\": [\"packages/*\"],\n  \"scripts\": {\n    \"build\": \"bun run build:types && bun run build:docs && bun run build:cli\",\n    \"build:cli\": \"bun run --filter @secondlayer/cli build\",\n    \"build:docs\": \"bun run --filter @secondlayer/clarity-docs build\",\n    \"build:types\": \"bun run --filter @secondlayer/clarity-types build\",\n    \"dev\": \"bun run --filter '*' dev\",\n    \"test\": \"bun run --filter '*' test\",\n    \"test:cli\": \"bun run --filter @secondlayer/cli test\",\n    \"test:docs\": \"bun run --filter @secondlayer/clarity-docs test\",\n    \"test:types\": \"bun run --filter @secondlayer/clarity-types test\",\n    \"typecheck\": \"bun run --filter '*' typecheck\",\n    \"typecheck:docs\": \"bun run --filter @secondlayer/clarity-docs typecheck\",\n    \"clean\": \"rm -rf packages/*/dist packages/*/node_modules node_modules\",\n    \"changeset\": \"changeset\",\n    \"version\": \"changeset version\",\n    \"release\": \"bun run build && NPM_TOKEN=$NPM_SECOND_LAYER_TOKEN changeset publish\"\n  },\n  \"devDependencies\": {\n    \"@changesets/changelog-github\": \"^0.5.2\",\n    \"@changesets/cli\": \"^2.29.8\",\n    \"@types/node\": \"^20.11.0\",\n    \"bunup\": \"^0.9.0\",\n    \"typescript\": \"^5.3.3\",\n    \"vitest\": \"^1.2.1\"\n  },\n  \"engines\": {\n    \"node\": \">=20.19.0\"\n  }\n}",
    "packages/cli/CHANGELOG.md": "# @secondlayer/cli\n\n## 1.2.0\n\n### Minor Changes\n\n- Migrate code formatter from Prettier to Biome JS API with import sorting and tabs\n\n## 1.1.0\n\n### Minor Changes\n\n- feat(actions): optional senderKey with STX_SENDER_KEY env var fallback\n\n## 1.0.0\n\n### Major Changes\n\n- BREAKING: Renamed all Stacks/Codegen references to SecondLayer\n  - `StacksConfig` â†’ `SecondLayerConfig`\n  - `StacksCodegenPlugin` â†’ `SecondLayerPlugin`\n  - `StacksReactConfig` â†’ `SecondLayerReactConfig`\n  - `StacksProvider` â†’ `SecondLayerProvider`\n  - `useStacksConfig` â†’ `useSecondLayerConfig`\n  - `createStacksConfig` â†’ `createSecondLayerConfig`\n  - Config file: `stacks.config.ts` â†’ `secondlayer.config.ts`\n\n## 0.3.10\n\n### Patch Changes\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.5.0\n\n## 0.3.9\n\n### Patch Changes\n\n- fix: consolidated audit fixes - config regex, missing imports, type validation, error handling, code deduplication\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.4.2\n\n## 0.3.8\n\n### Patch Changes\n\n- Fix generated code linting: map Clarity `none` type to TypeScript `null` instead of `any`\n\n  This fixes Biome and other linter warnings for response types like `{ ok: null } | { err: bigint }` in generated constant getters.\n\n## 0.3.7\n\n### Patch Changes\n\n- Hardening improvements based on audit findings:\n  - Add composite type validation for lists (max length), tuples (required fields), and responses (ok/err shape)\n  - Create ABI normalization layer for format compatibility (buffer/buff, read_only/read-only)\n  - Enhance principal validation with contract name format checking\n  - Consolidate type mapping utilities into shared module\n  - Remove @secondlayer/clarity-types dependency from generated code for better DX\n  - Inline validation utilities in generated code (CONTRACT_NAME_REGEX)\n\n## 0.3.6\n\n### Patch Changes\n\n- Add composite type validation and consolidate shared utilities\n\n  - Add validation for lists (max length), tuples (required fields), and responses (ok/err shape)\n  - Add contract name format validation for principals\n  - Create ABI normalization layer for buffer/buff and read_only/read-only compatibility\n  - Consolidate toCamelCase implementations into clarity-types\n  - Consolidate type mapping utilities into shared module\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.4.1\n\n## 0.3.5\n\n### Patch Changes\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.4.0\n\n## 0.3.4\n\n### Patch Changes\n\n- Simplify generate command output to single success message\n\n## 0.3.3\n\n### Patch Changes\n\n- Fix contractName to use original kebab-case for API calls while keeping camelCase for JS exports\n  - Preserve `_directFile` flag through contract config transformation\n  - Extract original contract name from address for API endpoints (vars, constants, maps)\n  - Maintains `sbtcToken` for JS imports but uses `sbtc-token` for API URLs\n\n## 0.3.2\n\n### Patch Changes\n\n- Fix lint issues in generated code and improve dependency DX\n  - Remove useless else clauses after return statements (noUselessElse)\n  - Replace control character regex with charCodeAt for ASCII detection (noControlCharactersInRegex)\n  - Add warning when @stacks/transactions peer dependency is missing\n  - Add @requires JSDoc tag to generated file header\n\n## 0.3.1\n\n### Patch Changes\n\n- Auto-infer network from contract address prefix (SP/SM = mainnet, ST/SN = testnet) for maps, variables, constants, and read helpers. Network parameter is now optional with explicit override still supported for devnet testing.\n\n## 0.3.0\n\n### Minor Changes\n\n- Add support for contract state (maps, variables, and constants)\n  - Generate typed `maps` object with `get()` methods for reading map entries via Hiro API\n  - Generate typed `vars` object with `get()` methods for reading data variables\n  - Generate typed `constants` object with `get()` methods for reading contract constants\n  - Add React hooks for maps (`useContractMapName`), variables (`useContractVarName`), and constants (`useContractConstantName`)\n  - Constants hooks use `staleTime: Infinity` since values never change\n  - Parse maps and variables from Hiro API contract interface responses\n\n### Patch Changes\n\n- Fix type safety for complex Clarity types in React hooks\n\n  - Fix `mapClarityTypeToTS` to properly handle response, tuple, list, and optional types\n  - React hooks now return proper TypeScript types instead of `any` for complex return values\n  - Fix PostCondition types (use `PostCondition[]` instead of `any[]`)\n  - Add proper parentheses for union types in list contexts (e.g., `(string | null)[]`)\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.3.0\n\n## 0.2.5\n\n### Patch Changes\n\n- Fix issue with CommonJS bundling\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.2.2\n\n## 0.2.4\n\n### Patch Changes\n\n- Clean up eager imports and heavy deps\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.2.1\n\n## 0.2.3\n\n### Patch Changes\n\n- Fix --version flag to read version dynamically from package.json\n\n## 0.2.2\n\n### Patch Changes\n\n- Replace Bun.Glob with fast-glob for Node.js compatibility\n\n## 0.2.1\n\n### Patch Changes\n\n- Fix workspace dependency resolution for @secondlayer/clarity-types\n\n## 0.2.0\n\n### Minor Changes\n\n- Initial monorepo release. The CLI now includes a new testing plugin for Clarinet SDK integration, and type inference is powered by the new @secondlayer/clarity-types package with runtime validation guards and value converters.\n\n### Patch Changes\n\n- Updated dependencies []:\n  - @secondlayer/clarity-types@0.2.0",
    "packages/cli/package.json": "{\n  \"name\": \"@secondlayer/cli\",\n  \"version\": \"1.2.0\",\n  \"description\": \"CLI for generating type-safe contract interfaces for the Stacks blockchain\",\n  \"type\": \"module\",\n  \"bin\": {\n    \"secondlayer\": \"./dist/cli.js\"\n  },\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    },\n    \"./plugins\": {\n      \"types\": \"./dist/plugins/index.d.ts\",\n      \"import\": \"./dist/plugins/index.js\"\n    }\n  },\n  \"files\": [\n    \"dist\",\n    \"templates\"\n  ],\n  \"scripts\": {\n    \"build\": \"bunup\",\n    \"dev\": \"bunup --watch\",\n    \"test\": \"vitest\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"prepublishOnly\": \"bun run build\"\n  },\n  \"keywords\": [\n    \"stacks\",\n    \"clarity\",\n    \"blockchain\",\n    \"smart-contracts\",\n    \"cli\"\n  ],\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@secondlayer/clarity-types\": \"^0.5.0\",\n    \"@stacks/transactions\": \"7.0.6\",\n    \"@biomejs/js-api\": \"^0.7.0\",\n    \"@biomejs/wasm-nodejs\": \"^1.9.0\",\n    \"esbuild\": \"^0.19.0\"\n  },\n  \"devDependencies\": {\n    \"@antfu/ni\": \"^24.4.0\",\n    \"@hirosystems/clarinet-sdk\": \"^3.0.2\",\n    \"@stacks/connect\": \"^8.1.9\",\n    \"@tanstack/react-query\": \"^5.77.0\",\n    \"@types/bun\": \"^1.1.14\",\n    \"@types/react\": \"^19.1.5\",\n    \"chalk\": \"^5.3.0\",\n    \"commander\": \"^11.1.0\",\n    \"execa\": \"^9.5.3\",\n    \"fast-glob\": \"^3.3.3\",\n    \"got\": \"^13.0.0\",\n    \"react\": \"^19.1.0\"\n  },\n  \"engines\": {\n    \"node\": \">=20.19.0\"\n  }\n}",
    "README.md": "# @secondlayer/cli\n\nType-safe contract interfaces, functions, and React hooks for Clarity smart contracts.\n\n## Install\n\n```bash\nbun add -g @secondlayer/cli\n```\n\n## Quick Start\n\nGenerate from local files or deployed contractsâ€”no config required:\n\n```bash\n# Local .clar files\nsecondlayer generate ./contracts/token.clar -o ./src/generated.ts\n\n# Deployed contracts (network inferred from address)\nsecondlayer generate SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9.alex-vault -o ./src/generated.ts\n\n# Glob patterns\nsecondlayer generate \"./contracts/*.clar\" -o ./src/generated.ts\n```\n\n## With Config\n\n```bash\nsecondlayer init  # creates secondlayer.config.ts\nsecondlayer generate\n```\n\n```typescript\n// secondlayer.config.ts\nimport { defineConfig } from '@secondlayer/cli'\nimport { clarinet, actions, react } from '@secondlayer/cli/plugins'\n\nexport default defineConfig({\n  out: 'src/generated.ts',\n  plugins: [\n    clarinet(),  // parse local Clarinet project\n    actions(),   // add read/write helpers\n    react(),     // generate React hooks\n  ],\n})\n```\n\n## Usage\n\n### Contract Calls\n\n```typescript\nimport { token } from './generated/contracts'\nimport { makeContractCall, fetchCallReadOnlyFunction } from '@stacks/transactions'\n\n// works with @stacks/transactions directly\nawait makeContractCall({\n  ...token.transfer({ amount: 100n, recipient: \"SP...\" }),\n  network: 'mainnet',\n})\n\nawait fetchCallReadOnlyFunction({\n  ...token.getBalance({ account: \"SP...\" }),\n  network: 'mainnet',\n})\n```\n\n### Read/Write Helpers\n\nRequires `actions()` plugin:\n\n```typescript\n// read-only\nconst balance = await token.read.getBalance({ account: \"SP...\" })\n\n// write (uses STX_SENDER_KEY env var)\nawait token.write.transfer({ amount: 100n, recipient: \"SP...\" })\n\n// or pass senderKey explicitly\nawait token.write.transfer({ amount: 100n, recipient: \"SP...\" }, \"<sender-key>\")\n\n// with additional options\nawait token.write.transfer({ amount: 100n, recipient: \"SP...\" }, \"<sender-key>\", { network: 'testnet' })\n```\n\n### Contract State\n\nAccess maps, variables, constants directly:\n\n```typescript\n// maps\nconst balance = await token.maps.balances.get(\"SP...\")\n\n// variables\nconst supply = await token.vars.totalSupply.get()\n\n// constants\nconst max = await token.constants.maxSupply.get()\n\n// network override\nconst devBalance = await token.maps.balances.get(\"SP...\", { network: 'devnet' })\n```\n\n### React Hooks\n\nRequires `react()` plugin:\n\n```typescript\nimport { useTokenTransfer, useTokenBalances, useTokenTotalSupply } from './generated/hooks'\n\nfunction App() {\n  const { transfer, isRequestPending } = useTokenTransfer()\n  const { data: balance } = useTokenBalances(\"SP...\")\n  const { data: supply } = useTokenTotalSupply()\n\n  return (\n    <button onClick={() => transfer({ amount: 100n, recipient: \"SP...\" })} disabled={isRequestPending}>\n      Transfer\n    </button>\n  )\n}\n```\n\n### Testing Helpers\n\nRequires `testing()` plugin:\n\n```typescript\nimport { getContracts } from './helpers'\n\nconst simnet = await initSimnet()\nconst { token } = getContracts(simnet)\n\n// call functions\nconst result = token.transfer({ amount: 100n, recipient: \"ST...\" }, \"wallet_1\")\nexpect(result.result).toBeOk(Cl.bool(true))\n\n// read state\nconst supply = token.vars.totalSupply()\nconst balance = token.maps.balances(\"ST...\")\n```\n\n## Plugins\n\n| Plugin | Description |\n|--------|-------------|\n| `clarinet()` | Parse local Clarinet project |\n| `actions()` | Add `read`/`write` helpers |\n| `react()` | Generate React hooks |\n| `testing()` | Generate Clarinet SDK test helpers |\n\n## Network Inference\n\nAddress prefix determines network:\n- `SP`/`SM` â†’ mainnet\n- `ST`/`SN` â†’ testnet\n\n## License\n\nMIT"
  },
  "gitDiffs": {
    "workTree": "diff --git a/packages/clarity-docs/tests/dao-test.ts b/packages/clarity-docs/tests/dao-test.ts\ndeleted file mode 100644\nindex 89e5e35..0000000\n--- a/packages/clarity-docs/tests/dao-test.ts\n+++ /dev/null\n@@ -1,105 +0,0 @@\n-/**\n- * Test ClarityDoc parsing on DAO contracts\n- */\n-\n-import { readFileSync } from 'fs';\n-import { describe, it, expect } from 'vitest';\n-import {\n-  extractDocs,\n-  generateMarkdown,\n-  generateJson,\n-  toJson,\n-} from '../src/index';\n-\n-const DAO_PATH = '/tmp/dao/contracts';\n-\n-describe('DAO Contract Documentation', () => {\n-  it('parses executor-dao.clar', () => {\n-    const source = readFileSync(`${DAO_PATH}/executor-dao.clar`, 'utf-8');\n-    const docs = extractDocs(source);\n-\n-    // Header\n-    expect(docs.header).toBeTruthy();\n-    expect(docs.header?.contract).toBe('Executor DAO');\n-    expect(docs.header?.author).toBe('DAO Framework');\n-    expect(docs.header?.version).toBe('1.0.0');\n-\n-    // Functions\n-    expect(docs.functions.length).toBeGreaterThan(0);\n-    const setExtension = docs.functions.find(f => f.name === 'set-extension');\n-    expect(setExtension).toBeTruthy();\n-    expect(setExtension?.params.length).toBe(2);\n-\n-    // Error constants\n-    expect(docs.constants.length).toBe(3);\n-    const json = toJson(docs);\n-    const errUnauth = json.constants.find(c => c.name === 'ERR_UNAUTHORIZED');\n-    expect(errUnauth?.isError).toBe(true);\n-    expect(errUnauth?.errorCode).toBe('u1000');\n-\n-    // Maps\n-    expect(docs.maps.length).toBe(2);\n-    const execMap = docs.maps.find(m => m.name === 'ExecutedProposals');\n-    expect(execMap?.key).toBeTruthy();\n-    expect(execMap?.value).toBeTruthy();\n-\n-    // Variables\n-    expect(docs.variables.length).toBe(1);\n-    expect(docs.variables[0].name).toBe('executive');\n-\n-    console.log('\\nðŸ“‹ executor-dao.clar:');\n-    console.log(`  Functions: ${docs.functions.length}`);\n-    console.log(`  Constants: ${docs.constants.length}`);\n-    console.log(`  Maps: ${docs.maps.length}`);\n-    console.log(`  Variables: ${docs.variables.length}`);\n-  });\n-\n-  it('parses proposal-trait.clar', () => {\n-    const source = readFileSync(`${DAO_PATH}/traits/proposal-trait.clar`, 'utf-8');\n-    const docs = extractDocs(source);\n-\n-    expect(docs.header?.contract).toBe('Proposal Trait');\n-    expect(docs.traits.length).toBe(1);\n-    expect(docs.traits[0].name).toBe('proposal-trait');\n-\n-    console.log('\\nðŸ“‹ proposal-trait.clar:');\n-    console.log(`  Traits: ${docs.traits.length}`);\n-  });\n-\n-  it('parses extension-trait.clar', () => {\n-    const source = readFileSync(`${DAO_PATH}/traits/extension-trait.clar`, 'utf-8');\n-    const docs = extractDocs(source);\n-\n-    expect(docs.header?.contract).toBe('Extension Trait');\n-    expect(docs.traits.length).toBe(1);\n-    expect(docs.traits[0].name).toBe('extension-trait');\n-\n-    console.log('\\nðŸ“‹ extension-trait.clar:');\n-    console.log(`  Traits: ${docs.traits.length}`);\n-  });\n-\n-  it('generates markdown for executor-dao', () => {\n-    const source = readFileSync(`${DAO_PATH}/executor-dao.clar`, 'utf-8');\n-    const docs = extractDocs(source);\n-    const md = generateMarkdown(docs);\n-\n-    expect(md).toContain('# Executor DAO');\n-    expect(md).toContain('set-extension');\n-    expect(md).toContain('ERR_UNAUTHORIZED');\n-\n-    console.log('\\nðŸ“ Markdown output:', md.length, 'chars');\n-  });\n-\n-  it('generates JSON for executor-dao', () => {\n-    const source = readFileSync(`${DAO_PATH}/executor-dao.clar`, 'utf-8');\n-    const docs = extractDocs(source);\n-    const json = generateJson(docs);\n-    const parsed = JSON.parse(json);\n-\n-    expect(parsed.header.contract).toBe('Executor DAO');\n-    expect(parsed.functions.length).toBeGreaterThan(0);\n-    expect(parsed.constants.some((c: any) => c.isError)).toBe(true);\n-\n-    console.log('\\nðŸ“„ JSON output:', json.length, 'chars');\n-  });\n-});\n",
    "staged": ""
  },
  "gitLogs": [
    {
      "date": "2025-12-21 18:24:32 -0600",
      "message": "chore(clarity-docs): version release",
      "files": [
        "packages/clarity-docs/CHANGELOG.md",
        "packages/clarity-docs/package.json"
      ]
    },
    {
      "date": "2025-12-21 18:23:20 -0600",
      "message": "chore(clarity-docs): use explicit version for clarity-types dep",
      "files": [
        "packages/clarity-docs/package.json",
        "packages/clarity-docs/tests/dao-test.ts"
      ]
    },
    {
      "date": "2025-12-21 13:31:48 -0600",
      "message": "chore(clarity-docs): version release",
      "files": [
        "packages/clarity-docs/CHANGELOG.md",
        "packages/clarity-docs/package.json"
      ]
    },
    {
      "date": "2025-12-21 13:31:22 -0600",
      "message": "feat(clarity-docs): add package for clarity documentation parsing",
      "files": [
        "bun.lock",
        "package.json",
        "packages/clarity-docs/SIP-DRAFT-claritydoc.md",
        "packages/clarity-docs/bunup.config.ts",
        "packages/clarity-docs/package.json",
        "packages/clarity-docs/src/generators/index.ts",
        "packages/clarity-docs/src/generators/json.ts",
        "packages/clarity-docs/src/generators/markdown.ts",
        "packages/clarity-docs/src/index.ts",
        "packages/clarity-docs/src/parser/extractor.ts",
        "packages/clarity-docs/src/parser/index.ts",
        "packages/clarity-docs/src/parser/lexer.ts",
        "packages/clarity-docs/src/parser/parser.ts",
        "packages/clarity-docs/src/types/doc-block.ts",
        "packages/clarity-docs/src/types/index.ts",
        "packages/clarity-docs/src/types/tags.ts",
        "packages/clarity-docs/src/utils/index.ts",
        "packages/clarity-docs/src/utils/strip.ts",
        "packages/clarity-docs/src/validation/index.ts",
        "packages/clarity-docs/src/validation/validators.ts",
        "packages/clarity-docs/tests/generators.test.ts",
        "packages/clarity-docs/tests/parser.test.ts",
        "packages/clarity-docs/tsconfig.json",
        "packages/clarity-docs/vitest.config.ts"
      ]
    },
    {
      "date": "2025-12-20 12:38:10 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-20 12:37:58 -0600",
      "message": "feat(cli): migrate formatter from prettier to biome js-api",
      "files": [
        "bun.lock",
        "package.json",
        "packages/cli/biome.json",
        "packages/cli/bunup.config.ts",
        "packages/cli/package.json",
        "packages/cli/src/utils/format.ts",
        "packages/cli/tests/buffer-conversion.test.ts",
        "packages/cli/tests/generator.test.ts",
        "packages/cli/tests/maps-variables.test.ts"
      ]
    },
    {
      "date": "2025-12-19 23:04:34 -0600",
      "message": "refactor(cli): extract duplicate error handling in client",
      "files": [
        "packages/cli/src/utils/api.ts"
      ]
    },
    {
      "date": "2025-12-16 20:54:57 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-16 20:54:45 -0600",
      "message": "feat(actions): optional senderKey with env var fallback",
      "files": [
        "README.md",
        "packages/cli/src/plugins/actions/generators.ts",
        "packages/cli/src/plugins/actions/index.ts",
        "packages/cli/tests/actions-plugin.test.ts"
      ]
    },
    {
      "date": "2025-12-16 20:43:57 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-16 20:43:45 -0600",
      "message": "chore: rename codegen to secondlayer",
      "files": [
        ".gitignore",
        "README.md",
        "packages/clarity-types/README.md",
        "packages/cli/src/cli.ts",
        "packages/cli/src/commands/generate.ts",
        "packages/cli/src/commands/init.ts",
        "packages/cli/src/core/plugin-manager.ts",
        "packages/cli/src/generated/provider.tsx",
        "packages/cli/src/generators/hooks.ts",
        "packages/cli/src/generators/react-provider.ts",
        "packages/cli/src/index.ts",
        "packages/cli/src/plugins/clarinet/index.ts",
        "packages/cli/src/plugins/index.ts",
        "packages/cli/src/plugins/react/generators/contract.ts",
        "packages/cli/src/plugins/react/generators/generic.ts",
        "packages/cli/src/plugins/react/provider/context.ts",
        "packages/cli/src/plugins/react/provider/index.ts",
        "packages/cli/src/plugins/react/provider/provider.tsx",
        "packages/cli/src/plugins/react/provider/types.ts",
        "packages/cli/src/plugins/react/types.ts",
        "packages/cli/src/react/config.ts",
        "packages/cli/src/react/hooks.ts",
        "packages/cli/src/react/index.ts",
        "packages/cli/src/react/types.ts",
        "packages/cli/src/types/config.ts",
        "packages/cli/src/types/plugin.ts",
        "packages/cli/src/utils/config.ts"
      ]
    },
    {
      "date": "2025-12-16 20:15:29 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-16 20:15:19 -0600",
      "message": "feat(clarity-types): add token, trait, map, and variable abi extractors",
      "files": [
        "packages/clarity-types/README.md",
        "packages/clarity-types/src/abi/extractors.ts",
        "packages/clarity-types/src/abi/functions.ts",
        "packages/clarity-types/src/index.ts",
        "packages/clarity-types/src/validation/guards.ts",
        "packages/clarity-types/tests/runtime.test.ts",
        "packages/clarity-types/tests/types.test.ts"
      ]
    },
    {
      "date": "2025-12-16 17:56:40 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-16 17:56:23 -0600",
      "message": "fix: implement fixes - regex, imports, validation, error handling, deduplication",
      "files": [
        "packages/clarity-types/src/converters/index.ts",
        "packages/cli/src/commands/generate.ts",
        "packages/cli/src/core/plugin-manager.ts",
        "packages/cli/src/generators/contract.ts",
        "packages/cli/src/generators/hooks.ts",
        "packages/cli/src/generators/react-provider.ts",
        "packages/cli/src/generators/stacks-api-generator.ts",
        "packages/cli/src/parsers/clarity.ts",
        "packages/cli/src/plugins/clarinet/index.ts",
        "packages/cli/src/plugins/react/generators/contract.ts",
        "packages/cli/src/plugins/react/generators/generic.ts",
        "packages/cli/src/plugins/react/provider/index.ts",
        "packages/cli/src/types/config.ts",
        "packages/cli/src/types/plugin.ts",
        "packages/cli/src/utils/abi-compat.ts",
        "packages/cli/src/utils/api.ts",
        "packages/cli/src/utils/config.ts",
        "packages/cli/src/utils/format.ts"
      ]
    },
    {
      "date": "2025-12-15 11:12:22 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-15 11:12:11 -0600",
      "message": "fix: map clarity none type to null instead of any in generated code",
      "files": [
        "packages/cli/src/utils/type-mapping.ts"
      ]
    },
    {
      "date": "2025-12-15 11:07:37 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-15 11:07:27 -0600",
      "message": "fix: harden cli with audit fixes and remove clarity-types from generated code",
      "files": [
        "packages/cli/src/generators/contract.ts",
        "packages/cli/src/plugins/actions/generators.ts",
        "packages/cli/src/utils/type-mapping.ts"
      ]
    },
    {
      "date": "2025-12-15 10:57:25 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-15 10:57:11 -0600",
      "message": "fix: add composite validation and consolidate shared utilities",
      "files": [
        "packages/clarity-types/src/utils/index.ts",
        "packages/cli/src/generators/contract.ts",
        "packages/cli/src/generators/hooks.ts",
        "packages/cli/src/parsers/clarity.ts",
        "packages/cli/src/plugins/actions/generators.ts",
        "packages/cli/src/plugins/react/generators/contract.ts",
        "packages/cli/src/plugins/react/generators/utils.ts",
        "packages/cli/src/plugins/testing/generators.ts",
        "packages/cli/src/utils/abi-compat.ts",
        "packages/cli/src/utils/type-mapping.ts",
        "packages/cli/tests/type-safety.test.ts"
      ]
    },
    {
      "date": "2025-12-15 10:32:58 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-15 10:32:44 -0600",
      "message": "feat(clarity-types): harden with upstream validation and composite type support",
      "files": [
        "bun.lock",
        "packages/clarity-types/gpt-5.1-codex-max-high-clarity-types-audit.md",
        "packages/clarity-types/package.json",
        "packages/clarity-types/src/abi/extractors.ts",
        "packages/clarity-types/src/converters/index.ts",
        "packages/clarity-types/src/index.ts",
        "packages/clarity-types/src/integration/connect.ts",
        "packages/clarity-types/src/types/mappings.ts",
        "packages/clarity-types/src/types/primitives.ts",
        "packages/clarity-types/src/utils/index.ts",
        "packages/clarity-types/src/validation/guards.ts",
        "packages/clarity-types/tests/runtime.test.ts"
      ]
    },
    {
      "date": "2025-12-15 09:44:38 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-15 09:44:24 -0600",
      "message": "fix: simplify generate command output to single success message",
      "files": [
        "packages/cli/src/commands/generate.ts"
      ]
    },
    {
      "date": "2025-12-15 09:36:32 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-15 09:36:11 -0600",
      "message": "fix: use original contract name for api calls in vars/constants/maps",
      "files": [
        "packages/cli/src/commands/generate.ts",
        "packages/cli/src/core/plugin-manager.ts"
      ]
    },
    {
      "date": "2025-12-15 09:13:52 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-15 09:13:35 -0600",
      "message": "fix: resolve lint issues in generated code and improve dependency dx",
      "files": [
        "packages/cli/src/commands/generate.ts",
        "packages/cli/src/generators/contract.ts",
        "packages/cli/src/plugins/actions/generators.ts",
        "packages/cli/src/utils/dependencies.ts"
      ]
    },
    {
      "date": "2025-12-14 22:55:34 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-14 22:54:48 -0600",
      "message": "feat: auto-infer network from contract address for improved dx",
      "files": [
        "README.md",
        "packages/cli/src/generators/contract.ts",
        "packages/cli/src/plugins/actions/generators.ts"
      ]
    },
    {
      "date": "2025-12-14 22:27:09 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-14 22:26:44 -0600",
      "message": "feat: add contract state support (maps, variables, constants) and fix type safety",
      "files": [
        "bun.lock",
        "package.json",
        "packages/clarity-types/src/abi/functions.ts",
        "packages/clarity-types/src/index.ts",
        "packages/cli/src/generators/contract.ts",
        "packages/cli/src/generators/hooks.ts",
        "packages/cli/src/parsers/clarity.ts",
        "packages/cli/src/plugins/actions/generators.ts",
        "packages/cli/src/plugins/actions/index.ts",
        "packages/cli/src/plugins/react/generators/contract.ts",
        "packages/cli/src/plugins/react/generators/generic.ts",
        "packages/cli/src/plugins/react/generators/utils.ts",
        "packages/cli/tests/maps-variables.test.ts",
        "packages/cli/tests/type-safety.test.ts"
      ]
    },
    {
      "date": "2025-12-13 13:14:35 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-13 13:13:59 -0600",
      "message": "fix: commonjs deps",
      "files": [
        "packages/cli/bunup.config.ts",
        "packages/cli/package.json",
        "packages/cli/src/commands/generate.ts",
        "packages/cli/src/commands/init.ts",
        "packages/cli/src/utils/dependencies.ts"
      ]
    },
    {
      "date": "2025-12-13 13:04:17 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-13 13:02:50 -0600",
      "message": "chore: performance fixes",
      "files": [
        "packages/cli/bunup.config.ts",
        "packages/cli/package.json",
        "packages/cli/src/cli.ts",
        "packages/cli/src/core/plugin-manager.ts",
        "packages/cli/src/utils/config.ts"
      ]
    },
    {
      "date": "2025-12-12 22:14:56 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json",
        "packages/cli/src/cli.ts"
      ]
    },
    {
      "date": "2025-12-12 22:06:49 -0600",
      "message": "chore: version release",
      "files": [
        "bun.lock",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json",
        "packages/cli/src/commands/generate.ts"
      ]
    },
    {
      "date": "2025-12-12 22:03:12 -0600",
      "message": "chore: version release",
      "files": [
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-12 21:48:35 -0600",
      "message": "chore: version release",
      "files": [
        "packages/clarity-types/CHANGELOG.md",
        "packages/clarity-types/package.json",
        "packages/cli/CHANGELOG.md",
        "packages/cli/package.json"
      ]
    },
    {
      "date": "2025-12-12 21:45:47 -0600",
      "message": "feat(plugin): new testing plugin for clarinet sdk integration",
      "files": [
        ".changeset/README.md",
        ".changeset/config.json",
        "README.md",
        "bun.lock",
        "package.json",
        "packages/cli/package.json",
        "packages/cli/src/commands/generate.ts",
        "packages/cli/src/commands/init.ts",
        "packages/cli/src/generated/provider.tsx",
        "packages/cli/src/plugins/actions/generators.ts",
        "packages/cli/src/plugins/index.ts",
        "packages/cli/src/plugins/testing/generators.ts",
        "packages/cli/src/plugins/testing/index.ts"
      ]
    },
    {
      "date": "2025-12-12 20:50:17 -0600",
      "message": "feat: consolidate to monorepo",
      "files": [
        "README.md",
        "bun.lock",
        "package.json",
        "packages/clarity-types/README.md",
        "packages/clarity-types/bunup.config.ts",
        "packages/clarity-types/package.json",
        "packages/clarity-types/src/abi/extractors.ts",
        "packages/clarity-types/src/abi/functions.ts",
        "packages/clarity-types/src/converters/index.ts",
        "packages/clarity-types/src/index.ts",
        "packages/clarity-types/src/integration/connect.ts",
        "packages/clarity-types/src/types/composites.ts",
        "packages/clarity-types/src/types/mappings.ts",
        "packages/clarity-types/src/types/primitives.ts",
        "packages/clarity-types/src/validation/guards.ts",
        "packages/clarity-types/tests/camelcase-conversion.test.ts",
        "packages/clarity-types/tests/runtime.test.ts",
        "packages/clarity-types/tests/trait-reference.test.ts",
        "packages/clarity-types/tests/types.test.ts",
        "packages/clarity-types/tsconfig.json",
        "packages/clarity-types/vitest.config.ts",
        "packages/cli/bunup.config.ts",
        "packages/cli/package.json",
        "packages/cli/src/cli.ts",
        "packages/cli/src/commands/generate.ts",
        "packages/cli/src/commands/init.ts",
        "packages/cli/src/core/plugin-manager.ts",
        "packages/cli/src/generated/provider.tsx",
        "packages/cli/src/generated/stacks-api.ts",
        "packages/cli/src/generators/contract.ts",
        "packages/cli/src/generators/hooks.ts",
        "packages/cli/src/generators/react-provider.ts",
        "packages/cli/src/generators/stacks-api-generator.ts",
        "packages/cli/src/generators/stacks-api.ts",
        "packages/cli/src/index.ts",
        "packages/cli/src/parsers/clarity.ts",
        "packages/cli/src/plugins/actions/generators.ts",
        "packages/cli/src/plugins/actions/index.ts",
        "packages/cli/src/plugins/clarinet/index.ts",
        "packages/cli/src/plugins/index.ts",
        "packages/cli/src/plugins/react/generators/contract.ts",
        "packages/cli/src/plugins/react/generators/generic.ts",
        "packages/cli/src/plugins/react/generators/utils.ts",
        "packages/cli/src/plugins/react/index.ts",
        "packages/cli/src/plugins/react/provider/context.ts",
        "packages/cli/src/plugins/react/provider/index.ts",
        "packages/cli/src/plugins/react/provider/provider.tsx",
        "packages/cli/src/plugins/react/provider/types.ts",
        "packages/cli/src/plugins/react/types.ts",
        "packages/cli/src/react/config.ts",
        "packages/cli/src/react/hooks.ts",
        "packages/cli/src/react/index.ts",
        "packages/cli/src/react/types.ts",
        "packages/cli/src/types/config.ts",
        "packages/cli/src/types/plugin.ts",
        "packages/cli/src/utils/api.ts",
        "packages/cli/src/utils/config.ts",
        "packages/cli/src/utils/dependencies.ts",
        "packages/cli/tests/actions-plugin.test.ts",
        "packages/cli/tests/buffer-conversion.test.ts",
        "packages/cli/tests/fixtures/counter.clar",
        "packages/cli/tests/fixtures/simple-token.clar",
        "packages/cli/tests/generator.test.ts",
        "packages/cli/tsconfig.json",
        "src/plugins/hiro/index.ts",
        "src/plugins/hiro/types.ts",
        "src/react/index.ts",
        "tests/plugins/hiro.test.ts",
        "tsconfig.json",
        "tsup.config.ts"
      ]
    },
    {
      "date": "2025-05-30 11:17:12 -0500",
      "message": "remove codegen name",
      "files": [
        "README.md",
        "package.json",
        "src/commands/init.ts",
        "src/core/plugin-manager.ts",
        "src/generators/contract.ts",
        "src/index.ts",
        "src/plugins/actions/index.ts",
        "src/plugins/clarinet/index.ts",
        "src/plugins/hiro/index.ts",
        "src/plugins/hiro/types.ts",
        "src/plugins/index.ts",
        "src/plugins/react/index.ts",
        "src/plugins/react/types.ts",
        "src/react/index.ts",
        "src/types/config.ts",
        "src/types/plugin.ts",
        "src/utils/config.ts",
        "tests/plugins/hiro.test.ts"
      ]
    },
    {
      "date": "2025-05-30 11:14:06 -0500",
      "message": "add @secondlayer/clarity-types",
      "files": [
        "bun.lock",
        "package.json",
        "src/generators/contract.ts",
        "src/generators/hooks.ts",
        "src/index.ts",
        "src/parsers/clarity.ts",
        "src/plugins/actions/generators.ts",
        "src/plugins/react/generators/contract.ts",
        "src/plugins/react/generators/generic.ts",
        "tsup.config.ts"
      ]
    },
    {
      "date": "2025-05-28 09:40:07 -0500",
      "message": "chore: update future enhancements",
      "files": [
        "README.md"
      ]
    },
    {
      "date": "2025-05-27 19:34:03 -0500",
      "message": "chore: updates",
      "files": [
        "README.md"
      ]
    },
    {
      "date": "2025-05-27 19:31:28 -0500",
      "message": "chore: updates",
      "files": [
        "README.md"
      ]
    },
    {
      "date": "2025-05-27 19:29:46 -0500",
      "message": "fix: copy edit",
      "files": [
        "README.md"
      ]
    },
    {
      "date": "2025-05-27 19:26:57 -0500",
      "message": "fix: copy edit",
      "files": [
        "README.md"
      ]
    }
  ]
}